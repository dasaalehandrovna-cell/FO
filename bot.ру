# -------------------------------
# –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç "–§–û" ‚Äî –≤–µ—Ä—Å–∏—è 9.8.1 (full)
# Per-chat accounting + PM-owner media forwarding + inline editing restored
# Requires: BOT_TOKEN, OWNER_ID environment variables
# -------------------------------

import os
import json
import time
import re
import csv
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Any, Dict, List, Optional, Tuple

from flask import Flask, request
import telebot
from telebot import types

# Configuration
VERSION = "9.8.1"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/" + TOKEN) if TOKEN else "/webhook"

if not TOKEN:
    raise ValueError("–û—à–∏–±–∫–∞: BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------------
# Data helpers
def default_data() -> Dict[str, Any]:
    return {
        "version_base": "9.6.1",
        "version_current": VERSION,
        "global_balance": 0,
        "chats": {},  # chat_id -> { balance, records, next_id, prefix }
        "active_messages": {},  # day-> { "<chat_id>": { "chat_id": id, "message_id": id } }
        "sent_messages": [],
        "forward_targets": {}  # owner_chat_id -> [targets]
    }

def load_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            print(f"[load_data] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è {DATA_FILE}: {e}")
            d = default_data()
    else:
        d = default_data()
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d: Dict[str, Any]) -> None:
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[save_data] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è {DATA_FILE}: {e}")

data = load_data()

# -------------------------------
# Utilities
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text: str) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    if s.startswith('+'):
        sign = '+'
        digits = s[1:].strip()
    elif s.startswith('-'):
        sign = '-'
        digits = s[1:].strip()
    else:
        sign = ''
        digits = s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    dm = re.match(r'(\d+)', digits_norm)
    if not dm:
        return None, None, None
    return int(dm.group(1)), sign, raw

def apply_sign_and_normalize(num: int, sign: Optional[str]) -> int:
    return num if sign == '+' else -num

def fmt_amount(n: int) -> str:
    return f"{abs(n):,}".replace(",", ".")

def now_iso_utc() -> str:
    return datetime.now(tz=ZoneInfo("UTC")).isoformat()

# -------------------------------
# Per-chat accounting
def ensure_chat_struct(chat_id: str) -> Dict[str, Any]:
    data.setdefault("chats", {})
    if chat_id not in data["chats"]:
        data["chats"][chat_id] = {"balance": 0, "records": [], "next_id": 1, "prefix": "C"}
        save_data(data)
    return data["chats"][chat_id]

def make_short_id(chat_info: Dict[str, Any], n: int) -> str:
    return f"{chat_info.get('prefix','C')}{n}"

def add_record_to_chat(chat_id: str, amount: int, note: str, user: str) -> Dict[str, Any]:
    ch = ensure_chat_struct(chat_id)
    rid = ch.get("next_id", 1)
    short = make_short_id(ch, rid)
    rec = {
        "id": rid,
        "short_id": short,
        "timestamp": now_iso_utc(),
        "amount": amount,
        "note": note,
        "user": user
    }
    ch.setdefault("records", []).append(rec)
    ch["next_id"] = rid + 1
    ch["balance"] = ch.get("balance", 0) + amount
    data["global_balance"] = sum([c.get("balance", 0) for c in data.get("chats", {}).values()])
    save_data(data)
    return rec

def find_record_by_short_id(chat_id: str, short_id: str) -> Optional[Dict[str, Any]]:
    ch = data.get("chats", {}).get(chat_id)
    if not ch:
        return None
    for r in ch.get("records", []):
        if r.get("short_id") == short_id:
            return r
    return None

def delete_record_from_chat(chat_id: str, short_id: str) -> bool:
    ch = data.get("chats", {}).get(chat_id)
    if not ch:
        return False
    for r in ch.get("records", []):
        if r.get("short_id") == short_id:
            ch["records"] = [x for x in ch["records"] if x.get("short_id") != short_id]
            ch["balance"] = ch.get("balance", 0) - r.get("amount", 0)
            data["global_balance"] = sum([c.get("balance", 0) for c in data.get("chats", {}).values()])
            save_data(data)
            return True
    return False

def modify_record_in_chat(chat_id: str, short_id: str, new_amount: int, new_note: str) -> bool:
    ch = data.get("chats", {}).get(chat_id)
    if not ch:
        return False
    for i, r in enumerate(ch.get("records", [])):
        if r.get("short_id") == short_id:
            old = r.get("amount", 0)
            ch["records"][i]["amount"] = new_amount
            ch["records"][i]["note"] = new_note
            ch["balance"] = ch.get("balance", 0) - old + new_amount
            data["global_balance"] = sum([c.get("balance", 0) for c in data.get("chats", {}).values()])
            save_data(data)
            return True
    return False

def export_chat_to_csv(chat_id: str, path: str = CSV_FILE) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    rows = []
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
            date_s = ts.strftime("%Y-%m-%d")
            time_s = ts.strftime("%H:%M:%S")
        except Exception:
            date_s = r.get("timestamp", "")
            time_s = ""
        rows.append([r.get("short_id"), date_s, time_s, r.get("amount"), r.get("note"), r.get("user")])
    with open(path, "w", newline="", encoding="utf-8-sig") as f:
        writer = csv.writer(f)
        writer.writerow(["ID", "–î–∞—Ç–∞", "–í—Ä–µ–º—è", "–°—É–º–º–∞", "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π", "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"])
        for row in rows:
            writer.writerow(row)
    return path

# -------------------------------
# Forward targets helpers
def ensure_forward_list_for(owner_chat_id: str) -> List[str]:
    data.setdefault("forward_targets", {})
    lst = data["forward_targets"].get(owner_chat_id)
    if lst is None:
        data["forward_targets"][owner_chat_id] = []
        save_data(data)
        return data["forward_targets"][owner_chat_id]
    if isinstance(lst, list):
        return lst
    data["forward_targets"][owner_chat_id] = [str(lst)]
    save_data(data)
    return data["forward_targets"][owner_chat_id]

def add_forward_target(owner_chat_id: str, target: str) -> bool:
    lst = ensure_forward_list_for(owner_chat_id)
    t = str(target).strip()
    if t in lst:
        return False
    lst.append(t)
    data["forward_targets"][owner_chat_id] = lst
    save_data(data)
    return True

def remove_forward_target(owner_chat_id: str, target: str) -> bool:
    lst = ensure_forward_list_for(owner_chat_id)
    t = str(target).strip()
    if t in lst:
        lst = [x for x in lst if x != t]
        data["forward_targets"][owner_chat_id] = lst
        save_data(data)
        return True
    return False

def list_forward_targets(owner_chat_id: str) -> List[str]:
    return ensure_forward_list_for(owner_chat_id)

def validate_and_test_target(target_raw: str) -> Tuple[bool, str, str]:
    t_raw = str(target_raw).strip()
    if t_raw.startswith("@"):
        normalized = t_raw
    else:
        try:
            normalized = int(t_raw)
        except Exception:
            normalized = t_raw if t_raw.startswith("@") else "@" + t_raw
    try:
        bot.send_message(normalized, "üîÅ –¢–µ—Å—Ç –æ—Ç –±–æ—Ç–∞: –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏.")
        return True, "–¢–µ—Å—Ç –¥–æ—Å—Ç–∞–≤–ª–µ–Ω.", str(normalized)
    except Exception as e:
        return False, f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç: {e}", str(normalized)

# -------------------------------
# Sending helpers for different media (use file_id to resend)
def record_sent(entry: Dict[str, Any]) -> None:
    data.setdefault("sent_messages", []).append(entry)
    save_data(data)

def send_text(target, text: str, purpose: str="pm_forward_text"):
    try:
        sent = bot.send_message(int(target), text)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "message_id": getattr(sent, "message_id", None), "purpose": purpose, "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose": purpose, "ok": False, "error": str(e)})
        return None

def send_photo_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_photo(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "ok": False, "error": str(e)})
        return None

def send_document_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_document(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "ok": False, "error": str(e)})
        return None

def send_sticker_by_file_id(target, file_id):
    try:
        sent = bot.send_sticker(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "ok": False, "error": str(e)})
        return None

def send_voice_by_file_id(target, file_id):
    try:
        sent = bot.send_voice(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "ok": False, "error": str(e)})
        return None

def send_video_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_video(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "ok": False, "error": str(e)})
        return None

def send_location(target, latitude, longitude):
    try:
        sent = bot.send_location(int(target), latitude, longitude)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "ok": False, "error": str(e)})
        return None

def send_contact(target, phone_number, first_name, last_name=None):
    try:
        sent = bot.send_contact(int(target), phone_number, first_name, last_name)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "ok": False, "error": str(e)})
        return None

# -------------------------------
# PM-owner forwarding block
def pm_owner_forward_block(message: types.Message) -> bool:
    try:
        if getattr(message.chat, "type", "") != "private":
            return False
        if str(message.from_user.id) != str(OWNER_ID):
            return False
        owner_key = str(OWNER_ID)
        targets = data.get("forward_targets", {}).get(owner_key, []) or []
        if not targets:
            return False
        # text
        if message.content_type == 'text':
            text = (message.text or "").strip()
            if not text:
                return True
            for tgt in targets:
                send_text(tgt, text)
            return True
        # photo
        if message.content_type == 'photo' and getattr(message, "photo", None):
            file_id = message.photo[-1].file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_photo_by_file_id(tgt, file_id, caption=caption)
            return True
        # document
        if message.content_type == 'document' and getattr(message, "document", None):
            file_id = message.document.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_document_by_file_id(tgt, file_id, caption=caption)
            return True
        # audio
        if message.content_type == 'audio' and getattr(message, "audio", None):
            file_id = message.audio.file_id
            for tgt in targets:
                try:
                    bot.send_audio(int(tgt), file_id)
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": True})
                except Exception as e:
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": False, "error": str(e)})
            return True
        # voice
        if message.content_type == 'voice' and getattr(message, "voice", None):
            file_id = message.voice.file_id
            for tgt in targets:
                send_voice_by_file_id(tgt, file_id)
            return True
        # sticker
        if message.content_type == 'sticker' and getattr(message, "sticker", None):
            file_id = message.sticker.file_id
            for tgt in targets:
                send_sticker_by_file_id(tgt, file_id)
            return True
        # video
        if message.content_type == 'video' and getattr(message, "video", None):
            file_id = message.video.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_video_by_file_id(tgt, file_id, caption=caption)
            return True
        # location
        if message.content_type == 'location' and getattr(message, "location", None):
            lat = message.location.latitude
            lon = message.location.longitude
            for tgt in targets:
                send_location(tgt, lat, lon)
            return True
        # contact
        if message.content_type == 'contact' and getattr(message, "contact", None):
            phone = message.contact.phone_number
            first = message.contact.first_name
            last = getattr(message.contact, "last_name", None)
            for tgt in targets:
                send_contact(tgt, phone, first, last)
            return True
        # fallback: try forward
        for tgt in targets:
            try:
                try:
                    bot.forward_message(int(tgt), message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
                except Exception:
                    bot.forward_message(tgt, message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
            except Exception as e:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": False, "error": str(e)})
        return True
    except Exception as e:
        print(f"[pm_owner_forward_block] –û—à–∏–±–∫–∞: {e}")
        try:
            bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –±–ª–æ–∫–∞ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –ª–∏—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π: {e}")
        except Exception:
            pass
        return False

# -------------------------------
# Auto-forward for chats (forward message as forward)
def auto_forward_message_from(chat_id: str, message: types.Message) -> None:
    targets = data.get("forward_targets", {}).get(str(chat_id)) or []
    if not targets:
        return
    for t in targets:
        try:
            try:
                bot.forward_message(int(t), int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
            except Exception:
                bot.forward_message(t, int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
        except Exception as e:
            try:
                if message.content_type == 'text' and getattr(message, "text", None):
                    bot.send_message(t, f"üì® –ö–æ–ø–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ {chat_id}:\n\n{message.text}")
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"sent_copy"})
                else:
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e)})
            except Exception as e2:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e2)})

# -------------------------------
# Build day window per chat
def build_day_window_for_chat(chat_id: str, day_date: str) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    recs = []
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        except Exception:
            try:
                ts = datetime.fromisoformat(r["timestamp"])
                ts = ts.astimezone(TZ)
            except Exception:
                ts = None
        if ts and ts.strftime("%Y-%m-%d") == day_date:
            recs.append((ts, r))
    recs.sort(key=lambda x: x[0])
    if not recs:
        return "üìò –ó–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –µ—â—ë –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π."
    lines = [f"üìÖ {day_date}\n"]
    day_income = 0
    day_expense = 0
    last_hour = None
    for ts, r in recs:
        hour = ts.strftime("%H")
        if last_hour and hour != last_hour:
            lines.append("")
        last_hour = hour
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        sid = r.get("short_id")
        note = r.get("note", "")
        t_local = ts.strftime("%H:%M")
        lines.append(f"üïì {t_local} | {sid} | {sign}{fmt_amount(amt)} {note}".rstrip())
        if amt > 0:
            day_income += amt
        else:
            day_expense += abs(amt)
    overall = data.get("chats", {}).get(chat_id, {}).get("balance", 0)
    lines.append("")
    lines.append(f"üìà –ü—Ä–∏—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_income)}")
    lines.append(f"üìâ –†–∞—Å—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_expense)}")
    lines.append(f"üíµ –ë–∞–ª–∞–Ω—Å —á–∞—Ç–∞: {fmt_amount(overall)}")
    return "\n".join(lines)

# Keyboards for inline editing
def kb_day_main():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_menu"))
    return kb

def kb_edit_main(chat_id=None):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–ò–∑–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å", callback_data="edit_modify"))
    kb.add(types.InlineKeyboardButton("–£–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å", callback_data="edit_delete"))
    kb.add(types.InlineKeyboardButton("üìÑ –≠–∫—Å–ø–æ—Ä—Ç CSV", callback_data="edit_export_csv"))
    kb.add(types.InlineKeyboardButton("–û–±–Ω—É–ª–∏—Ç—å –≤—Å—ë (–≤—Å–µ—Ö)", callback_data="edit_reset_all"))
    target = data.get("forward_targets", {}).get(str(chat_id)) if chat_id is not None else None
    if target:
        kb.add(types.InlineKeyboardButton("üö´ –û—Ç–∫–ª—é—á–∏—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫—É", callback_data="forward_cancel"))
    else:
        kb.add(types.InlineKeyboardButton("üì§ –ü–µ—Ä–µ—Å—ã–ª–∫–∞", callback_data="forward_setup"))
    kb.add(types.InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="edit_cancel"))
    return kb

def kb_forward_menu(chat_id=None):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("üîß –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫—É (–ø–µ—Ä–µ—à–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –Ω—É–∂–Ω–æ–≥–æ —á–∞—Ç–∞)", callback_data="forward_setup"))
    kb.add(types.InlineKeyboardButton("‚ùå –û—Ç–∫–ª—é—á–∏—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫—É", callback_data="forward_cancel"))
    kb.add(types.InlineKeyboardButton("‚ÑπÔ∏è –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–µ–∫—É—â—É—é", callback_data="forward_check"))
    kb.add(types.InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="edit_cancel"))
    return kb

def kb_records_list(chat_id, day_date, mode):
    kb = types.InlineKeyboardMarkup()
    recs = []
    ch = data.get("chats", {}).get(str(chat_id), {"records": []})
    for ts, r in sorted([(datetime.fromisoformat(x["timestamp"]).astimezone(TZ), x) for x in ch.get("records", [])], key=lambda xx: xx[0]):
        if ts.strftime("%Y-%m-%d") != day_date:
            continue
        sid = r.get("short_id")
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        label = f"[{sid}] {sign}{fmt_amount(amt)} {r.get('note','')}"
        recs.append((sid, label))
    if not recs:
        kb.add(types.InlineKeyboardButton("–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –∑–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å", callback_data="no_op"))
        kb.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="edit_menu"))
        return kb
    for sid, label in recs:
        kb.add(types.InlineKeyboardButton(label[:60], callback_data=f"select:{mode}:{sid}"))
    kb.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="edit_menu"))
    return kb

def kb_yes_no(cb_prefix):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–î–∞", callback_data=f"{cb_prefix}_yes"),
           types.InlineKeyboardButton("–ù–µ—Ç", callback_data=f"{cb_prefix}_no"))
    return kb

# -------------------------------
pending_actions: Dict[str, Dict[str, Any]] = {}

# -------------------------------
# Message handler
@bot.message_handler(func=lambda m: True, content_types=['text','photo','document','audio','video','voice','sticker','animation','contact','location'])
def handle_any_message(message: types.Message):
    global data
    chat_id = message.chat.id
    data = load_data()

    # 0) PM-owner forwarding: if private and from OWNER -> send copies to targets and stop
    handled = pm_owner_forward_block(message)
    if handled:
        return

    # 1) pending actions
    pa = pending_actions.get(str(chat_id))
    if pa:
        t = pa.get("type")
        if t == "await_forward_setup":
            target = None
            if getattr(message, "forward_from_chat", None):
                try:
                    target = str(message.forward_from_chat.id)
                except Exception:
                    target = None
            elif getattr(message, "forward_from", None):
                try:
                    target = str(message.forward_from.id)
                except Exception:
                    target = None
            elif message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() == "–æ—Ç–º–µ–Ω–∞":
                    send_text(chat_id, "–û—Ç–º–µ–Ω–µ–Ω–æ")
                    pending_actions.pop(str(chat_id), None)
                    return
                target = txt
            if not target:
                send_text(chat_id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä. –û—Ç–º–µ–Ω–∞.")
                pending_actions.pop(str(chat_id), None)
                return
            ok, msg_text, norm = validate_and_test_target(target)
            if ok:
                added = add_forward_target(str(chat_id), norm)
                if added:
                    send_text(chat_id, f"‚úÖ –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞: {norm}")
                else:
                    send_text(chat_id, f"‚ÑπÔ∏è –¶–µ–ª—å —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ: {norm}")
            else:
                send_text(chat_id, f"‚ùå {msg_text}")
            pending_actions.pop(str(chat_id), None)
            return

        if t == "await_modify_input":
            short = pa["payload"]["short_id"]
            text = (message.text or "").strip()
            ok = False
            if text:
                num, sign, raw = parse_first_number(text)
                if num is not None:
                    new_amt = apply_sign_and_normalize(num, sign)
                    note = text[(text.find(raw)+len(raw)):].strip() if raw in text else ""
                    ok = modify_record_in_chat(str(chat_id), short, new_amt, note)
            if ok:
                send_text(chat_id, f"‚úÖ –ó–∞–ø–∏—Å—å {short} –æ–±–Ω–æ–≤–ª–µ–Ω–∞.")
            else:
                send_text(chat_id, f"‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å {short}. –ü—Ä–∏–º–µ—Ä: +1000 –∑–∞—Ä–ø–ª–∞—Ç–∞")
            pending_actions.pop(str(chat_id), None)
            # refresh day window
            today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            try:
                update_day_window_after_change(chat_id, today)
            except Exception:
                pass
            return

        if t == "await_remove_forward":
            if message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() in ('–≤—Å—ë','–≤—Å–µ','all'):
                    data["forward_targets"].pop(str(chat_id), None)
                    save_data(data)
                    send_text(chat_id, "‚úÖ –í—Å–µ —Ü–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ —É–¥–∞–ª–µ–Ω—ã.")
                else:
                    removed = remove_forward_target(str(chat_id), txt)
                    if removed:
                        send_text(chat_id, f"‚úÖ –¶–µ–ª—å {txt} —É–¥–∞–ª–µ–Ω–∞.")
                    else:
                        send_text(chat_id, f"‚ùó –¶–µ–ª—å {txt} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
            else:
                send_text(chat_id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥, –æ—Ç–º–µ–Ω–µ–Ω–æ.")
            pending_actions.pop(str(chat_id), None)
            return

    # 2) Auto-forward from group/chat if configured (for readers who set per-chat forward)
    try:
        auto_forward_message_from(str(chat_id), message)
    except Exception as e:
        print(f"[auto_forward] –û—à–∏–±–∫–∞: {e}")

    # 3) Accounting: messages of any participants in groups + private (per-chat accounting)
    if message.content_type == 'text':
        text = (message.text or "").strip()
        lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
        any_added = False
        for line in lines:
            num, sign, raw = parse_first_number(line)
            if num is None:
                continue
            amt_signed = apply_sign_and_normalize(num, sign)
            note = line[(line.find(raw) + len(raw)):].strip() if raw in line else ""
            user_display = (message.from_user.username or message.from_user.first_name or str(message.from_user.id))
            add_record_to_chat(str(chat_id), amt_signed, note, user_display)
            any_added = True
        if any_added:
            today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            try:
                update_day_window_after_change(chat_id, today)
            except Exception as e:
                print(f"[day window update] {e}")
        return

# -------------------------------
# Update day window with editing and forwarding
def update_day_window_after_change(chat_id, day_date, purpose="day_window"):
    # build text
    text = build_day_window_for_chat(str(chat_id), day_date)
    kb = kb_day_main()
    prev = data.get("active_messages", {}).get(day_date, {}).get(str(chat_id))
    # Try to edit existing message (search in active_messages structure)
    # Our active_messages: day -> { "<chat_id>": {"chat_id":id, "message_id": id} }
    try:
        day_map = data.get("active_messages", {}).get(day_date, {})
        prev_entry = day_map.get(str(chat_id))
        if prev_entry and int(prev_entry.get("chat_id")) == int(chat_id):
            try:
                bot.edit_message_text(chat_id=int(chat_id), message_id=int(prev_entry.get("message_id")), text=text, reply_markup=kb)
                # record as edited
                fake_msg = types.Message.de_json({"message_id": int(prev_entry.get("message_id"))}, bot)
                record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(prev_entry.get("message_id")), "purpose": purpose, "ok": True})
                save_data(data)
                return prev_entry
            except Exception as e:
                print(f"[update_day_window] edit failed: {e}")
        # send new
        sent = bot.send_message(int(chat_id), text, reply_markup=kb)
        data.setdefault("active_messages", {}).setdefault(day_date, {})[str(chat_id)] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
        record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(sent.message_id), "purpose": purpose, "ok": True})
        save_data(data)
    except Exception as e:
        print(f"[update_day_window] failed to send: {e}")

    # forward the day window if forward_targets set for this chat (not owner's personal forward)
    forward_targets_map = data.get("forward_targets", {})
    forward_target = forward_targets_map.get(str(chat_id))
    if forward_target:
        for ft in forward_target:
            try:
                try:
                    bot.forward_message(int(ft), int(chat_id), sent.message_id)
                except Exception:
                    bot.forward_message(ft, int(chat_id), sent.message_id)
            except Exception as e:
                print(f"[update_day_window] forward failed to {ft}: {e}")

# -------------------------------
# Callback handler (inline)
@bot.callback_query_handler(func=lambda call: True)
def callback_worker(call: types.CallbackQuery):
    data_local = load_data()
    data_call = call.data or ""
    chat_id = call.message.chat.id
    call_msg = call.message
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    try:
        bot.answer_callback_query(call.id)
    except Exception:
        pass

    if data_call == "edit_menu":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
        except Exception:
            send_text(chat_id, "–ú–µ–Ω—é —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:",)
        return

    if data_call == "edit_cancel":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_day_main())
        except Exception:
            try:
                send_text(chat_id, build_day_window_for_chat(str(chat_id), today))
            except Exception:
                pass
        return

    if data_call == "edit_modify":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_records_list(chat_id, today, mode="modify"))
        except Exception:
            send_text(chat_id, "–í—ã–±–æ—Ä –∑–∞–ø–∏—Å–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:",)
        return

    if data_call == "edit_delete":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_records_list(chat_id, today, mode="delete"))
        except Exception:
            send_text(chat_id, "–í—ã–±–æ—Ä –∑–∞–ø–∏—Å–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",)
        return

    if data_call in ("edit_export_csv",):
        try:
            path = export_chat_to_csv(str(chat_id), CSV_FILE)
            bot.send_document(chat_id, open(path, "rb"))
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
            except Exception:
                pass
        except Exception as e:
            print(f"[export csv] {e}")
            send_text(chat_id, "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ CSV.")
        return

    if data_call == "forward_setup":
        send_text(chat_id, "–ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å—é–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –Ω—É–∂–Ω–æ–≥–æ —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ chat_id/@username. –û—Ç–ø—Ä–∞–≤—å—Ç–µ '–æ—Ç–º–µ–Ω–∞' –¥–ª—è –æ—Ç–∫–∞–∑–∞.")
        pending_actions[str(chat_id)] = {"type":"await_forward_setup","payload":{}}
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=None)
        except Exception:
            pass
        return

    if data_call == "forward_check":
        ft = data.get("forward_targets", {}).get(str(chat_id))
        if ft:
            send_text(chat_id, f"üì® –¢–µ–∫—É—â–∏–µ —Ü–µ–ª–∏: {', '.join(ft)}")
        else:
            send_text(chat_id, "üîï –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.")
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
        except Exception:
            pass
        return

    if data_call == "forward_cancel":
        ft = data.get("forward_targets", {})
        if str(chat_id) in ft:
            ft.pop(str(chat_id), None)
            data["forward_targets"] = ft
            save_data(data)
            send_text(chat_id, "‚úÖ –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞.")
        else:
            send_text(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –±—ã–ª–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.")
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
        except Exception:
            pass
        return

    if data_call.startswith("select:"):
        parts = data_call.split(":", 2)
        if len(parts) != 3:
            send_text(chat_id, "–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä.")
            return
        mode = parts[1]
        short_id = parts[2]
        if mode == "modify":
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=None)
            except Exception:
                pass
            send_text(chat_id, f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è {short_id} (–ø—Ä–∏–º–µ—Ä: +1000 –∑–∞—Ä–ø–ª–∞—Ç–∞).")
            pending_actions[str(chat_id)] = {"type":"await_modify_input","payload":{"short_id": short_id}}
            return
        elif mode == "delete":
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_yes_no(f"confirm_delete:{short_id}"))
            except Exception:
                send_text(chat_id, f"–£–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å {short_id}?",)
            return
        else:
            send_text(chat_id, "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞.")
            return

    if data_call.startswith("confirm_delete:"):
        tail = data_call[len("confirm_delete:"):]
        if tail.endswith("_yes"):
            short_id = tail[:-4]
            ok = delete_record_from_chat(str(chat_id), short_id)
            if ok:
                try:
                    bot.edit_message_text(f"‚úÖ –ó–∞–ø–∏—Å—å {short_id} —É–¥–∞–ª–µ–Ω–∞.", call_msg.chat.id, call_msg.message_id)
                except Exception:
                    send_text(chat_id, f"‚úÖ –ó–∞–ø–∏—Å—å {short_id} —É–¥–∞–ª–µ–Ω–∞.")
                # refresh window
                try:
                    update_day_window_after_change(chat_id, today)
                except Exception:
                    pass
            else:
                try:
                    bot.edit_message_text(f"‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å {short_id}.", call_msg.chat.id, call_msg.message_id)
                except Exception:
                    send_text(chat_id, f"‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å {short_id}.")
        else:
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
            except Exception:
                send_text(chat_id, "–£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.",)
        return

    if data_call == "edit_reset_all":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_yes_no("confirm_reset_all"))
        except Exception:
            send_text(chat_id, "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω—É–ª–∏—Ç—å –í–°–ï –¥–∞–Ω–Ω—ã–µ –Ω–∞–≤—Å–µ–≥–¥–∞? (–î–∞/–ù–µ—Ç)")
        return

    if data_call.startswith("confirm_reset_all"):
        if data_call.endswith("_yes"):
            data.update(default_data())
            save_data(data)
            try:
                bot.edit_message_text("‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã.", call_msg.chat.id, call_msg.message_id)
            except Exception:
                send_text(chat_id, "‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã.")
        else:
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
            except Exception:
                send_text(chat_id, "–û–±–Ω—É–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
        return

    if data_call in ("no_op",):
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_day_main())
        except Exception:
            try:
                send_text(chat_id, build_day_window_for_chat(str(chat_id), today))
            except Exception:
                pass
        return

    print("Unhandled callback:", data_call)

# -------------------------------
# Commands (forward management and accounting)
@bot.message_handler(commands=['addforward'])
def cmd_addforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.")
        return
    send_text(message.chat.id, "–ü–µ—Ä–µ—à–ª–∏—Ç–µ –º–Ω–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ü–µ–ª–µ–≤–æ–≥–æ —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ chat_id/@username.")
    pending_actions[str(message.chat.id)] = {"type": "await_forward_setup", "payload": {}}

@bot.message_handler(commands=['removeforward'])
def cmd_removeforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.")
        return
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "–°–ø–∏—Å–æ–∫ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –ø—É—Å—Ç.")
        return
    send_text(message.chat.id, "–°–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π:\n" + "\n".join(lst) + "\n–û—Ç–ø—Ä–∞–≤—å —Ü–µ–ª—å –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∏–ª–∏ '–≤—Å—ë' –¥–ª—è –æ—á–∏—Å—Ç–∫–∏.")
    pending_actions[str(message.chat.id)] = {"type": "await_remove_forward", "payload": {}}

@bot.message_handler(commands=['listforwards'])
def cmd_listforwards(message: types.Message):
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.")
    else:
        send_text(message.chat.id, "–¢–µ–∫—É—â–∏–µ —Ü–µ–ª–∏:\n" + "\n".join(lst))

@bot.message_handler(commands=["–±–∞–ª–∞–Ω—Å"])
def cmd_balance(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"balance": 0})
    bot.reply_to(message, f"üí∞ –ë–∞–ª–∞–Ω—Å —ç—Ç–æ–≥–æ —á–∞—Ç–∞: {fmt_amount(ch.get('balance', 0))}")

@bot.message_handler(commands=["–æ—Ç—á–µ—Ç"])
def cmd_report(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    if not ch.get("records"):
        bot.reply_to(message, "–ü–æ–∫–∞ –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π –≤ —ç—Ç–æ–º —á–∞—Ç–µ.")
        return
    try:
        path = export_chat_to_csv(chat_id, CSV_FILE)
        bot.send_document(message.chat.id, open(path, "rb"))
    except Exception as e:
        bot.reply_to(message, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ: {e}")

@bot.message_handler(commands=["—Å–±—Ä–æ—Å"])
def cmd_reset(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç –æ–±–Ω—É–ª–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.")
        return
    data.update(default_data())
    save_data(data)
    bot.reply_to(message, "‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã (–≥–ª–æ–±–∞–ª—å–Ω–æ).")

# -------------------------------
# Webhook endpoint
@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    try:
        json_str = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
    except Exception as e:
        print(f"[webhook] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ update: {e}")
    return '', 200

@app.route("/", methods=['GET'])
def index():
    return f"ü§ñ –ë–æ—Ç '–§–û' v{VERSION} —Ä–∞–±–æ—Ç–∞–µ—Ç."

# -------------------------------
def set_webhook_if_possible():
    try:
        host = os.getenv("RENDER_EXTERNAL_HOSTNAME")
        if host:
            url = f"https://{host}{WEBHOOK_PATH}"
            bot.remove_webhook()
            time.sleep(0.3)
            bot.set_webhook(url=url)
            print(f"[startup] Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {url}")
            if OWNER_ID:
                try:
                    bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION}: webhook –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.")
                except Exception:
                    pass
    except Exception as e:
        print(f"[set_webhook_if_possible] {e}")

# -------------------------------
if __name__ == "__main__":
    print(f"–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ '–§–û' v{VERSION} ...")
    save_data(data)
    set_webhook_if_possible()
    try:
        bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION} –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤.")
    except Exception:
        pass
    app.run(host="0.0.0.0", port=PORT)

# -------------------------------
# EOF
# -------------------------------