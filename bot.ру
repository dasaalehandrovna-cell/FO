# ============================================
# Финансовый бот — версия 9.8.3
# Полная версия с одним окном, CSV, редактированием и подтверждениями
# Отсеки 1–16
# ============================================

# -----------------------------
# ОТСЕК 1 — Импорты и настройки
# -----------------------------
import os
import json
import csv
import logging
import re
import threading
import time
from datetime import datetime
from zoneinfo import ZoneInfo

import telebot
from flask import Flask, request
from telebot import types

TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
APP_URL = os.getenv("APP_URL", "https://yourapp.onrender.com")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
LOG_FILE = "log.txt"
PORT = int(os.environ.get("PORT", 5000))
VERSION = "9.8.3"

if not TOKEN:
    raise ValueError("BOT_TOKEN не установлен!")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -----------------------------
# ОТСЕК 2 — Логирование
# -----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="[{asctime}] {levelname}: {message}",
    style="{",
    handlers=[logging.FileHandler(LOG_FILE, encoding="utf-8"), logging.StreamHandler()]
)

def log_info(msg):
    logging.info(msg)
def log_error(msg):
    logging.error(msg)

log_info(f"Старт приложения. Версия {VERSION}")

# -----------------------------
# ОТСЕК 3 — Структура данных и IO
# -----------------------------
def default_data():
    return {
        "overall_balance": 0,
        "records": [],
        "chats": {},
        "active_messages": {},
        "processed_messages": [],
        "forward_targets": [],
        "tracked_messages": {},
        "next_id": 1
    }

def load_data():
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except:
            d = default_data()
    else:
        d = default_data()
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d):
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        log_error(f"Ошибка сохранения data.json: {e}")

data = load_data()

if OWNER_ID:
    try:
        oi = int(OWNER_ID)
        if oi not in data.get("forward_targets", []):
            data["forward_targets"].append(oi)
            save_data(data)
    except Exception:
        pass

# -----------------------------
# ОТСЕК 4 — Чат/дата
# -----------------------------
def get_today_key():
    return datetime.now(TZ).strftime("%Y-%m-%d")

def get_chat_store(chat_id):
    cid = str(chat_id)
    if cid not in data["chats"]:
        data["chats"][cid] = {"balance": 0, "records": [], "next_id": 1, "daily_records": {}, "active_windows": {}, "edit_wait": None, "edit_target": None}
        save_data(data)
    return data["chats"][cid]

def get_today_active_window(chat_id):
    today = get_today_key()
    day_map = data["active_messages"].get(today, {})
    return day_map.get(str(chat_id))

def set_today_active_window(chat_id, message_id):
    today = get_today_key()
    if "active_messages" not in data:
        data["active_messages"] = {}
    if today not in data["active_messages"]:
        data["active_messages"][today] = {}
    data["active_messages"][today][str(chat_id)] = message_id
    save_data(data)

# -----------------------------
# ОТСЕК 5 — Работа с записями
# -----------------------------
def add_record_to_chat(chat_id, amount, note, owner):
    store = get_chat_store(chat_id)
    rid = data.get("next_id", 1)
    rec = {"id": rid, "short_id": f"R{rid}", "timestamp": datetime.now(TZ).isoformat(timespec="seconds"), "amount": amount, "note": note, "owner": owner}
    data.setdefault("records", []).append(rec)
    store.setdefault("records", []).append(rec)
    day = get_today_key()
    store.setdefault("daily_records", {}).setdefault(day, []).append(rec)
    store["balance"] = store.get("balance", 0) + amount
    data["overall_balance"] = data.get("overall_balance", 0) + amount
    data["next_id"] = rid + 1
    save_data(data)
    try:
        export_to_csv(data)
    except:
        pass
    return rec

def update_record_in_chat(chat_id, rid, new_amount, new_note):
    store = get_chat_store(chat_id)
    found = None
    for r in store.get("records", []):
        if r["id"] == rid:
            r["amount"] = new_amount
            r["note"] = new_note
            found = r
            break
    if found:
        for day_recs in store.get("daily_records", {}).values():
            for r in day_recs:
                if r["id"] == rid:
                    r.update(found)
        store["balance"] = sum([x["amount"] for x in store.get("records", [])])
        data["overall_balance"] = sum([x["amount"] for x in data.get("records", [])])
        save_data(data)
        export_to_csv(data)
        return True, found
    return False, None

def delete_record_in_chat(chat_id, rid):
    store = get_chat_store(chat_id)
    removed = None
    for r in list(store.get("records", [])):
        if r["id"] == rid or str(r["id"]) == str(rid) or r.get("short_id") == f"R{rid}":
            removed = r
            store["records"].remove(r)
            break
    if removed:
        for day_key, recs in store.get("daily_records", {}).items():
            store["daily_records"][day_key] = [x for x in recs if x["id"] != rid]
        store["balance"] = sum([x["amount"] for x in store.get("records", [])])
        data["records"] = [x for x in data.get("records", []) if x["id"] != rid]
        data["overall_balance"] = sum([x["amount"] for x in data.get("records", [])])
        save_data(data)
        export_to_csv(data)
        return True, removed
    return False, None

def export_to_csv(d):
    try:
        with open(CSV_FILE, "w", newline='', encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["chat_id","ID","short_id","timestamp","amount","note","owner","day_key"])
            for cid, cdata in d.get("chats", {}).items():
                for day_key, records in cdata.get("daily_records", {}).items():
                    for r in records:
                        writer.writerow([cid, r.get("id"), r.get("short_id"), r.get("timestamp"), r.get("amount"), r.get("note"), r.get("owner"), day_key])
    except Exception as e:
        log_error(f"Ошибка экспорта CSV: {e}")

# -----------------------------
# ОТСЕК 6 — Клавиатуры
# -----------------------------
def build_main_keyboard(chat_id=None, confirm_reset=False):
    kb = types.InlineKeyboardMarkup(row_width=3)
    kb.row(
        types.InlineKeyboardButton("💰 Баланс", callback_data="btn_balance"),
        types.InlineKeyboardButton("📊 Отчёт", callback_data="btn_report"),
        types.InlineKeyboardButton("📂 CSV", callback_data="btn_csv")
    )
    # Добавляем кнопку редактирования
    kb.row(types.InlineKeyboardButton("✏️ Редактировать", callback_data="btn_edit_list"))
    if confirm_reset:
        kb.row(
            types.InlineKeyboardButton("✅ Да", callback_data="confirm_reset"),
            types.InlineKeyboardButton("❌ Нет", callback_data="cancel_reset")
        )
    else:
        kb.row(types.InlineKeyboardButton("⚙️ Обнулить данные", callback_data="btn_reset"))
    kb.row(
        types.InlineKeyboardButton("🚀 Обновить", callback_data="btn_start"),
        types.InlineKeyboardButton("ℹ️ Инфо", callback_data="btn_cod")
    )
    balance_text = ""
    if chat_id is not None:
        store = get_chat_store(chat_id)
        balance_text = f"💰 {store.get('balance', 0)} ARS"
    kb.add(types.InlineKeyboardButton(balance_text or "💰 0 ARS", callback_data="noop"))
    return kb

def build_edit_keyboard_for_record(rid):
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.row(
        types.InlineKeyboardButton("✏ Изменить", callback_data=f"edit_change_{rid}"),
        types.InlineKeyboardButton("🗑 Удалить", callback_data=f"edit_delete_{rid}")
    )
    kb.add(types.InlineKeyboardButton("🔙 Назад", callback_data="edit_back_to_list"))
    return kb

def build_confirm_delete_keyboard(rid):
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.row(types.InlineKeyboardButton("✅ Да, удалить", callback_data=f"confirm_delete_{rid}"),
           types.InlineKeyboardButton("❌ Отмена", callback_data="cancel_delete"))
    return kb

# -----------------------------
# ОТСЕК 7 — Обновление/создание окна
# -----------------------------
def update_or_send_today_window(chat_id, create_if_missing=True):
    today_key = get_today_key()
    store = get_chat_store(chat_id)
    day_records = store.get("daily_records", {}).get(today_key, [])

    daily_income = sum(r["amount"] for r in day_records if r["amount"] > 0)
    daily_expense = sum(r["amount"] for r in day_records if r["amount"] < 0)
    overall_balance = store.get("balance", 0)

    if not day_records:
        text = (
            f"📅 {today_key}\n"
            f"Пока нет операций.\n"
            f"💵 Приход: {daily_income} ARS\n"
            f"💸 Расход: {abs(daily_expense)} ARS\n"
            f"💰 Общий остаток: {overall_balance} ARS"
        )
    else:
        lines = [f"📅 {today_key}", "📋 Операции:"]
        for r in day_records[-50:]:
            sign = "+" if r["amount"] > 0 else "-"
            lines.append(f"{r['short_id']}: {sign}{abs(r['amount'])} — {r.get('note','')}")
        lines.append(
            f"\n💵 Приход: {daily_income} ARS\n"
            f"💸 Расход: {abs(daily_expense)} ARS\n"
            f"💰 Общий остаток: {overall_balance} ARS"
        )
        text = "\n".join(lines)

    kb = build_main_keyboard(chat_id)
    today_msgs = data.setdefault("active_messages", {}).setdefault(today_key, {})
    active_id = today_msgs.get(str(chat_id))

    # Если активное окно есть — редактируем его
    if active_id:
        try:
            bot.edit_message_text(text, chat_id, active_id, reply_markup=kb)
        except telebot.apihelper.ApiException as e:
            log_error(f"Не удалось редактировать окно {active_id} для чата {chat_id}: {e}")
        return

    # Если create_if_missing=False — не создаём новое окно
    if not create_if_missing:
        return

    # Создаём новое окно, если активного нет
    try:
        sent = bot.send_message(chat_id, text, reply_markup=kb)
        today_msgs[str(chat_id)] = sent.message_id
        save_data(data)
    except Exception as e:
        log_error(f"Ошибка при создании нового окна для {chat_id}: {e}")

@bot.message_handler(commands=["start"])
def handle_start(msg):
    chat_id = msg.chat.id
    update_or_send_today_window(chat_id, create_if_missing=True)

# -----------------------------
# ОТСЕК 8 — Callback кнопок
# -----------------------------
@bot.callback_query_handler(func=lambda c: True)
def handle_callback(call):
    try:
        chat_id = call.message.chat.id
    except Exception:
        # Защита на случай inline-ответа без сообщения
        return
    store = get_chat_store(chat_id)
    today_key = get_today_key()
    day_records = store.get("daily_records", {}).get(today_key, [])
    today_msgs = data.setdefault("active_messages", {}).setdefault(today_key, {})
    active_id = today_msgs.get(str(chat_id))

    # ---------- Баланс ----------
    if call.data == "btn_balance":
        daily_income = sum(r["amount"] for r in day_records if r["amount"] > 0)
        daily_expense = sum(r["amount"] for r in day_records if r["amount"] < 0)
        overall_balance = store.get("balance", 0)

        text = (
            f"📅 {today_key}\n\n"
            f"💰 Общий остаток: {overall_balance} ARS\n"
            f"💵 Приход за сегодня: {daily_income} ARS\n"
            f"💸 Расход за сегодня: {abs(daily_expense)} ARS"
        )

        if active_id:
            try:
                bot.edit_message_text(text, chat_id, active_id, reply_markup=build_main_keyboard(chat_id))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка редактирования окна (Баланс): {e}")
        else:
            update_or_send_today_window(chat_id)

        bot.answer_callback_query(call.id, "Баланс обновлён ✅")
        return

    # ---------- Отчёт (расходы) ----------
    if call.data == "btn_report":
        expenses = [r for r in day_records if r["amount"] < 0]
        daily_expense_total = sum(abs(r["amount"]) for r in expenses)

        if not expenses:
            text = f"📅 {today_key}\nПока нет расходов за сегодня.\n💸 Расход за день: 0 ARS"
        else:
            lines = [f"📅 {today_key}", "📋 Расходы за день:"]
            for r in expenses[-30:]:
                lines.append(f"{r['short_id']}: -{abs(r['amount'])} — {r.get('note','')}")
            lines.append(f"\n💸 Расход за день: {daily_expense_total} ARS")
            text = "\n".join(lines)

        if active_id:
            try:
                bot.edit_message_text(text, chat_id, active_id, reply_markup=build_main_keyboard(chat_id))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка редактирования окна (Отчёт расходов): {e}")
        else:
            update_or_send_today_window(chat_id)

        bot.answer_callback_query(call.id, "Отчёт расходов обновлён 📊")
        return

    # ---------- CSV ----------
    if call.data == "btn_csv":
        try:
            with open(CSV_FILE, "rb") as f:
                bot.send_document(chat_id, f, caption="📂 Ваш файл data.csv")
            bot.answer_callback_query(call.id, "CSV отправлен 📁")
        except Exception as e:
            bot.send_message(chat_id, f"❌ Ошибка при отправке CSV: {e}")
            bot.answer_callback_query(call.id)
        return

    # ---------- Обнуление (с подтверждением) ----------
    if call.data == "btn_reset":
        # Показываем клавиатуру подтверждения в том же окне
        if active_id:
            try:
                bot.edit_message_text("⚠️ Вы уверены? Это удалит все записи. Подтвердите:", chat_id, active_id, reply_markup=build_main_keyboard(chat_id, confirm_reset=True))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка при показе подтверждения сброса: {e}")
        else:
            update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id)
        return

    if call.data == "confirm_reset":
        # Выполняем полный сброс для этого чата
        store["records"] = []
        store["daily_records"] = {}
        store["balance"] = 0
        # также удаляем из глобальных записей
        data["records"] = [x for x in data.get("records", []) if x.get("owner") != chat_id]
        # обновляем общий баланс корректно
        # (в этом простом варианте пересчитаем по имеющимся записям)
        try:
            data["overall_balance"] = sum([x["amount"] for x in data.get("records", [])])
        except:
            data["overall_balance"] = 0
        save_data(data)
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Данные сброшены 🧹")
        return

    if call.data == "cancel_reset":
        # Отмена подтверждения — возвращаем главное окно
        if active_id:
            try:
                update_or_send_today_window(chat_id)
            except:
                pass
        bot.answer_callback_query(call.id, "Отмена")
        return

    # ---------- Обновить ----------
    if call.data == "btn_start":
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Окно обновлено 🔄")
        return

    # ---------- Инфо (редактируется в том же окне) ----------
    if call.data == "btn_cod":
        info_text = (
            f"ℹ️ Финансовый бот — версия {VERSION}\n\n"
            "📌 Доступные команды:\n"
            "/start - Запуск бота и создание окна отчёта на сегодня\n"
            "/balance - Показать общий остаток за день\n"
            "/report - Показать список расходов текущего дня\n"
            "/csv - Скачать файл с историей операций\n"
            "/reset - Полностью очистить все записи (с подтверждением)\n"
            "/update - Обновить текущее окно\n"
            "/info - Показать это окно со списком команд\n\n"
            "📝 Добавление операций (в сообщении):\n"
            "+500 Зарплата\n"
            "-150 Обед\n"
            "200 Такси  (без знака = расход)\n\n"
            "✏️ Нажмите «✏️ Редактировать», чтобы управлять записями (редактировать/удалять)."
        )
        if active_id:
            try:
                bot.edit_message_text(info_text, chat_id, active_id, reply_markup=build_main_keyboard(chat_id))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка редактирования окна (Инфо): {e}")
        else:
            # если активного окна нет, создаём
            try:
                sent = bot.send_message(chat_id, info_text, reply_markup=build_main_keyboard(chat_id))
                set_today_active_window(chat_id, sent.message_id)
            except Exception as e:
                log_error(f"Ошибка отправки инфо: {e}")
        bot.answer_callback_query(call.id)
        return

    # ---------- Редактировать — показать список записей (последние 20) ----------
    if call.data == "btn_edit_list":
        if not day_records:
            text = f"📅 {today_key}\nПока нет операций за сегодня."
            if active_id:
                try:
                    bot.edit_message_text(text, chat_id, active_id, reply_markup=build_main_keyboard(chat_id))
                except telebot.apihelper.ApiException as e:
                    log_error(f"Ошибка редактирования окна (пустой список редактирования): {e}")
            else:
                update_or_send_today_window(chat_id)
            bot.answer_callback_query(call.id, "Нет записей для редактирования")
            return

        # Собираем список последних записей и клавиши для каждой
        lines = [f"📅 {today_key}", "Выберите запись для редактирования:"]
        kb = types.InlineKeyboardMarkup(row_width=1)
        for r in reversed(day_records[-20:]):
            sign = "+" if r["amount"] > 0 else "-"
            label = f"{r['short_id']}: {sign}{abs(r['amount'])} — {r.get('note','')}"
            kb.add(types.InlineKeyboardButton(label, callback_data=f"rec_{r['id']}"))
        kb.add(types.InlineKeyboardButton("🔙 Назад", callback_data="back_to_main"))
        text = "\n".join(lines)

        if active_id:
            try:
                bot.edit_message_text(text, chat_id, active_id, reply_markup=kb)
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка показа списка редактирования: {e}")
        else:
            try:
                sent = bot.send_message(chat_id, text, reply_markup=kb)
                set_today_active_window(chat_id, sent.message_id)
            except Exception as e:
                log_error(f"Ошибка отправки списка редактирования: {e}")
        bot.answer_callback_query(call.id)
        return

    # ---------- Обработчики выбора записи ----------
    if call.data and call.data.startswith("rec_"):
        try:
            rid = int(call.data.split("_",1)[1])
        except:
            bot.answer_callback_query(call.id, "Неверный ID")
            return
        # находим запись
        rec = None
        for r in day_records:
            if r["id"] == rid:
                rec = r
                break
        if not rec:
            bot.answer_callback_query(call.id, "Запись не найдена")
            return

        sign = "+" if rec["amount"] > 0 else "-"
        text = f"Запись {rec['short_id']}\n{sign}{abs(rec['amount'])} — {rec.get('note','')}\nДобавлена: {rec.get('timestamp')}"
        kb = build_edit_keyboard_for_record(rid)

        if active_id:
            try:
                bot.edit_message_text(text, chat_id, active_id, reply_markup=kb)
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка показа детали записи: {e}")
        else:
            try:
                sent = bot.send_message(chat_id, text, reply_markup=kb)
                set_today_active_window(chat_id, sent.message_id)
            except Exception as e:
                log_error(f"Ошибка отправки детали записи: {e}")
        bot.answer_callback_query(call.id)
        return

    # ---------- Нажали "Изменить" на конкретной записи ----------
    if call.data and call.data.startswith("edit_change_"):
        try:
            rid = int(call.data.split("_",2)[2])
        except:
            bot.answer_callback_query(call.id, "Неверный ID")
            return
        # Устанавливаем ожидание ввода новой суммы и заметки
        store["edit_wait"] = "change_value"
        store["edit_target"] = rid
        save_data(data)
        # Просим пользователя ввести новую сумму и заметку в чате (обычное сообщение)
        bot.send_message(chat_id, f"Введите новую сумму и заметку для записи R{rid} в формате:\n<сумма> <заметка>\nПримеры:\n+500 Зарплата\n-150 Обед\n200 Такси (без знака = расход)")
        bot.answer_callback_query(call.id)
        return

    # ---------- Нажали "Удалить" на конкретной записи (показываем подтверждение) ----------
    if call.data and call.data.startswith("edit_delete_"):
        try:
            rid = int(call.data.split("_",2)[2])
        except:
            bot.answer_callback_query(call.id, "Неверный ID")
            return
        # Показываем подтверждение удаления в том же окне
        if active_id:
            try:
                bot.edit_message_text(f"Подтвердите удаление записи R{rid}:", chat_id, active_id, reply_markup=build_confirm_delete_keyboard(rid))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка показа подтверждения удаления: {e}")
        else:
            # отправляем новый (на всякий случай)
            try:
                sent = bot.send_message(chat_id, f"Подтвердите удаление записи R{rid}:", reply_markup=build_confirm_delete_keyboard(rid))
                set_today_active_window(chat_id, sent.message_id)
            except Exception as e:
                log_error(f"Ошибка отправки подтверждения удаления: {e}")
        bot.answer_callback_query(call.id)
        return

    # ---------- Подтвердили удаление ----------
    if call.data and call.data.startswith("confirm_delete_"):
        try:
            rid = int(call.data.split("_",2)[2])
        except:
            bot.answer_callback_query(call.id, "Неверный ID")
            return
        success, removed = delete_record_in_chat(chat_id, rid)
        store["edit_wait"] = None
        store["edit_target"] = None
        save_data(data)
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Запись удалена" if success else "Запись не найдена")
        return

    if call.data == "cancel_delete":
        # Возвращаем список записей
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Отмена удаления")
        return

    # ---------- Возврат назад ----------
    if call.data in ("back_to_main", "edit_back_to_list", "edit_back"):
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id)
        return

    # Обработчик noop и неожиданных callback
    if call.data == "noop":
        bot.answer_callback_query(call.id)
        return

    # По умолчанию — подтверждаем callback
    bot.answer_callback_query(call.id)
    return

# -----------------------------
# ОТСЕК 9 — Входящие сообщения
# -----------------------------
num_re = re.compile(r'([+-]?\s*\d+)')

@bot.message_handler(func=lambda m: True)
def handle_message(msg):
    chat_id = msg.chat.id
    store = get_chat_store(chat_id)
    wait_action = store.get("edit_wait")

    # Если ожидаем изменения значения (после нажатия "Изменить")
    if wait_action == "change_value":
        rid = store.get("edit_target")
        if not rid:
            store["edit_wait"] = None
            store["edit_target"] = None
            save_data(data)
            return
        parts = msg.text.strip().split(" ", 1)
        try:
            raw_amount = parts[0].replace(" ", "")
            if raw_amount.startswith("+"):
                amount = int(raw_amount[1:])
            elif raw_amount.startswith("-"):
                amount = -int(raw_amount[1:])
            else:
                # если без знака — считаем расход (как в оригинале)
                amount = -int(raw_amount)
            note = parts[1] if len(parts) > 1 else ""
            success, _ = update_record_in_chat(chat_id, rid, amount, note)
            store["edit_wait"] = None
            store["edit_target"] = None
            save_data(data)
            update_or_send_today_window(chat_id)
            bot.send_message(chat_id, f"✅ Запись R{rid} {'изменена' if success else 'не найдена'}")
        except Exception as e:
            log_error(f"Ошибка при изменении записи: {e}")
            bot.send_message(chat_id, "Ошибка при вводе суммы. Введите в формате: +500 Зарплата или -150 Обед или 200 Такси")
        return

    # Если ожидаем другое действие (например удаление через режим сообщений) — не используем.
    # Основной режим — авто-добавление записей из свободного текста
    if wait_action is None:
        if not msg.text:
            return
        m = num_re.search(msg.text)
        if m:
            try:
                raw = m.group(1).replace(" ", "")
                if raw.startswith("+"):
                    amount = int(raw[1:])        # Приход
                elif raw.startswith("-"):
                    amount = -int(raw[1:])       # Расход
                else:
                    amount = -int(raw)           # Без знака = расход

                note = msg.text.replace(m.group(1), "").strip()
                add_record_to_chat(chat_id, amount, note, msg.from_user.id)
                update_or_send_today_window(chat_id)
            except Exception as e:
                log_error(f"Ошибка авто-добавления записи: {e}")
        return

    # Другие wait_action ветки (например change_id/delete_id) не используются в этом варианте,
    # потому что редактирование/удаление реализованы через callback'и и прямой ввод.
    return

# -----------------------------
# ОТСЕК 13 — Flask webhook
# -----------------------------
@app.route(f"/{TOKEN}", methods=["POST"])
def webhook():
    update = telebot.types.Update.de_json(request.get_data().decode("utf-8"))
    bot.process_new_updates([update])
    return "OK", 200

@app.route("/", methods=["GET"])
def index():
    return f"Финансовый бот «ФО» — версия {VERSION} работает", 200

# -----------------------------
# ОТСЕК 14 — Webhook установка и запуск
# -----------------------------
def set_webhook():
    url = f"{APP_URL}/{TOKEN}"
    try:
        bot.remove_webhook()
        time.sleep(0.5)
        bot.set_webhook(url=url)
        log_info(f"Webhook установлен: {url}")
    except Exception as e:
        log_error(f"Не удалось установить webhook: {e}")

# -----------------------------
# ОТСЕК 15 — Планировщик смены дня
# -----------------------------
def schedule_daily_window_creation():
    def task():
        last_day = get_today_key()
        while True:
            try:
                time.sleep(60)
                current_day = get_today_key()
                if current_day != last_day:
                    for chat_id_str in list(data.get("chats", {}).keys()):
                        try:
                            chat_id = int(chat_id_str)
                        except: continue
                        try:
                            update_or_send_today_window(chat_id)
                        except Exception as e:
                            log_error(f"Ошибка при создании окна нового дня для {chat_id}: {e}")
                    last_day = current_day
            except Exception as e:
                log_error(f"Ошибка в daily loop: {e}")
                time.sleep(5)
    thread = threading.Thread(target=task, daemon=True)
    thread.start()

# -----------------------------
# ОТСЕК 16 — Запуск
# -----------------------------
if __name__ == "__main__":
    set_webhook()
    schedule_daily_window_creation()
    log_info(f"Бот ФО версии {VERSION} запущен")

    # Сообщение владельцу в Telegram
    try:
        if OWNER_ID:
            bot.send_message(int(OWNER_ID), f"✅ Бот запущен и работает! (версия {VERSION})")
    except Exception as e:
        log_error(f"Не удалось отправить сообщение о запуске: {e}")

    app.run(host="0.0.0.0", port=PORT)