# –ö–æ–¥ –±–æ—Ç–∞ ‚Ññ6
# –£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –∫–æ—Ä–æ—Ç–∫–∏–º–∏ ID –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º –≤ —Ç–æ–º –∂–µ –æ–∫–Ω–µ
# –¢—Ä–µ–±—É–µ—Ç –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏: BOT_TOKEN, OWNER_ID
# requirements.txt: pyTelegramBotAPI==4.23.0, flask

import os
import json
import time
import threading
import re
from datetime import datetime
from zoneinfo import ZoneInfo

import telebot
from flask import Flask, request
from telebot import types

TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
PORT = int(os.environ.get("PORT", 5000))

if not TOKEN:
    raise ValueError("BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")

bot = telebot.TeleBot(TOKEN)
app = Flask(__name__)

# --------------------------------------
# —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
# --------------------------------------
def default_data():
    return {
        "overall_balance": 0,
        "records": [],
        "active_messages": {},
        "next_id": 1
    }

def load_data():
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            try:
                return json.load(f)
            except Exception:
                return default_data()
    return default_data()

def save_data(d):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(d, f, ensure_ascii=False, indent=2)

data = load_data()

# --------------------------------------
# –£—Ç–∏–ª–∏—Ç—ã
# --------------------------------------
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text):
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    if s.startswith('+'):
        sign = '+'
        digits = s[1:].strip()
    elif s.startswith('-'):
        sign = '-'
        digits = s[1:].strip()
    else:
        sign = ''
        digits = s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    digits_norm = re.match(r'(\d+)', digits_norm)
    if not digits_norm:
        return None, None, None
    return int(digits_norm.group(1)), sign, raw

def apply_sign(num, sign):
    return num if sign == '+' else -num

def fmt(n):
    return f"{abs(n):,}".replace(",", ".")

def short_id(n):
    """–∫–æ—Ä–æ—Ç–∫–∏–π id: –Ω–∞–ø—Ä–∏–º–µ—Ä 1 ‚Üí A1, 27 ‚Üí A27"""
    return f"R{n}"

def date_str(dt):
    return dt.astimezone(TZ).strftime("%Y-%m-%d")

def time_str(dt):
    return dt.astimezone(TZ).strftime("%H:%M")

# --------------------------------------
# –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –æ–∫–Ω–∞ –¥–Ω—è
# --------------------------------------
def build_day_window(chat_id, day):
    recs = []
    for r in data["records"]:
        if str(r["owner"]) != str(chat_id):
            continue
        ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        if date_str(ts) == day:
            recs.append((ts, r))
    recs.sort(key=lambda x: x[0])
    if not recs:
        return "üìò –ó–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –µ—â—ë –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π."

    lines = [f"üìÖ {day}\n"]
    last_hour = None
    inc, exp = 0, 0
    for ts, r in recs:
        hour = ts.strftime("%H")
        if last_hour and hour != last_hour:
            lines.append("")
        last_hour = hour
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        if amt > 0:
            inc += amt
        else:
            exp += abs(amt)
        lines.append(f"{short_id(r['id'])} | {sign}{fmt(amt)} {r.get('note','')}".rstrip())

    overall = data["overall_balance"]
    lines.append("")
    lines.append(f"üìà –ü—Ä–∏—Ö–æ–¥ –¥–Ω—è: {fmt(inc)}")
    lines.append(f"üìâ –†–∞—Å—Ö–æ–¥ –¥–Ω—è: {fmt(exp)}")
    lines.append(f"üíµ –û–±—â–∏–π –æ—Å—Ç–∞—Ç–æ–∫: {fmt(overall)}")
    return "\n".join(lines)

# --------------------------------------
# –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
# --------------------------------------
def kb_main():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_menu"))
    return kb

def kb_edit_menu():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–ò–∑–º–µ–Ω–∏—Ç—å", callback_data="edit_modify"))
    kb.add(types.InlineKeyboardButton("–£–¥–∞–ª–∏—Ç—å", callback_data="edit_delete"))
    kb.add(types.InlineKeyboardButton("–û–±–Ω—É–ª–∏—Ç—å –≤—Å—ë", callback_data="edit_reset"))
    kb.add(types.InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_main"))
    return kb

def kb_records_for_edit(chat_id, day):
    recs = []
    for ts, r in get_day_records(chat_id, day):
        recs.append((r["id"], f"{short_id(r['id'])} {r.get('note','') or ''}"))
    kb = types.InlineKeyboardMarkup()
    for rid, txt in recs:
        kb.add(types.InlineKeyboardButton(txt, callback_data=f"select_{rid}"))
    kb.add(types.InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data="back_edit"))
    return kb

def kb_yes_no(prefix):
    kb = types.InlineKeyboardMarkup()
    kb.add(
        types.InlineKeyboardButton("–î–∞", callback_data=f"{prefix}_yes"),
        types.InlineKeyboardButton("–ù–µ—Ç", callback_data=f"{prefix}_no")
    )
    return kb

# --------------------------------------
# –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
# --------------------------------------
def get_day_records(chat_id, day):
    res = []
    for r in data["records"]:
        if str(r["owner"]) != str(chat_id):
            continue
        ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        if date_str(ts) == day:
            res.append((ts, r))
    res.sort(key=lambda x: x[0])
    return res

def update_day_window(chat_id, day, call_msg=None):
    text = build_day_window(chat_id, day)
    if call_msg:
        bot.edit_message_text(
            text, chat_id, call_msg.message_id,
            reply_markup=kb_main()
        )
        data["active_messages"][day] = {"chat_id": chat_id, "message_id": call_msg.message_id}
        save_data(data)
    else:
        sent = bot.send_message(chat_id, text, reply_markup=kb_main())
        data["active_messages"][day] = {"chat_id": chat_id, "message_id": sent.message_id}
        save_data(data)

# --------------------------------------
# –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
# --------------------------------------
@bot.message_handler(func=lambda m: True)
def handle_message(m):
    chat_id = m.chat.id
    txt = m.text.strip()
    num, sign, raw = parse_first_number(txt)
    if num is None:
        bot.reply_to(m, "‚ùó –ü—Ä–∏–º–µ—Ä: `+1000 —Ö–ª–µ–±` –∏–ª–∏ `-500 –±–µ–Ω–∑–∏–Ω`.", parse_mode="Markdown")
        return
    amt = apply_sign(num, sign)
    note = txt[(txt.find(raw) + len(raw)) :].strip() if raw in txt else ""
    rec_id = data["next_id"]
    data["next_id"] += 1
    rec = {
        "id": rec_id,
        "timestamp": datetime.now().astimezone(ZoneInfo("UTC")).isoformat(),
        "amount": amt,
        "note": note,
        "owner": str(chat_id)
    }
    data["records"].append(rec)
    data["overall_balance"] += amt
    save_data(data)

    day = date_str(datetime.now(tz=TZ))
    update_day_window(chat_id, day)

# --------------------------------------
# callback queries
# --------------------------------------
@bot.callback_query_handler(func=lambda c: True)
def callbacks(call):
    chat_id = call.message.chat.id
    day = date_str(datetime.now(tz=TZ))
    data_call = call.data

    if data_call == "edit_menu":
        bot.answer_callback_query(call.id)
        bot.edit_message_reply_markup(chat_id, call.message.message_id, reply_markup=kb_edit_menu())
        return

    if data_call == "back_main":
        bot.answer_callback_query(call.id)
        bot.edit_message_reply_markup(chat_id, call.message.message_id, reply_markup=kb_main())
        return

    if data_call == "back_edit":
        bot.answer_callback_query(call.id)
        bot.edit_message_reply_markup(chat_id, call.message.message_id, reply_markup=kb_edit_menu())
        return

    if data_call == "edit_modify":
        bot.answer_callback_query(call.id)
        bot.edit_message_reply_markup(chat_id, call.message.message_id, reply_markup=kb_records_for_edit(chat_id, day))
        return

    if data_call.startswith("select_"):
        bot.answer_callback_query(call.id)
        rec_id = int(data_call.split("_")[1])
        bot.send_message(chat_id, f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è {short_id(rec_id)} (–Ω–∞–ø—Ä–∏–º–µ—Ä: +2000 –±–µ–Ω–∑–∏–Ω):")
        pending[str(chat_id)] = {"mode": "modify", "rid": rec_id, "msg": call.message}
        return

    if data_call == "edit_delete":
        bot.answer_callback_query(call.id)
        bot.edit_message_reply_markup(chat_id, call.message.message_id, reply_markup=kb_records_for_edit(chat_id, day))
        pending[str(chat_id)] = {"mode": "delete_menu", "msg": call.message}
        return

    if data_call == "edit_reset":
        bot.answer_callback_query(call.id)
        bot.edit_message_reply_markup(chat_id, call.message.message_id, reply_markup=kb_yes_no("reset_all"))
        return

    if data_call.startswith("reset_all_"):
        if data_call.endswith("_yes"):
            data["overall_balance"] = 0
            data["records"] = []
            data["active_messages"] = {}
            save_data(data)
            bot.edit_message_text("‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã.", chat_id, call.message.message_id)
        else:
            update_day_window(chat_id, day, call.message)
        bot.answer_callback_query(call.id)
        return

pending = {}

# --------------------------------------
# –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
# --------------------------------------
@bot.message_handler(func=lambda m: str(m.chat.id) in pending)
def handle_pending(m):
    chat_id = m.chat.id
    state = pending.get(str(chat_id))
    if not state:
        return
    rid = state["rid"]
    msg = state["msg"]
    txt = m.text.strip()

    rec = next((r for r in data["records"] if r["id"] == rid and str(r["owner"]) == str(chat_id)), None)
    if not rec:
        bot.send_message(chat_id, "‚ùó –ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        pending.pop(str(chat_id), None)
        return

    if state["mode"] == "modify":
        num, sign, raw = parse_first_number(txt)
        if num is None:
            bot.send_message(chat_id, "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: `+1000 –ø—Ä–æ–¥—É–∫—Ç—ã`", parse_mode="Markdown")
            return
        amt = apply_sign(num, sign)
        note = txt[(txt.find(raw) + len(raw)) :].strip() if raw in txt else ""
        data["overall_balance"] -= rec["amount"]
        rec["amount"] = amt
        rec["note"] = note
        data["overall_balance"] += amt
        save_data(data)
        update_day_window(chat_id, date_str(datetime.now(tz=TZ)), msg)
        pending.pop(str(chat_id), None)
        return

# --------------------------------------
# –∫–æ–º–∞–Ω–¥—ã
# --------------------------------------
@bot.message_handler(commands=["–±–∞–ª–∞–Ω—Å"])
def balance_cmd(m):
    bot.reply_to(m, f"üí∞ –ë–∞–ª–∞–Ω—Å: {fmt(data['overall_balance'])}")

@bot.message_handler(commands=["–æ—Ç—á–µ—Ç"])
def report_cmd(m):
    day = date_str(datetime.now(tz=TZ))
    update_day_window(m.chat.id, day)

@bot.message_handler(commands=["—Å–±—Ä–æ—Å"])
def reset_cmd(m):
    bot.send_message(m.chat.id, "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω—É–ª–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ?", reply_markup=kb_yes_no("reset_all"))

# --------------------------------------
# webhook
# --------------------------------------
@app.route("/" + TOKEN, methods=["POST"])
def receive_update():
    update = telebot.types.Update.de_json(request.get_data().decode("utf-8"))
    bot.process_new_updates([update])
    return "!", 200

@app.route("/", methods=["GET"])
def set_hook():
    bot.remove_webhook()
    wh_url = f"https://{os.getenv('RENDER_EXTERNAL_HOSTNAME')}/{TOKEN}"
    bot.set_webhook(url=wh_url)
    print(f"‚úÖ Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {wh_url}")
    if OWNER_ID:
        msg = bot.send_message(int(OWNER_ID), "‚úÖ –ë–æ—Ç ‚Ññ6 –∂–∏–≤")
        threading.Thread(target=lambda: (time.sleep(10), bot.delete_message(int(OWNER_ID), msg.message_id)), daemon=True).start()
    return "ok", 200

# --------------------------------------
# –∑–∞–ø—É—Å–∫
# --------------------------------------
if __name__ == "__main__":
    print("üöÄ –ë–æ—Ç ‚Ññ6 –∑–∞–ø—É—â–µ–Ω.")
    if OWNER_ID:
        msg = bot.send_message(int(OWNER_ID), "‚úÖ –ë–æ—Ç ‚Ññ6 –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ.")
        threading.Thread(target=lambda: (time.sleep(10), bot.delete_message(int(OWNER_ID), msg.message_id)), daemon=True).start()
    save_data(data)
    app.run(host="0.0.0.0", port=PORT)
