# -------------------------------
# –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç "–§–û" ‚Äî –≤–µ—Ä—Å–∏—è 9.8.1 (stable)
# Per-chat accounting + PM-owner media forwarding
# Requires: BOT_TOKEN, OWNER_ID environment variables
# -------------------------------

import os
import json
import time
import re
import csv
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Any, Dict, List, Optional, Tuple

from flask import Flask, request
import telebot
from telebot import types

# Configuration
VERSION = "9.8.1"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/" + TOKEN) if TOKEN else "/webhook"

if not TOKEN:
    raise ValueError("–û—à–∏–±–∫–∞: BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------------
# Data helpers
def default_data() -> Dict[str, Any]:
    return {
        "version_base": "9.6.1",
        "version_current": VERSION,
        "global_balance": 0,
        "chats": {},  # chat_id -> { balance, records, next_id, prefix }
        "active_messages": {},  # day -> {chat_id, message_id}
        "sent_messages": [],
        "forward_targets": {}  # owner_chat_id -> [targets]
    }

def load_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            print(f"[load_data] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è {DATA_FILE}: {e}")
            d = default_data()
    else:
        d = default_data()
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d: Dict[str, Any]) -> None:
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[save_data] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è {DATA_FILE}: {e}")

data = load_data()

# -------------------------------
# Utilities
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text: str) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    if s.startswith('+'):
        sign = '+'
        digits = s[1:].strip()
    elif s.startswith('-'):
        sign = '-'
        digits = s[1:].strip()
    else:
        sign = ''
        digits = s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    dm = re.match(r'(\d+)', digits_norm)
    if not dm:
        return None, None, None
    return int(dm.group(1)), sign, raw

def apply_sign_and_normalize(num: int, sign: Optional[str]) -> int:
    return num if sign == '+' else -num

def fmt_amount(n: int) -> str:
    return f"{abs(n):,}".replace(",", ".")

def now_iso_utc() -> str:
    return datetime.now(tz=ZoneInfo("UTC")).isoformat()

# -------------------------------
# Per-chat accounting
def ensure_chat_struct(chat_id: str) -> Dict[str, Any]:
    data.setdefault("chats", {})
    if chat_id not in data["chats"]:
        data["chats"][chat_id] = {"balance": 0, "records": [], "next_id": 1, "prefix": "C"}
        save_data(data)
    return data["chats"][chat_id]

def make_short_id(chat_info: Dict[str, Any], n: int) -> str:
    return f"{chat_info.get('prefix','C')}{n}"

def add_record_to_chat(chat_id: str, amount: int, note: str, user: str) -> Dict[str, Any]:
    ch = ensure_chat_struct(chat_id)
    rid = ch.get("next_id", 1)
    short = make_short_id(ch, rid)
    rec = {
        "id": rid,
        "short_id": short,
        "timestamp": now_iso_utc(),
        "amount": amount,
        "note": note,
        "user": user
    }
    ch.setdefault("records", []).append(rec)
    ch["next_id"] = rid + 1
    ch["balance"] = ch.get("balance", 0) + amount
    # update global
    data["global_balance"] = sum([c.get("balance", 0) for c in data.get("chats", {}).values()])
    save_data(data)
    return rec

def export_chat_to_csv(chat_id: str, path: str = CSV_FILE) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    rows = []
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
            date_s = ts.strftime("%Y-%m-%d")
            time_s = ts.strftime("%H:%M:%S")
        except Exception:
            date_s = r.get("timestamp", "")
            time_s = ""
        rows.append([r.get("short_id"), date_s, time_s, r.get("amount"), r.get("note"), r.get("user")])
    with open(path, "w", newline="", encoding="utf-8-sig") as f:
        writer = csv.writer(f)
        writer.writerow(["ID", "–î–∞—Ç–∞", "–í—Ä–µ–º—è", "–°—É–º–º–∞", "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π", "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"])
        for row in rows:
            writer.writerow(row)
    return path

# -------------------------------
# Forward targets helpers
def ensure_forward_list_for(owner_chat_id: str) -> List[str]:
    data.setdefault("forward_targets", {})
    lst = data["forward_targets"].get(owner_chat_id)
    if lst is None:
        data["forward_targets"][owner_chat_id] = []
        save_data(data)
        return data["forward_targets"][owner_chat_id]
    if isinstance(lst, list):
        return lst
    data["forward_targets"][owner_chat_id] = [str(lst)]
    save_data(data)
    return data["forward_targets"][owner_chat_id]

def add_forward_target(owner_chat_id: str, target: str) -> bool:
    lst = ensure_forward_list_for(owner_chat_id)
    t = str(target).strip()
    if t in lst:
        return False
    lst.append(t)
    data["forward_targets"][owner_chat_id] = lst
    save_data(data)
    return True

def list_forward_targets(owner_chat_id: str) -> List[str]:
    return ensure_forward_list_for(owner_chat_id)

def validate_and_test_target(target_raw: str) -> Tuple[bool, str, str]:
    t_raw = str(target_raw).strip()
    if t_raw.startswith("@"):
        normalized = t_raw
    else:
        try:
            normalized = int(t_raw)
        except Exception:
            normalized = t_raw if t_raw.startswith("@") else "@" + t_raw
    try:
        bot.send_message(normalized, "üîÅ –¢–µ—Å—Ç –æ—Ç –±–æ—Ç–∞: –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏.")
        return True, "–¢–µ—Å—Ç –¥–æ—Å—Ç–∞–≤–ª–µ–Ω.", str(normalized)
    except Exception as e:
        return False, f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç: {e}", str(normalized)

# -------------------------------
# Sending helpers for different media (use file_id to resend)
def record_sent(entry: Dict[str, Any]) -> None:
    data.setdefault("sent_messages", []).append(entry)
    save_data(data)

def send_text(target, text: str, purpose: str="pm_forward_text"):
    try:
        sent = bot.send_message(int(target), text)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "message_id": getattr(sent, "message_id", None), "purpose": purpose, "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose": purpose, "ok": False, "error": str(e)})
        return None

def send_photo_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_photo(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "ok": False, "error": str(e)})
        return None

def send_document_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_document(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "ok": False, "error": str(e)})
        return None

def send_sticker_by_file_id(target, file_id):
    try:
        sent = bot.send_sticker(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "ok": False, "error": str(e)})
        return None

def send_voice_by_file_id(target, file_id):
    try:
        sent = bot.send_voice(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "ok": False, "error": str(e)})
        return None

def send_video_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_video(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "ok": False, "error": str(e)})
        return None

def send_location(target, latitude, longitude):
    try:
        sent = bot.send_location(int(target), latitude, longitude)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "ok": False, "error": str(e)})
        return None

def send_contact(target, phone_number, first_name, last_name=None):
    try:
        sent = bot.send_contact(int(target), phone_number, first_name, last_name)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "ok": False, "error": str(e)})
        return None

# -------------------------------
# PM-owner forwarding block
def pm_owner_forward_block(message: types.Message) -> bool:
    try:
        if getattr(message.chat, "type", "") != "private":
            return False
        if str(message.from_user.id) != str(OWNER_ID):
            return False
        owner_key = str(OWNER_ID)
        targets = data.get("forward_targets", {}).get(owner_key, []) or []
        if not targets:
            return False
        # text
        if message.content_type == 'text':
            text = (message.text or "").strip()
            if not text:
                return True
            for tgt in targets:
                send_text(tgt, text)
            return True
        # photo
        if message.content_type == 'photo' and getattr(message, "photo", None):
            file_id = message.photo[-1].file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_photo_by_file_id(tgt, file_id, caption=caption)
            return True
        # document
        if message.content_type == 'document' and getattr(message, "document", None):
            file_id = message.document.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_document_by_file_id(tgt, file_id, caption=caption)
            return True
        # audio
        if message.content_type == 'audio' and getattr(message, "audio", None):
            file_id = message.audio.file_id
            for tgt in targets:
                try:
                    bot.send_audio(int(tgt), file_id)
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": True})
                except Exception as e:
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": False, "error": str(e)})
            return True
        # voice
        if message.content_type == 'voice' and getattr(message, "voice", None):
            file_id = message.voice.file_id
            for tgt in targets:
                send_voice_by_file_id(tgt, file_id)
            return True
        # sticker
        if message.content_type == 'sticker' and getattr(message, "sticker", None):
            file_id = message.sticker.file_id
            for tgt in targets:
                send_sticker_by_file_id(tgt, file_id)
            return True
        # video
        if message.content_type == 'video' and getattr(message, "video", None):
            file_id = message.video.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_video_by_file_id(tgt, file_id, caption=caption)
            return True
        # location
        if message.content_type == 'location' and getattr(message, "location", None):
            lat = message.location.latitude
            lon = message.location.longitude
            for tgt in targets:
                send_location(tgt, lat, lon)
            return True
        # contact
        if message.content_type == 'contact' and getattr(message, "contact", None):
            phone = message.contact.phone_number
            first = message.contact.first_name
            last = getattr(message.contact, "last_name", None)
            for tgt in targets:
                send_contact(tgt, phone, first, last)
            return True
        # fallback: try forward
        for tgt in targets:
            try:
                try:
                    bot.forward_message(int(tgt), message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
                except Exception:
                    bot.forward_message(tgt, message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
            except Exception as e:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": False, "error": str(e)})
        return True
    except Exception as e:
        print(f"[pm_owner_forward_block] –û—à–∏–±–∫–∞: {e}")
        try:
            bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –±–ª–æ–∫–∞ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –ª–∏—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π: {e}")
        except Exception:
            pass
        return False

# -------------------------------
# Auto-forward for chats (forward message as forward)
def auto_forward_message_from(chat_id: str, message: types.Message) -> None:
    targets = data.get("forward_targets", {}).get(str(chat_id)) or []
    if not targets:
        return
    for t in targets:
        try:
            try:
                bot.forward_message(int(t), int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
            except Exception:
                bot.forward_message(t, int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
        except Exception as e:
            try:
                if message.content_type == 'text' and getattr(message, "text", None):
                    bot.send_message(t, f"üì® –ö–æ–ø–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ {chat_id}:\n\n{message.text}")
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"sent_copy"})
                else:
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e)})
            except Exception as e2:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e2)})

# -------------------------------
# Build day window per chat
def build_day_window_for_chat(chat_id: str, day_date: str) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    recs = []
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        except Exception:
            try:
                ts = datetime.fromisoformat(r["timestamp"])
                ts = ts.astimezone(TZ)
            except Exception:
                ts = None
        if ts and ts.strftime("%Y-%m-%d") == day_date:
            recs.append((ts, r))
    recs.sort(key=lambda x: x[0])
    if not recs:
        return "üìò –ó–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –µ—â—ë –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π."
    lines = [f"üìÖ {day_date}\n"]
    day_income = 0
    day_expense = 0
    last_hour = None
    for ts, r in recs:
        hour = ts.strftime("%H")
        if last_hour and hour != last_hour:
            lines.append("")
        last_hour = hour
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        sid = r.get("short_id")
        note = r.get("note", "")
        t_local = ts.strftime("%H:%M")
        lines.append(f"üïì {t_local} | {sid} | {sign}{fmt_amount(amt)} {note}".rstrip())
        if amt > 0:
            day_income += amt
        else:
            day_expense += abs(amt)
    overall = data.get("chats", {}).get(chat_id, {}).get("balance", 0)
    lines.append("")
    lines.append(f"üìà –ü—Ä–∏—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_income)}")
    lines.append(f"üìâ –†–∞—Å—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_expense)}")
    lines.append(f"üíµ –ë–∞–ª–∞–Ω—Å —á–∞—Ç–∞: {fmt_amount(overall)}")
    return "\n".join(lines)

def kb_day_main():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_menu"))
    return kb

# -------------------------------
pending_actions: Dict[str, Dict[str, Any]] = {}

# -------------------------------
# Main message handler
@bot.message_handler(func=lambda m: True, content_types=['text','photo','document','audio','video','voice','sticker','animation','contact','location'])
def handle_any_message(message: types.Message):
    global data
    chat_id = message.chat.id
    data = load_data()

    # 0) PM-owner forwarding: if private and from OWNER -> send copies to targets and stop
    handled = pm_owner_forward_block(message)
    if handled:
        return

    # 1) handle pending actions (forward setup / remove)
    pa = pending_actions.get(str(chat_id))
    if pa:
        t = pa.get("type")
        if t == "await_forward_setup":
            target = None
            if getattr(message, "forward_from_chat", None):
                try:
                    target = str(message.forward_from_chat.id)
                except Exception:
                    target = None
            elif getattr(message, "forward_from", None):
                try:
                    target = str(message.forward_from.id)
                except Exception:
                    target = None
            elif message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() == "–æ—Ç–º–µ–Ω–∞":
                    send_text(chat_id, "–û—Ç–º–µ–Ω–µ–Ω–æ")
                    pending_actions.pop(str(chat_id), None)
                    return
                target = txt
            if not target:
                send_text(chat_id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä. –û—Ç–º–µ–Ω–∞.")
                pending_actions.pop(str(chat_id), None)
                return
            ok, msg_text, norm = validate_and_test_target(target)
            if ok:
                added = add_forward_target(str(chat_id), norm)
                if added:
                    send_text(chat_id, f"‚úÖ –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞: {norm}")
                else:
                    send_text(chat_id, f"‚ÑπÔ∏è –¶–µ–ª—å —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ: {norm}")
            else:
                send_text(chat_id, f"‚ùå {msg_text}")
            pending_actions.pop(str(chat_id), None)
            return

        if t == "await_remove_forward":
            if message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() in ('–≤—Å—ë','–≤—Å–µ','all'):
                    data["forward_targets"].pop(str(chat_id), None)
                    save_data(data)
                    send_text(chat_id, "‚úÖ –í—Å–µ —Ü–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ —É–¥–∞–ª–µ–Ω—ã.")
                else:
                    removed = remove_forward_target(str(chat_id), txt)
                    if removed:
                        send_text(chat_id, f"‚úÖ –¶–µ–ª—å {txt} —É–¥–∞–ª–µ–Ω–∞.")
                    else:
                        send_text(chat_id, f"‚ùó –¶–µ–ª—å {txt} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
            else:
                send_text(chat_id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥, –æ—Ç–º–µ–Ω–µ–Ω–æ.")
            pending_actions.pop(str(chat_id), None)
            return

    # 2) auto-forward from this chat (as forward)
    try:
        auto_forward_message_from(str(chat_id), message)
    except Exception as e:
        print(f"[auto_forward] –û—à–∏–±–∫–∞: {e}")

    # 3) accounting: messages of any participants in groups/pm (per-chat)
    if message.content_type == 'text':
        text = (message.text or "").strip()
        lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
        any_added = False
        for line in lines:
            num, sign, raw = parse_first_number(line)
            if num is None:
                continue
            amt_signed = apply_sign_and_normalize(num, sign)
            note = line[(line.find(raw) + len(raw)):].strip() if raw in line else ""
            user_display = (message.from_user.username or message.from_user.first_name or str(message.from_user.id))
            add_record_to_chat(str(chat_id), amt_signed, note, user_display)
            any_added = True
        if any_added:
            today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            text_window = build_day_window_for_chat(str(chat_id), today)
            try:
                prev = data.get("active_messages", {}).get(today)
                if prev and int(prev.get("chat_id")) == int(chat_id):
                    try:
                        bot.edit_message_text(chat_id=int(chat_id), message_id=int(prev.get("message_id")), text=text_window, reply_markup=kb_day_main())
                    except Exception:
                        sent = bot.send_message(int(chat_id), text_window, reply_markup=kb_day_main())
                        data.setdefault("active_messages", {})[today] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
                        record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(sent.message_id), "purpose": "day_window"})
                        save_data(data)
                else:
                    sent = bot.send_message(int(chat_id), text_window, reply_markup=kb_day_main())
                    data.setdefault("active_messages", {})[today] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
                    record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(sent.message_id), "purpose": "day_window"})
                    save_data(data)
            except Exception as e:
                print(f"[day_window send] {e}")
        return

# -------------------------------
# Callback handler (basic)
@bot.callback_query_handler(func=lambda call: True)
def callback_worker(call: types.CallbackQuery):
    data_local = load_data()
    data_call = call.data or ""
    chat_id = call.message.chat.id
    try:
        bot.answer_callback_query(call.id)
    except Exception:
        pass
    if data_call == "edit_menu":
        try:
            bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=kb_day_main())
        except Exception:
            send_text(chat_id, "–ú–µ–Ω—é —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ.")

# -------------------------------
# Commands (forward management and accounting)
@bot.message_handler(commands=['addforward'])
def cmd_addforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.")
        return
    send_text(message.chat.id, "–ü–µ—Ä–µ—à–ª–∏—Ç–µ –º–Ω–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ü–µ–ª–µ–≤–æ–≥–æ —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ chat_id/@username.")
    pending_actions[str(message.chat.id)] = {"type": "await_forward_setup", "payload": {}}

@bot.message_handler(commands=['removeforward'])
def cmd_removeforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.")
        return
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "–°–ø–∏—Å–æ–∫ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –ø—É—Å—Ç.")
        return
    send_text(message.chat.id, "–°–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π:\n" + "\n".join(lst) + "\n–û—Ç–ø—Ä–∞–≤—å —Ü–µ–ª—å –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∏–ª–∏ '–≤—Å—ë' –¥–ª—è –æ—á–∏—Å—Ç–∫–∏.")
    pending_actions[str(message.chat.id)] = {"type": "await_remove_forward", "payload": {}}

@bot.message_handler(commands=['listforwards'])
def cmd_listforwards(message: types.Message):
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.")
    else:
        send_text(message.chat.id, "–¢–µ–∫—É—â–∏–µ —Ü–µ–ª–∏:\n" + "\n".join(lst))

@bot.message_handler(commands=["–±–∞–ª–∞–Ω—Å"])
def cmd_balance(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"balance": 0})
    bot.reply_to(message, f"üí∞ –ë–∞–ª–∞–Ω—Å —ç—Ç–æ–≥–æ —á–∞—Ç–∞: {fmt_amount(ch.get('balance', 0))}")

@bot.message_handler(commands=["–æ—Ç—á–µ—Ç"])
def cmd_report(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    if not ch.get("records"):
        bot.reply_to(message, "–ü–æ–∫–∞ –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π –≤ —ç—Ç–æ–º —á–∞—Ç–µ.")
        return
    try:
        path = export_chat_to_csv(chat_id, CSV_FILE)
        bot.send_document(message.chat.id, open(path, "rb"))
    except Exception as e:
        bot.reply_to(message, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ: {e}")

@bot.message_handler(commands=["—Å–±—Ä–æ—Å"])
def cmd_reset(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç –æ–±–Ω—É–ª–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.")
        return
    data.update(default_data())
    save_data(data)
    bot.reply_to(message, "‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã (–≥–ª–æ–±–∞–ª—å–Ω–æ).")

# -------------------------------
# Webhook endpoint
@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    try:
        json_str = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
    except Exception as e:
        print(f"[webhook] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ update: {e}")
    return '', 200

@app.route("/", methods=['GET'])
def index():
    return f"ü§ñ –ë–æ—Ç '–§–û' v{VERSION} —Ä–∞–±–æ—Ç–∞–µ—Ç."

# -------------------------------
def set_webhook_if_possible():
    try:
        host = os.getenv("RENDER_EXTERNAL_HOSTNAME")
        if host:
            url = f"https://{host}{WEBHOOK_PATH}"
            bot.remove_webhook()
            time.sleep(0.3)
            bot.set_webhook(url=url)
            print(f"[startup] Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {url}")
            if OWNER_ID:
                try:
                    bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION}: webhook –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.")
                except Exception:
                    pass
    except Exception as e:
        print(f"[set_webhook_if_possible] {e}")

# -------------------------------
if __name__ == "__main__":
    print(f"–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ '–§–û' v{VERSION} ...")
    save_data(data)
    set_webhook_if_possible()
    try:
        bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION} –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤.")
    except Exception:
        pass
    app.run(host="0.0.0.0", port=PORT)

# -------------------------------
# EOF
# -------------------------------