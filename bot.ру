# main.py
# –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç "–§–û" ‚Äî –≤–µ—Ä—Å–∏—è 9.8.1
# –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ 9.8.0 + –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π Flask webhook –∏ —É–¥–æ–±—Å—Ç–≤–∞
# –¢—Ä–µ–±—É–µ—Ç –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏: BOT_TOKEN, OWNER_ID
# –§–∞–π–ª—ã: data.json, data.csv

import os
import json
import csv
import time
import re
from datetime import datetime
from zoneinfo import ZoneInfo

import telebot
from telebot import types
from flask import Flask, request, jsonify

# -------------------------
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
# -------------------------
VERSION = "9.8.1"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = int(os.getenv("OWNER_ID")) if os.getenv("OWNER_ID") else None
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))

if not TOKEN:
    raise ValueError("BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è!")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------
# –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è –¥–∞–Ω–Ω—ã—Ö
# -------------------------
def default_data():
    return {
        "version": VERSION,
        "overall_balance": 0,
        "records": [],           # {id, short_id, timestamp, amount, note, owner}
        "next_id": 1,
        "forward_targets": [],   # list of chat_ids (ints)
    }

def load_data():
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception:
            d = default_data()
    else:
        d = default_data()
    # ensure keys
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(d, f, ensure_ascii=False, indent=2)

data = load_data()

# -------------------------
# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
# -------------------------
def make_short_id(n):
    # –∫–æ—Ä–æ—Ç–∫–∏–π ID –≤–∏–¥–∞ R0001
    return f"R{n:04d}"

def add_record(amount: int, note: str, owner_id: int):
    rec_id = data["next_id"]
    short = make_short_id(rec_id)
    ts = datetime.now(TZ).isoformat()
    record = {
        "id": rec_id,
        "short_id": short,
        "timestamp": ts,
        "amount": amount,
        "note": note,
        "owner": owner_id
    }
    data["records"].append(record)
    data["next_id"] += 1
    data["overall_balance"] += amount
    save_data(data)
    return record

def export_csv(path=CSV_FILE):
    keys = ["id","short_id","timestamp","amount","note","owner"]
    with open(path, "w", newline="", encoding="utf-8") as cf:
        writer = csv.DictWriter(cf, fieldnames=keys)
        writer.writeheader()
        for r in data["records"]:
            writer.writerow({k: r.get(k, "") for k in keys})
    return path

def is_owner(user_id):
    return OWNER_ID is not None and user_id == OWNER_ID

def safe_parse_financial(text):
    """
    –ü–æ–ø—ã—Ç–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∑–∞–ø–∏—Å—å —Ñ–æ—Ä–º–∞—Ç–∞:
    +1000 –ø—Ä–∏–º–µ—á–∞–Ω–∏–µ
    -500 —Ö–ª–µ–±
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (amount:int, note:str) –∏–ª–∏ None –µ—Å–ª–∏ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ.
    """
    if not text:
        return None
    s = text.strip()
    m = re.match(r'^([+-])\s*([0-9]+)(?:\s+(.*))?$', s)
    if m:
        sign = m.group(1)
        val = int(m.group(2))
        note = m.group(3) or ""
        amount = val if sign == '+' else -val
        return amount, note.strip()
    return None

# -------------------------
# –õ–æ–≥–∏–∫–∞ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
# -------------------------
def forward_message_to_targets(message):
    targets = data.get("forward_targets", [])
    if not targets:
        return 0
    sent = 0
    for t in targets:
        try:
            bot.forward_message(chat_id=int(t), from_chat_id=message.chat.id, message_id=message.message_id)
            sent += 1
        except Exception:
            # –Ω–µ —Ñ–µ–π–ª–∏–º –≤–µ—Å—å –ø—Ä–æ—Ü–µ—Å—Å –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –≤ –æ–¥–∏–Ω target
            pass
    return sent

# -------------------------
# –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞
# -------------------------
@bot.message_handler(commands=['start', 'help'])
def cmd_start(m: types.Message):
    txt = (
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç ¬´–§–û¬ª. \n\n"
        "–î–æ–±–∞–≤–ª—è–π —Ä–∞—Å—Ö–æ–¥—ã/–ø—Ä–∏—Ö–æ–¥—ã –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
        "-1000 —Ö–ª–µ–±   (—Ä–∞—Å—Ö–æ–¥)\n"
        "+2000 –∑–∞—Ä–ø–ª–∞—Ç–∞ (–ø—Ä–∏—Ö–æ–¥)\n\n"
        "–ö–æ–º–∞–Ω–¥—ã:\n"
        "/–±–∞–ª–∞–Ω—Å ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –±–∞–ª–∞–Ω—Å\n"
        "/–æ—Ç—á–µ—Ç ‚Äî —ç–∫—Å–ø–æ—Ä—Ç CSV\n"
        "/addforward <chat_id> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å —Ü–µ–ª—å –ø–µ—Ä–µ—Å—ã–ª–∫–∏ (–≤–ª–∞–¥–µ–ª–µ—Ü)\n"
        "/removeforward <chat_id> ‚Äî —É–¥–∞–ª–∏—Ç—å —Ü–µ–ª—å –ø–µ—Ä–µ—Å—ã–ª–∫–∏ (–≤–ª–∞–¥–µ–ª–µ—Ü)\n"
        "/listforwards ‚Äî —Å–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π –ø–µ—Ä–µ—Å—ã–ª–∫–∏\n"
        "/setwebhook <url> ‚Äî —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å webhook (–≤–ª–∞–¥–µ–ª–µ—Ü)\n"
        "/deletewebhook ‚Äî —É–¥–∞–ª–∏—Ç—å webhook (–≤–ª–∞–¥–µ–ª–µ—Ü)\n"
        "/ping ‚Äî –ø—Ä–æ–≤–µ—Ä–∫–∞\n"
    )
    bot.reply_to(m, txt)

@bot.message_handler(commands=['ping'])
def cmd_ping(m: types.Message):
    bot.reply_to(m, "pong")

@bot.message_handler(commands=['–±–∞–ª–∞–Ω—Å'])
def cmd_balance(m: types.Message):
    bal = data.get("overall_balance", 0)
    bot.reply_to(m, f"üìä –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {bal}")

@bot.message_handler(commands=['–æ—Ç—á–µ—Ç'])
def cmd_report(m: types.Message):
    path = export_csv()
    with open(path, "rb") as f:
        bot.send_document(m.chat.id, f)

@bot.message_handler(commands=['listforwards'])
def cmd_listforwards(m: types.Message):
    items = data.get("forward_targets", [])
    if not items:
        bot.reply_to(m, "–°–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –ø—É—Å—Ç.")
        return
    txt = "–¶–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏:\n" + "\n".join(str(x) for x in items)
    bot.reply_to(m, txt)

@bot.message_handler(commands=['addforward'])
def cmd_addforward(m: types.Message):
    if not is_owner(m.from_user.id):
        bot.reply_to(m, "–¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å —Ü–µ–ª—è–º–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏.")
        return
    parts = m.text.split()
    if len(parts) < 2:
        bot.reply_to(m, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /addforward <chat_id>")
        return
    try:
        cid = int(parts[1])
    except:
        bot.reply_to(m, "chat_id –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
        return
    if cid in data["forward_targets"]:
        bot.reply_to(m, "–≠—Ç–æ—Ç chat_id —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ.")
        return
    data["forward_targets"].append(cid)
    save_data(data)
    bot.reply_to(m, f"–î–æ–±–∞–≤–ª–µ–Ω–æ: {cid}")

@bot.message_handler(commands=['removeforward'])
def cmd_removeforward(m: types.Message):
    if not is_owner(m.from_user.id):
        bot.reply_to(m, "–¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å —Ü–µ–ª—è–º–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏.")
        return
    parts = m.text.split()
    if len(parts) < 2:
        bot.reply_to(m, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /removeforward <chat_id>")
        return
    try:
        cid = int(parts[1])
    except:
        bot.reply_to(m, "chat_id –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
        return
    if cid not in data["forward_targets"]:
        bot.reply_to(m, "–¢–∞–∫–æ–≥–æ chat_id –Ω–µ—Ç –≤ —Å–ø–∏—Å–∫–µ.")
        return
    data["forward_targets"].remove(cid)
    save_data(data)
    bot.reply_to(m, f"–£–¥–∞–ª—ë–Ω: {cid}")

# Owner-only webhook control from chat (–ø–æ–ª–µ–∑–Ω–æ –¥–ª—è —Ç–µ—Å—Ç–∞)
@bot.message_handler(commands=['setwebhook'])
def cmd_setwebhook(m: types.Message):
    if not is_owner(m.from_user.id):
        bot.reply_to(m, "–¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É.")
        return
    parts = m.text.split(maxsplit=1)
    if len(parts) < 2:
        bot.reply_to(m, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /setwebhook https://your-url/webhook")
        return
    url = parts[1].strip()
    try:
        import requests
        r = requests.get(f"https://api.telegram.org/bot{TOKEN}/setWebhook", params={"url": url})
        bot.reply_to(m, f"–û—Ç–≤–µ—Ç Telegram: {r.text}")
    except Exception as e:
        bot.reply_to(m, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ Telegram API: {e}")

@bot.message_handler(commands=['deletewebhook'])
def cmd_deletewebhook(m: types.Message):
    if not is_owner(m.from_user.id):
        bot.reply_to(m, "–¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É.")
        return
    try:
        import requests
        r = requests.get(f"https://api.telegram.org/bot{TOKEN}/deleteWebhook")
        bot.reply_to(m, f"–û—Ç–≤–µ—Ç Telegram: {r.text}")
    except Exception as e:
        bot.reply_to(m, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ Telegram API: {e}")

# -------------------------
# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ª—é–±—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
# -------------------------
@bot.message_handler(func=lambda m: True, content_types=['text', 'photo', 'video', 'document', 'sticker', 'voice'])
def handle_all_messages(m: types.Message):
    """
    –ü—Ä–∞–≤–∏–ª–∞:
    - –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ñ–æ—Ä–≤–∞—Ä–¥ (forward_from/forward_from_chat/forward_date) => –Ω–µ –ø–∞—Ä—Å–∏–º –∫–∞–∫ —Ä–∞—Å—Ö–æ–¥/–ø—Ä–∏—Ö–æ–¥, –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º –≤ targets.
    - –ò–Ω–∞—á–µ, –ø—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å +N/-N –∏ —Å–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å.
    - –ï—Å–ª–∏ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ ‚Äî –µ—Å–ª–∏ –µ—Å—Ç—å targets ‚Äî –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º, –∏–Ω–∞—á–µ –æ—Ç–≤–µ—á–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫–æ–π.
    """
    # 1) –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–µ—Ä–µ—Å–ª–∞–Ω–æ ‚Äî –ù–ï –ø–∞—Ä—Å–∏–º, —Ç–æ–ª—å–∫–æ —Ñ–æ—Ä–≤–∞—Ä–¥
    forwarded = any([
        getattr(m, "forward_from", None),
        getattr(m, "forward_from_chat", None),
        getattr(m, "forward_date", None)
    ])
    if forwarded:
        forwarded_to = forward_message_to_targets(m)
        bot.reply_to(m, f"–ü–µ—Ä–µ—Å–ª–∞–Ω–æ –≤ {forwarded_to} —Ü–µ–ª–µ–π." if forwarded_to else "–ù–µ—Ç —Ü–µ–ª–µ–π –ø–µ—Ä–µ—Å—ã–ª–∫–∏.")
        return

    # 2) –ü–æ–ø—ã—Ç–∫–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∏—è —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞
    parsed = safe_parse_financial(m.text if m.text else "")
    if parsed:
        amount, note = parsed
        rec = add_record(amount, note, m.from_user.id)
        bot.reply_to(m, f"–ó–∞–ø–∏—Å–∞–Ω–æ: {rec['short_id']}  {rec['amount']}  {rec['note']}\n–ë–∞–ª–∞–Ω—Å: {data['overall_balance']}")
        return

    # 3) –ï—Å–ª–∏ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ –∏ –µ—Å—Ç—å —Ü–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ ‚Äî –ø—Ä–æ—Å—Ç–æ —Ñ–æ—Ä–≤–∞—Ä–¥–∏–º
    if data.get("forward_targets"):
        cnt = forward_message_to_targets(m)
        if cnt:
            bot.reply_to(m, f"–°–æ–æ–±—â–µ–Ω–∏–µ –ø–µ—Ä–µ—Å–ª–∞–Ω–æ –≤ {cnt} —Ü–µ–ª–µ–π.")
            return

    # 4) –ò–Ω–∞—á–µ ‚Äî –ø–æ–¥—Å–∫–∞–∑–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    bot.reply_to(m, "–ù–µ –ø–æ–Ω—è–ª. –í–≤–µ–¥–∏—Ç–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: +1000 –ø—Ä–∏–º–µ—á–∞–Ω–∏–µ –∏–ª–∏ -500 —Ö–ª–µ–±. –î–ª—è —Å–ø—Ä–∞–≤–∫–∏ ‚Äî /help")

# -------------------------
# Flask webhook –º–∞—Ä—à—Ä—É—Ç—ã
# -------------------------
@app.route('/webhook', methods=['POST'])
def webhook():
    # Telegram –ø—Ä–∏—Å—ã–ª–∞–µ—Ç JSON; –ø–µ—Ä–µ–¥–∞–µ–º –µ–≥–æ –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫—É telebot
    if request.headers.get('content-type') != 'application/json':
        return "Unsupported Media Type", 415
    try:
        json_str = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
        return '', 200
    except Exception as e:
        # –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 200, —á—Ç–æ–±—ã Telegram –Ω–µ –ø–æ–≤—Ç–æ—Ä—è–ª –∑–∞–ø—Ä–æ—Å—ã —Å–ª–∏—à–∫–æ–º –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ,
        # –Ω–æ –ª–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É (Render –ø–æ–º–æ–∂–µ—Ç —Å –ª–æ–≥–∞–º–∏)
        print("Webhook processing error:", e)
        return '', 200

@app.route('/', methods=['GET'])
def index():
    return f'ü§ñ –ë–æ—Ç "–§–û" ‚Äî –≤–µ—Ä—Å–∏—è {VERSION} ‚Äî —Ä–∞–±–æ—Ç–∞–µ—Ç!'

@app.route('/health', methods=['GET'])
def health():
    return jsonify({
        "ok": True,
        "version": VERSION,
        "records": len(data.get("records", [])),
        "balance": data.get("overall_balance", 0),
    })

# -------------------------
# –ó–∞–ø—É—Å–∫ (Render)
# -------------------------
if __name__ == '__main__':
    print(f"üöÄ –ó–∞–ø—É—Å–∫ –§–ª–∞—Å–∫ (–ø–æ—Ä—Ç {PORT}) ‚Äî –≤–µ—Ä—Å–∏—è {VERSION}")
    # –ù–∞ Render –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–ª—É—à–∞–µ—Ç –≤—Ö–æ–¥—è—â–∏–µ –∑–∞–ø—Ä–æ—Å—ã, telebot –Ω–µ —Å—Ç–∞–≤–∏–º –≤ polling.
    app.run(host='0.0.0.0', port=PORT)