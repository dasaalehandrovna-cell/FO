# -------------------------------
# Финансовый бот "ФО" — версия 9.8.1 (stable)
# Per-chat accounting + PM-owner media forwarding
# Requires: BOT_TOKEN, OWNER_ID environment variables
# -------------------------------

import os
import json
import time
import re
import csv
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Any, Dict, List, Optional, Tuple

from flask import Flask, request
import telebot
from telebot import types

# Configuration
VERSION = "9.8.1"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/" + TOKEN) if TOKEN else "/webhook"

if not TOKEN:
    raise ValueError("Ошибка: BOT_TOKEN не установлен.")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------------
# Data helpers
def default_data() -> Dict[str, Any]:
    return {
        "version_base": "9.6.1",
        "version_current": VERSION,
        "global_balance": 0,
        "chats": {},  # chat_id -> { balance, records, next_id, prefix }
        "active_messages": {},  # day -> {chat_id, message_id}
        "sent_messages": [],
        "forward_targets": {}  # owner_chat_id -> [targets]
    }

def load_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            print(f"[load_data] Ошибка чтения {DATA_FILE}: {e}")
            d = default_data()
    else:
        d = default_data()
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d: Dict[str, Any]) -> None:
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[save_data] Ошибка сохранения {DATA_FILE}: {e}")

data = load_data()

# -------------------------------
# Utilities
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text: str) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    if s.startswith('+'):
        sign = '+'
        digits = s[1:].strip()
    elif s.startswith('-'):
        sign = '-'
        digits = s[1:].strip()
    else:
        sign = ''
        digits = s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    dm = re.match(r'(\d+)', digits_norm)
    if not dm:
        return None, None, None
    return int(dm.group(1)), sign, raw

def apply_sign_and_normalize(num: int, sign: Optional[str]) -> int:
    return num if sign == '+' else -num

def fmt_amount(n: int) -> str:
    return f"{abs(n):,}".replace(",", ".")

def now_iso_utc() -> str:
    return datetime.now(tz=ZoneInfo("UTC")).isoformat()

# -------------------------------
# Per-chat accounting
def ensure_chat_struct(chat_id: str) -> Dict[str, Any]:
    data.setdefault("chats", {})
    if chat_id not in data["chats"]:
        data["chats"][chat_id] = {"balance": 0, "records": [], "next_id": 1, "prefix": "C"}
        save_data(data)
    return data["chats"][chat_id]

def make_short_id(chat_info: Dict[str, Any], n: int) -> str:
    return f"{chat_info.get('prefix','C')}{n}"

def add_record_to_chat(chat_id: str, amount: int, note: str, user: str) -> Dict[str, Any]:
    ch = ensure_chat_struct(chat_id)
    rid = ch.get("next_id", 1)
    short = make_short_id(ch, rid)
    rec = {
        "id": rid,
        "short_id": short,
        "timestamp": now_iso_utc(),
        "amount": amount,
        "note": note,
        "user": user
    }
    ch.setdefault("records", []).append(rec)
    ch["next_id"] = rid + 1
    ch["balance"] = ch.get("balance", 0) + amount
    # update global
    data["global_balance"] = sum([c.get("balance", 0) for c in data.get("chats", {}).values()])
    save_data(data)
    return rec

def export_chat_to_csv(chat_id: str, path: str = CSV_FILE) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    rows = []
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
            date_s = ts.strftime("%Y-%m-%d")
            time_s = ts.strftime("%H:%M:%S")
        except Exception:
            date_s = r.get("timestamp", "")
            time_s = ""
        rows.append([r.get("short_id"), date_s, time_s, r.get("amount"), r.get("note"), r.get("user")])
    with open(path, "w", newline="", encoding="utf-8-sig") as f:
        writer = csv.writer(f)
        writer.writerow(["ID", "Дата", "Время", "Сумма", "Комментарий", "Пользователь"])
        for row in rows:
            writer.writerow(row)
    return path

# -------------------------------
# Forward targets helpers
def ensure_forward_list_for(owner_chat_id: str) -> List[str]:
    data.setdefault("forward_targets", {})
    lst = data["forward_targets"].get(owner_chat_id)
    if lst is None:
        data["forward_targets"][owner_chat_id] = []
        save_data(data)
        return data["forward_targets"][owner_chat_id]
    if isinstance(lst, list):
        return lst
    data["forward_targets"][owner_chat_id] = [str(lst)]
    save_data(data)
    return data["forward_targets"][owner_chat_id]

def add_forward_target(owner_chat_id: str, target: str) -> bool:
    lst = ensure_forward_list_for(owner_chat_id)
    t = str(target).strip()
    if t in lst:
        return False
    lst.append(t)
    data["forward_targets"][owner_chat_id] = lst
    save_data(data)
    return True

def list_forward_targets(owner_chat_id: str) -> List[str]:
    return ensure_forward_list_for(owner_chat_id)

def validate_and_test_target(target_raw: str) -> Tuple[bool, str, str]:
    t_raw = str(target_raw).strip()
    if t_raw.startswith("@"):
        normalized = t_raw
    else:
        try:
            normalized = int(t_raw)
        except Exception:
            normalized = t_raw if t_raw.startswith("@") else "@" + t_raw
    try:
        bot.send_message(normalized, "🔁 Тест от бота: проверка доступа для пересылки.")
        return True, "Тест доставлен.", str(normalized)
    except Exception as e:
        return False, f"Не удалось отправить тест: {e}", str(normalized)

# -------------------------------
# Sending helpers for different media (use file_id to resend)
def record_sent(entry: Dict[str, Any]) -> None:
    data.setdefault("sent_messages", []).append(entry)
    save_data(data)

def send_text(target, text: str, purpose: str="pm_forward_text"):
    try:
        sent = bot.send_message(int(target), text)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "message_id": getattr(sent, "message_id", None), "purpose": purpose, "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose": purpose, "ok": False, "error": str(e)})
        return None

def send_photo_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_photo(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "ok": False, "error": str(e)})
        return None

def send_document_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_document(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "ok": False, "error": str(e)})
        return None

def send_sticker_by_file_id(target, file_id):
    try:
        sent = bot.send_sticker(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "ok": False, "error": str(e)})
        return None

def send_voice_by_file_id(target, file_id):
    try:
        sent = bot.send_voice(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "ok": False, "error": str(e)})
        return None

def send_video_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_video(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "ok": False, "error": str(e)})
        return None

def send_location(target, latitude, longitude):
    try:
        sent = bot.send_location(int(target), latitude, longitude)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "ok": False, "error": str(e)})
        return None

def send_contact(target, phone_number, first_name, last_name=None):
    try:
        sent = bot.send_contact(int(target), phone_number, first_name, last_name)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "ok": False, "error": str(e)})
        return None

# -------------------------------
# PM-owner forwarding block
def pm_owner_forward_block(message: types.Message) -> bool:
    try:
        if getattr(message.chat, "type", "") != "private":
            return False
        if str(message.from_user.id) != str(OWNER_ID):
            return False
        owner_key = str(OWNER_ID)
        targets = data.get("forward_targets", {}).get(owner_key, []) or []
        if not targets:
            return False
        # text
        if message.content_type == 'text':
            text = (message.text or "").strip()
            if not text:
                return True
            for tgt in targets:
                send_text(tgt, text)
            return True
        # photo
        if message.content_type == 'photo' and getattr(message, "photo", None):
            file_id = message.photo[-1].file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_photo_by_file_id(tgt, file_id, caption=caption)
            return True
        # document
        if message.content_type == 'document' and getattr(message, "document", None):
            file_id = message.document.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_document_by_file_id(tgt, file_id, caption=caption)
            return True
        # audio
        if message.content_type == 'audio' and getattr(message, "audio", None):
            file_id = message.audio.file_id
            for tgt in targets:
                try:
                    bot.send_audio(int(tgt), file_id)
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": True})
                except Exception as e:
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": False, "error": str(e)})
            return True
        # voice
        if message.content_type == 'voice' and getattr(message, "voice", None):
            file_id = message.voice.file_id
            for tgt in targets:
                send_voice_by_file_id(tgt, file_id)
            return True
        # sticker
        if message.content_type == 'sticker' and getattr(message, "sticker", None):
            file_id = message.sticker.file_id
            for tgt in targets:
                send_sticker_by_file_id(tgt, file_id)
            return True
        # video
        if message.content_type == 'video' and getattr(message, "video", None):
            file_id = message.video.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_video_by_file_id(tgt, file_id, caption=caption)
            return True
        # location
        if message.content_type == 'location' and getattr(message, "location", None):
            lat = message.location.latitude
            lon = message.location.longitude
            for tgt in targets:
                send_location(tgt, lat, lon)
            return True
        # contact
        if message.content_type == 'contact' and getattr(message, "contact", None):
            phone = message.contact.phone_number
            first = message.contact.first_name
            last = getattr(message.contact, "last_name", None)
            for tgt in targets:
                send_contact(tgt, phone, first, last)
            return True
        # fallback: try forward
        for tgt in targets:
            try:
                try:
                    bot.forward_message(int(tgt), message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
                except Exception:
                    bot.forward_message(tgt, message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
            except Exception as e:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": False, "error": str(e)})
        return True
    except Exception as e:
        print(f"[pm_owner_forward_block] Ошибка: {e}")
        try:
            bot.send_message(int(OWNER_ID), f"⚠️ Ошибка блока пересылки личных сообщений: {e}")
        except Exception:
            pass
        return False

# -------------------------------
# Auto-forward for chats (forward message as forward)
def auto_forward_message_from(chat_id: str, message: types.Message) -> None:
    targets = data.get("forward_targets", {}).get(str(chat_id)) or []
    if not targets:
        return
    for t in targets:
        try:
            try:
                bot.forward_message(int(t), int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
            except Exception:
                bot.forward_message(t, int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
        except Exception as e:
            try:
                if message.content_type == 'text' and getattr(message, "text", None):
                    bot.send_message(t, f"📨 Копия сообщения из {chat_id}:\n\n{message.text}")
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"sent_copy"})
                else:
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e)})
            except Exception as e2:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e2)})

# -------------------------------
# Build day window per chat
def build_day_window_for_chat(chat_id: str, day_date: str) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    recs = []
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        except Exception:
            try:
                ts = datetime.fromisoformat(r["timestamp"])
                ts = ts.astimezone(TZ)
            except Exception:
                ts = None
        if ts and ts.strftime("%Y-%m-%d") == day_date:
            recs.append((ts, r))
    recs.sort(key=lambda x: x[0])
    if not recs:
        return "📘 За этот день ещё нет записей."
    lines = [f"📅 {day_date}\n"]
    day_income = 0
    day_expense = 0
    last_hour = None
    for ts, r in recs:
        hour = ts.strftime("%H")
        if last_hour and hour != last_hour:
            lines.append("")
        last_hour = hour
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        sid = r.get("short_id")
        note = r.get("note", "")
        t_local = ts.strftime("%H:%M")
        lines.append(f"🕓 {t_local} | {sid} | {sign}{fmt_amount(amt)} {note}".rstrip())
        if amt > 0:
            day_income += amt
        else:
            day_expense += abs(amt)
    overall = data.get("chats", {}).get(chat_id, {}).get("balance", 0)
    lines.append("")
    lines.append(f"📈 Приход дня: {fmt_amount(day_income)}")
    lines.append(f"📉 Расход дня: {fmt_amount(day_expense)}")
    lines.append(f"💵 Баланс чата: {fmt_amount(overall)}")
    return "\n".join(lines)

def kb_day_main():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("Редактировать", callback_data="edit_menu"))
    return kb

# -------------------------------
pending_actions: Dict[str, Dict[str, Any]] = {}

# -------------------------------
# Main message handler
@bot.message_handler(func=lambda m: True, content_types=['text','photo','document','audio','video','voice','sticker','animation','contact','location'])
def handle_any_message(message: types.Message):
    global data
    chat_id = message.chat.id
    data = load_data()

    # 0) PM-owner forwarding: if private and from OWNER -> send copies to targets and stop
    handled = pm_owner_forward_block(message)
    if handled:
        return

    # 1) handle pending actions (forward setup / remove)
    pa = pending_actions.get(str(chat_id))
    if pa:
        t = pa.get("type")
        if t == "await_forward_setup":
            target = None
            if getattr(message, "forward_from_chat", None):
                try:
                    target = str(message.forward_from_chat.id)
                except Exception:
                    target = None
            elif getattr(message, "forward_from", None):
                try:
                    target = str(message.forward_from.id)
                except Exception:
                    target = None
            elif message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() == "отмена":
                    send_text(chat_id, "Отменено")
                    pending_actions.pop(str(chat_id), None)
                    return
                target = txt
            if not target:
                send_text(chat_id, "❌ Неверный идентификатор. Отмена.")
                pending_actions.pop(str(chat_id), None)
                return
            ok, msg_text, norm = validate_and_test_target(target)
            if ok:
                added = add_forward_target(str(chat_id), norm)
                if added:
                    send_text(chat_id, f"✅ Пересылка добавлена: {norm}")
                else:
                    send_text(chat_id, f"ℹ️ Цель уже в списке: {norm}")
            else:
                send_text(chat_id, f"❌ {msg_text}")
            pending_actions.pop(str(chat_id), None)
            return

        if t == "await_remove_forward":
            if message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() in ('всё','все','all'):
                    data["forward_targets"].pop(str(chat_id), None)
                    save_data(data)
                    send_text(chat_id, "✅ Все цели пересылки удалены.")
                else:
                    removed = remove_forward_target(str(chat_id), txt)
                    if removed:
                        send_text(chat_id, f"✅ Цель {txt} удалена.")
                    else:
                        send_text(chat_id, f"❗ Цель {txt} не найдена.")
            else:
                send_text(chat_id, "❌ Неверный ввод, отменено.")
            pending_actions.pop(str(chat_id), None)
            return

    # 2) auto-forward from this chat (as forward)
    try:
        auto_forward_message_from(str(chat_id), message)
    except Exception as e:
        print(f"[auto_forward] Ошибка: {e}")

    # 3) accounting: messages of any participants in groups/pm (per-chat)
    if message.content_type == 'text':
        text = (message.text or "").strip()
        lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
        any_added = False
        for line in lines:
            num, sign, raw = parse_first_number(line)
            if num is None:
                continue
            amt_signed = apply_sign_and_normalize(num, sign)
            note = line[(line.find(raw) + len(raw)):].strip() if raw in line else ""
            user_display = (message.from_user.username or message.from_user.first_name or str(message.from_user.id))
            add_record_to_chat(str(chat_id), amt_signed, note, user_display)
            any_added = True
        if any_added:
            today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            text_window = build_day_window_for_chat(str(chat_id), today)
            try:
                prev = data.get("active_messages", {}).get(today)
                if prev and int(prev.get("chat_id")) == int(chat_id):
                    try:
                        bot.edit_message_text(chat_id=int(chat_id), message_id=int(prev.get("message_id")), text=text_window, reply_markup=kb_day_main())
                    except Exception:
                        sent = bot.send_message(int(chat_id), text_window, reply_markup=kb_day_main())
                        data.setdefault("active_messages", {})[today] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
                        record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(sent.message_id), "purpose": "day_window"})
                        save_data(data)
                else:
                    sent = bot.send_message(int(chat_id), text_window, reply_markup=kb_day_main())
                    data.setdefault("active_messages", {})[today] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
                    record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(sent.message_id), "purpose": "day_window"})
                    save_data(data)
            except Exception as e:
                print(f"[day_window send] {e}")
        return

# -------------------------------
# Callback handler (basic)
@bot.callback_query_handler(func=lambda call: True)
def callback_worker(call: types.CallbackQuery):
    data_local = load_data()
    data_call = call.data or ""
    chat_id = call.message.chat.id
    try:
        bot.answer_callback_query(call.id)
    except Exception:
        pass
    if data_call == "edit_menu":
        try:
            bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=kb_day_main())
        except Exception:
            send_text(chat_id, "Меню редактирования недоступно.")

# -------------------------------
# Commands (forward management and accounting)
@bot.message_handler(commands=['addforward'])
def cmd_addforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "⛔ Только владелец может управлять пересылкой.")
        return
    send_text(message.chat.id, "Перешлите мне сообщение из целевого чата/канала или отправьте chat_id/@username.")
    pending_actions[str(message.chat.id)] = {"type": "await_forward_setup", "payload": {}}

@bot.message_handler(commands=['removeforward'])
def cmd_removeforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "⛔ Только владелец может управлять пересылкой.")
        return
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "Список пересылки пуст.")
        return
    send_text(message.chat.id, "Список целей:\n" + "\n".join(lst) + "\nОтправь цель для удаления или 'всё' для очистки.")
    pending_actions[str(message.chat.id)] = {"type": "await_remove_forward", "payload": {}}

@bot.message_handler(commands=['listforwards'])
def cmd_listforwards(message: types.Message):
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "Пересылка не настроена.")
    else:
        send_text(message.chat.id, "Текущие цели:\n" + "\n".join(lst))

@bot.message_handler(commands=["баланс"])
def cmd_balance(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"balance": 0})
    bot.reply_to(message, f"💰 Баланс этого чата: {fmt_amount(ch.get('balance', 0))}")

@bot.message_handler(commands=["отчет"])
def cmd_report(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    if not ch.get("records"):
        bot.reply_to(message, "Пока нет записей в этом чате.")
        return
    try:
        path = export_chat_to_csv(chat_id, CSV_FILE)
        bot.send_document(message.chat.id, open(path, "rb"))
    except Exception as e:
        bot.reply_to(message, f"Ошибка при экспорте: {e}")

@bot.message_handler(commands=["сброс"])
def cmd_reset(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "⛔ Только владелец может обнулить данные.")
        return
    data.update(default_data())
    save_data(data)
    bot.reply_to(message, "♻️ Все данные обнулены (глобально).")

# -------------------------------
# Webhook endpoint
@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    try:
        json_str = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
    except Exception as e:
        print(f"[webhook] Ошибка обработки update: {e}")
    return '', 200

@app.route("/", methods=['GET'])
def index():
    return f"🤖 Бот 'ФО' v{VERSION} работает."

# -------------------------------
def set_webhook_if_possible():
    try:
        host = os.getenv("RENDER_EXTERNAL_HOSTNAME")
        if host:
            url = f"https://{host}{WEBHOOK_PATH}"
            bot.remove_webhook()
            time.sleep(0.3)
            bot.set_webhook(url=url)
            print(f"[startup] Webhook установлен: {url}")
            if OWNER_ID:
                try:
                    bot.send_message(int(OWNER_ID), f"✅ Бот v{VERSION}: webhook активирован.")
                except Exception:
                    pass
    except Exception as e:
        print(f"[set_webhook_if_possible] {e}")

# -------------------------------
if __name__ == "__main__":
    print(f"Запуск бота 'ФО' v{VERSION} ...")
    save_data(data)
    set_webhook_if_possible()
    try:
        bot.send_message(int(OWNER_ID), f"✅ Бот v{VERSION} запущен и готов.")
    except Exception:
        pass
    app.run(host="0.0.0.0", port=PORT)

# -------------------------------
# EOF
# -------------------------------