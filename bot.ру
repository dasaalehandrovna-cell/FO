# 9.8.6 послед — с keep-alive и уведомлением владельца
# ============================================
# Финансовый бот — версия 9.8.6
# Обновлено: подменю "✏️ Редактировать" содержит CSV, Форвард, Получатель, Обнулить, Назад
# Добавлено: keep-alive (пинг OWNER_ID и self-ping)
# ============================================

import os
import json
import csv
import logging
import re
import threading
import time
from datetime import datetime
from zoneinfo import ZoneInfo

import requests
import telebot
from flask import Flask, request
from telebot import types

# --- Конфигурация (не меняй, если уже настроено в окружении) ---
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")  # строка с числом или None
APP_URL = os.getenv("APP_URL", "https://yourapp.onrender.com")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
LOG_FILE = "log.txt"
PORT = int(os.environ.get("PORT", 5000))
VERSION = "9.8.6"

# Keep-alive настройки
KEEP_ALIVE_INTERVAL_SECONDS = int(os.getenv("KEEP_ALIVE_INTERVAL_SECONDS", 12 * 60))  # по умолчанию ? минут
KEEP_ALIVE_SEND_TO_OWNER = True  # если False — не шлём сообщения владельцу, только self-ping

if not TOKEN:
    raise ValueError("BOT_TOKEN не установлен!")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

#улаление сообщений

def send_temp_message(chat_id, text, delay=5, **kwargs):
    """Отправка временного сообщения, которое удаляется через delay секунд."""
    try:
        msg = bot.send_message(chat_id, text, **kwargs)
        threading.Timer(delay, lambda: delete_message_safe(chat_id, msg.message_id)).start()
    except Exception as e:
        log_error(f"send_temp_message: не удалось отправить/удалить сообщение: {e}")

def delete_message_safe(chat_id, message_id):
    """Удаляет сообщение, игнорируя ошибки."""
    try:
        bot.delete_message(chat_id, message_id)
    except:
        pass

# ----------------------------------------
# ФУНКЦИЯ ФОРМАТИРОВАНИЯ ЧИСЕЛ
# ----------------------------------------
def fmt_num(value):
    try:
        return f"{value:,.0f}".replace(",", ".")
    except Exception:
        return str(value)

# -----------------------------
# Логирование
# -----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="[{asctime}] {levelname}: {message}",
    style="{",
    handlers=[logging.FileHandler(LOG_FILE, encoding="utf-8"), logging.StreamHandler()]
)

def log_info(msg):
    logging.info(msg)
def log_error(msg):
    logging.error(msg)

log_info(f"Старт приложения. Версия {VERSION}")

# -----------------------------
# Структура данных и IO
# -----------------------------
def default_data():
    return {
        "overall_balance": 0,
        "records": [],
        "chats": {},
        "active_messages": {},
        "processed_messages": [],
        "forward_targets": [],
        "tracked_messages": {},
        "next_id": 1
    }

def load_data():
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            log_error(f"Ошибка чтения data.json: {e}")
            d = default_data()
    else:
        d = default_data()
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d):
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        log_error(f"Ошибка сохранения data.json: {e}")

data = load_data()

# если задан OWNER_ID — добавим его в глобальные цели (совместимость со старым кодом)
if OWNER_ID:
    try:
        oi = int(OWNER_ID)
        if oi not in data.get("forward_targets", []):
            data["forward_targets"].append(oi)
            save_data(data)
    except Exception:
        pass

# -----------------------------
# Вспомогательные
# -----------------------------
def get_today_key():
    return datetime.now(TZ).strftime("%Y-%m-%d")

def get_chat_store(chat_id):
    cid = str(chat_id)
    if cid not in data["chats"]:
        data["chats"][cid] = {
            "balance": 0,
            "records": [],
            "next_id": 1,
            "daily_records": {},
            "active_windows": {},
            "edit_wait": None,
            "edit_target": None,
            "forward_enabled": False,
            "forward_target_id": None
        }
        save_data(data)
    store = data["chats"][cid]
    if "forward_enabled" not in store:
        store["forward_enabled"] = False
    if "forward_target_id" not in store:
        store["forward_target_id"] = None
    save_data(data)
    return store

def set_today_active_window(chat_id, message_id):
    today = get_today_key()
    if "active_messages" not in data:
        data["active_messages"] = {}
    if today not in data["active_messages"]:
        data["active_messages"][today] = {}
    data["active_messages"][today][str(chat_id)] = message_id
    save_data(data)

# -----------------------------
# Работа с записями
# -----------------------------
def add_record_to_chat(chat_id, amount, note, owner):
    store = get_chat_store(chat_id)
    rid = data.get("next_id", 1)
    rec = {
        "id": rid,
        "short_id": f"R{rid}",
        "timestamp": datetime.now(TZ).isoformat(timespec="seconds"),
        "amount": amount,
        "note": note,
        "owner": owner
    }
    data.setdefault("records", []).append(rec)
    store.setdefault("records", []).append(rec)
    day = get_today_key()
    store.setdefault("daily_records", {}).setdefault(day, []).append(rec)
    store["balance"] = store.get("balance", 0) + amount
    data["overall_balance"] = data.get("overall_balance", 0) + amount
    data["next_id"] = rid + 1
    save_data(data)
    try:
        export_to_csv(data)
    except Exception as e:
        log_error(f"Ошибка при экспорте в CSV после добавления: {e}")

    # Форвард новой записи владельцу или указанному получателю, если включено
    try:
        if store.get("forward_enabled"):
            target = store.get("forward_target_id")
            if not target and OWNER_ID:
                try:
                    target = int(OWNER_ID)
                except:
                    target = None
            if target:
                try:
                    bot.send_message(
                        int(target),
                        f"💰 {fmt_num(rec['amount'])} ARS\n🆔 {rec['short_id']}\n📝 {rec.get('note','')}\n⏱ {rec.get('timestamp')}"
                    )
                except Exception as e:
                    log_error(f"Не удалось переслать запись (target {target}): {e}")
    except Exception as e:
        log_error(f"Ошибка пересылки записи: {e}")

    return rec

def update_record_in_chat(chat_id, rid, new_amount, new_note, user=None):
    store = get_chat_store(chat_id)
    found = None
    for r in store.get("records", []):
        if r["id"] == rid:
            old = r.copy()
            r["amount"] = new_amount
            r["note"] = new_note
            found = r
            break
    if found:
        for day_recs in store.get("daily_records", {}).values():
            for r in day_recs:
                if r["id"] == rid:
                    r.update(found)
        store["balance"] = sum([x["amount"] for x in store.get("records", [])])
        data["overall_balance"] = sum([x["amount"] for x in data.get("records", [])])
        save_data(data)
        try:
            export_to_csv(data)
        except:
            pass
        user_repr = f"{user.id}/{user.username}" if user else "unknown"
        log_info(f"Edit by {user_repr}: R{rid} -> amount={new_amount}, note='{new_note}'")
        return True, found
    return False, None

def delete_record_in_chat(chat_id, rid, user=None):
    store = get_chat_store(chat_id)
    removed = None
    for r in list(store.get("records", [])):
        if r["id"] == rid or str(r["id"]) == str(rid) or r.get("short_id") == f"R{rid}":
            removed = r
            store["records"].remove(r)
            break
    if removed:
        for day_key, recs in store.get("daily_records", {}).items():
            store["daily_records"][day_key] = [x for x in recs if x["id"] != rid]
        store["balance"] = sum([x["amount"] for x in store.get("records", [])])
        data["records"] = [x for x in data.get("records", []) if x["id"] != rid]
        data["overall_balance"] = sum([x["amount"] for x in data.get("records", [])])
        save_data(data)
        try:
            export_to_csv(data)
        except:
            pass
        user_repr = f"{user.id}/{user.username}" if user else "unknown"
        log_info(f"Delete by {user_repr}: R{rid} removed")
        return True, removed
    return False, None

def export_to_csv(d):
    try:
        with open(CSV_FILE, "w", newline='', encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["chat_id","ID","short_id","timestamp","amount","note","owner","day_key"])
            for cid, cdata in d.get("chats", {}).items():
                for day_key, records in cdata.get("daily_records", {}).items():
                    for r in records:
                        writer.writerow([cid, r.get("id"), r.get("short_id"), r.get("timestamp"), r.get("amount"), r.get("note"), r.get("owner"), day_key])
    except Exception as e:
        log_error(f"Ошибка экспорта CSV: {e}")

# -----------------------------
# Клавиатуры
# -----------------------------
def build_main_keyboard(chat_id=None, confirm_reset=False):
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.row(
        types.InlineKeyboardButton("💰 Баланс", callback_data="btn_balance"),
        types.InlineKeyboardButton("📊 Отчёт", callback_data="btn_report"),
        types.InlineKeyboardButton("✏️ Редактировать", callback_data="btn_edit_menu"))
    kb.row(
        types.InlineKeyboardButton("🚀 Обновить", callback_data="btn_start"),
        types.InlineKeyboardButton("ℹ️ Инфо", callback_data="btn_cod")
    )
    balance_text = ""
    if chat_id is not None:
        store = get_chat_store(chat_id)
        balance_text = f"💰 {fmt_num(store.get('balance', 0))} ARS"
    kb.add(types.InlineKeyboardButton(balance_text or "💰 0 ARS", callback_data="noop"))
    return kb

def build_edit_menu_keyboard(chat_id=None):
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.row(
        types.InlineKeyboardButton("📂 CSV", callback_data="btn_csv"),
        types.InlineKeyboardButton("✏️ Редактировать записи", callback_data="btn_edit_list")
    )
    kb.row(
        types.InlineKeyboardButton("📨 Форвард", callback_data="btn_toggle_forward"),
        types.InlineKeyboardButton("👤 Получатель", callback_data="btn_set_forward_target")
    )
    kb.row(
        types.InlineKeyboardButton("⚙️ Обнулить", callback_data="btn_reset"),
        types.InlineKeyboardButton("🔙 Назад", callback_data="back_to_main")
    )
    return kb

def build_edit_keyboard_for_record(rid):
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.add(types.InlineKeyboardButton("✏ Ввести вручную", callback_data=f"edit_manual_{rid}"))
    kb.add(types.InlineKeyboardButton("🗑 Удалить", callback_data=f"edit_delete_{rid}"))
    kb.add(types.InlineKeyboardButton("🔙 Назад", callback_data="edit_back_to_list"))
    return kb

def build_confirm_delete_keyboard(rid):
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.row(types.InlineKeyboardButton("✅ Да, удалить", callback_data=f"confirm_delete_{rid}"),
           types.InlineKeyboardButton("❌ Отмена", callback_data="cancel_delete"))
    return kb

# -----------------------------
# Обновление/создание окна
# -----------------------------
def update_or_send_today_window(chat_id, create_if_missing=True):
    today_key = get_today_key()
    store = get_chat_store(chat_id)
    day_records = store.get("daily_records", {}).get(today_key, [])

    daily_income = sum(r["amount"] for r in day_records if r["amount"] > 0)
    daily_expense = sum(r["amount"] for r in day_records if r["amount"] < 0)
    overall_balance = store.get("balance", 0)

    if not day_records:
        text = (
            f"📅 {today_key}\n"
            f"Пока нет операций.\n"
            f"💵 Приход: {fmt_num(daily_income)} ARS\n"
            f"💸 Расход: {fmt_num(abs(daily_expense))} ARS\n"
            f"💰 Общий остаток: {fmt_num(overall_balance)} ARS"
        )
    else:
        lines = [f"📅 {today_key}", "📋 Операции:"]
        for r in day_records[-50:]:
            sign = "+" if r["amount"] > 0 else "-"
            lines.append(f"{r['short_id']}: {sign}{fmt_num(abs(r['amount']))} — {r.get('note','')}")
        lines.append(
            f"\n💵 Приход: {fmt_num(daily_income)} ARS\n"
            f"💸 Расход: {fmt_num(abs(daily_expense))} ARS\n"
            f"💰 Общий остаток: {fmt_num(overall_balance)} ARS"
        )
        text = "\n".join(lines)

    kb = build_main_keyboard(chat_id)
    try:
        forward_info = ""
        if store.get("forward_enabled"):
            tgt = store.get("forward_target_id") or OWNER_ID
            forward_info = f"\n\n📨 Пересылка: Включена → {tgt}"
        else:
            forward_info = f"\n\n📨 Пересылка: Выключена"
        text = text + forward_info
    except:
        pass

    today_msgs = data.setdefault("active_messages", {}).setdefault(get_today_key(), {})
    active_id = today_msgs.get(str(chat_id))

    if active_id:
        try:
            bot.edit_message_text(text, chat_id, active_id, reply_markup=kb)
        except telebot.apihelper.ApiException as e:
            log_error(f"Не удалось редактировать окно {active_id} для чата {chat_id}: {e}")
        return

    if not create_if_missing:
        return

    try:
        sent = bot.send_message(chat_id, text, reply_markup=kb)
        set_today_active_window(chat_id, sent.message_id)
    except Exception as e:
        log_error(f"Ошибка при создании нового окна для {chat_id}: {e}")

# -----------------------------
# Callback обработчик
# -----------------------------
@bot.callback_query_handler(func=lambda c: True)
def handle_callback(call):
    try:
        chat_id = call.message.chat.id
    except Exception:
        return
    store = get_chat_store(chat_id)
    today_key = get_today_key()
    day_records = store.get("daily_records", {}).get(today_key, [])
    today_msgs = data.setdefault("active_messages", {}).setdefault(today_key, {})
    active_id = today_msgs.get(str(chat_id))

    if call.data == "btn_edit_menu":
        text = (
            "✏️ Меню редактирования\n\n"
            "📂 CSV — экспорт данных\n"
            "📨 Форвард — включить/выключить пересылку\n"
            "👤 Получатель — задать ID для пересылки\n"
            "⚙️ Обнулить — очистить все данные\n"
        )
        if active_id:
            try:
                bot.edit_message_text(text, chat_id, active_id, reply_markup=build_edit_menu_keyboard(chat_id))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка открытия подменю редактирования: {e}")
        else:
            try:
                sent = bot.send_message(chat_id, text, reply_markup=build_edit_menu_keyboard(chat_id))
                set_today_active_window(chat_id, sent.message_id)
            except Exception as e:
                log_error(f"Ошибка отправки подменю редактирования: {e}")
        bot.answer_callback_query(call.id)
        return

    if call.data == "btn_balance":
        daily_income = sum(r["amount"] for r in day_records if r["amount"] > 0)
        daily_expense = sum(r["amount"] for r in day_records if r["amount"] < 0)
        overall_balance = store.get("balance", 0)
        text = (
            f"📅 {today_key}\n\n"
            f"💵 Приход за сегодня: {fmt_num(daily_income)} ARS\n"
            f"💸 Расход за сегодня: {fmt_num(abs(daily_expense))} ARS\n"
            f"💰 Общий остаток: {fmt_num(overall_balance)} ARS"
        )
        if active_id:
            try:
                bot.edit_message_text(text, chat_id, active_id, reply_markup=build_main_keyboard(chat_id))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка редактирования окна (Баланс): {e}")
        else:
            update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Баланс обновлён ✅")
        return

    if call.data == "btn_report":
        expenses = [r for r in day_records if r["amount"] < 0]
        daily_expense_total = sum(abs(r["amount"]) for r in expenses)
        if not expenses:
            text = f"📅 {today_key}\nПока нет расходов за сегодня.\n💸 Расход за день: 0 ARS"
        else:
            lines = [f"📅 {today_key}", "📋 Расходы за день:"]
            for r in expenses[-30:]:
                lines.append(f"{r['short_id']}: -{fmt_num(abs(r['amount']))} — {r.get('note','')}")
            lines.append(f"\n💸 Расход за день: {fmt_num(daily_expense_total)} ARS")
            text = "\n".join(lines)
        if active_id:
            try:
                bot.edit_message_text(text, chat_id, active_id, reply_markup=build_main_keyboard(chat_id))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка редактирования окна (Отчёт расходов): {e}")
        else:
            update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Отчёт расходов обновлён 📊")
        return

    if call.data == "btn_csv":
        try:
            with open(CSV_FILE, "rb") as f:
                bot.send_document(chat_id, f, caption="📂 Ваш файл data.csv")
            bot.answer_callback_query(call.id, "CSV отправлен 📁")
        except Exception as e:
            bot.send_message(chat_id, f"❌ Ошибка при отправке CSV: {e}")
            bot.answer_callback_query(call.id)
        return

    if call.data == "btn_toggle_forward":
        store["forward_enabled"] = not store.get("forward_enabled", False)
        save_data(data)
        status = "включена ✅" if store["forward_enabled"] else "выключена ❌"
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, f"Пересылка {status}")
        return

    if call.data == "btn_set_forward_target":
        try:
            bot.answer_callback_query(call.id)
            sent = bot.send_message(chat_id, "Введите ID пользователя, которому нужно пересылать записи (или введите 0, чтобы сбросить):")
            bot.register_next_step_handler(sent, process_forward_target)
        except Exception as e:
            log_error(f"Ошибка при запросе ID получателя: {e}")
            bot.answer_callback_query(call.id, "Не удалось запросить ID получателя.")
        return

    if call.data == "btn_reset":
        if active_id:
            try:
                bot.edit_message_text("Для обнуления используйте команду /reset (введите `/reset` в чате).", chat_id, active_id, reply_markup=build_main_keyboard(chat_id))
            except:
                pass
        bot.answer_callback_query(call.id)
        return

    if call.data == "confirm_reset":
        store["records"] = []
        store["daily_records"] = {}
        store["balance"] = 0
        data["records"] = [x for x in data.get("records", []) if x.get("owner") != chat_id]
        try:
            data["overall_balance"] = sum([x["amount"] for x in data.get("records", [])])
        except:
            data["overall_balance"] = 0
        save_data(data)
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Данные сброшены 🧹")
        return

    if call.data == "cancel_reset":
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Отмена")
        return

    if call.data == "btn_start":
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Окно обновлено 🔄")
        return

    if call.data == "btn_cod":
        info_text = (
            f"ℹ️ Финансовый бот — версия {VERSION}\n\n"
            "📌 Доступные команды:\n"
            "/start - Запуск бота и создание окна отчёта на сегодня\n"
            "/balance - Показать общий остаток за день\n"
            "/report - Показать список расходов текущего дня\n"
            "/csv - Скачать файл с историей операций\n"
            "/reset - Полностью очистить все записи (покажет подтверждение)\n"
            "/ping - Проверить жив ли бот\n"
            "/help - Помощь\n\n"
            "📝 Добавление операций (форматы):\n"
            "+500 Зарплата    (или ^+^500^)\n"
            "-150 Обед       (или ^-^150^)\n"
        )
        if active_id:
            try:
                bot.edit_message_text(info_text, chat_id, active_id, reply_markup=build_main_keyboard(chat_id))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка редактирования окна (Инфо): {e}")
        else:
            try:
                sent = bot.send_message(chat_id, info_text, reply_markup=build_main_keyboard(chat_id))
                set_today_active_window(chat_id, sent.message_id)
            except Exception as e:
                log_error(f"Ошибка отправки инфо: {e}")
        bot.answer_callback_query(call.id)
        return

    if call.data == "btn_edit_list":
        if not day_records:
            text = f"📅 {today_key}\nПока нет операций за сегодня."
            if active_id:
                try:
                    bot.edit_message_text(text, chat_id, active_id, reply_markup=build_main_keyboard(chat_id))
                except telebot.apihelper.ApiException as e:
                    log_error(f"Ошибка редактирования окна (пустой список редактирования): {e}")
            else:
                update_or_send_today_window(chat_id)
            bot.answer_callback_query(call.id, "Нет записей для редактирования")
            return

        lines = [f"📅 {today_key}", "Выберите запись для редактирования:"]
        kb = types.InlineKeyboardMarkup(row_width=1)
        for r in reversed(day_records[-20:]):
            sign = "+" if r["amount"] > 0 else "-"
            label = f"{r['short_id']}: {sign}{fmt_num(abs(r['amount']))} — {r.get('note','')}"
            kb.add(types.InlineKeyboardButton(label, callback_data=f"rec_{r['id']}"))
        kb.add(types.InlineKeyboardButton("🔙 Назад", callback_data="back_to_main"))
        text = "\n".join(lines)
        if active_id:
            try:
                bot.edit_message_text(text, chat_id, active_id, reply_markup=kb)
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка показа списка редактирования: {e}")
        else:
            try:
                sent = bot.send_message(chat_id, text, reply_markup=kb)
                set_today_active_window(chat_id, sent.message_id)
            except Exception as e:
                log_error(f"Ошибка отправки списка редактирования: {e}")
        bot.answer_callback_query(call.id)
        return

    if call.data and call.data.startswith("rec_"):
        try:
            rid = int(call.data.split("_",1)[1])
        except:
            bot.answer_callback_query(call.id, "Неверный ID")
            return
        rec = None
        for r in day_records:
            if r["id"] == rid:
                rec = r
                break
        if not rec:
            bot.answer_callback_query(call.id, "Запись не найдена")
            return
        sign = "+" if rec["amount"] > 0 else "-"
        text = f"Запись {rec['short_id']}\n{sign}{fmt_num(abs(rec['amount']))} — {rec.get('note','')}\nДобавлена: {rec.get('timestamp')}"
        kb = build_edit_keyboard_for_record(rid)
        if active_id:
            try:
                bot.edit_message_text(text, chat_id, active_id, reply_markup=kb)
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка показа детали записи: {e}")
        else:
            try:
                sent = bot.send_message(chat_id, text, reply_markup=kb)
                set_today_active_window(chat_id, sent.message_id)
            except Exception as e:
                log_error(f"Ошибка отправки детали записи: {e}")
        bot.answer_callback_query(call.id)
        return

    if call.data and call.data.startswith("preset_add_"):
        parts = call.data.split("_")
        try:
            rid = int(parts[2])
            delta = int(parts[3])
        except:
            bot.answer_callback_query(call.id, "Неверные параметры")
            return
        success = False
        for r in store.get("records", []):
            if r["id"] == rid:
                new_amount = r["amount"] + delta
                new_note = r.get("note","")
                user = call.from_user
                success, _ = update_record_in_chat(chat_id, rid, new_amount, new_note, user=user)
                break
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Сумма обновлена" if success else "Не удалось изменить")
        return

    # /////в одном окне//////
    if call.data and call.data.startswith("edit_manual_"):
        try:
            rid = int(call.data.split("_", 2)[2])
        except:
            bot.answer_callback_query(call.id, "Неверный ID")
            return

        store["edit_wait"] = "change_value"
        store["edit_target"] = rid
        save_data(data)

        text = f"Введите новую сумму и заметку для записи R{rid} в формате:\n+500 Зарплата  или  ^+^500^ Зарплата  или  ^-^150^ Обед"

        try:
            bot.edit_message_text(
                chat_id=chat_id,
                message_id=call.message.message_id,
                text=text,
                reply_markup=call.message.reply_markup  # <-- сохраняем кнопки
            )
        except Exception as e:
            bot.send_message(chat_id, text)

        bot.answer_callback_query(call.id)
        return

    if call.data and call.data.startswith("edit_delete_"):
        try:
            rid = int(call.data.split("_",2)[2])
        except:
            bot.answer_callback_query(call.id, "Неверный ID")
            return
        if active_id:
            try:
                bot.edit_message_text(f"Подтвердите удаление записи R{rid}:", chat_id, active_id, reply_markup=build_confirm_delete_keyboard(rid))
            except telebot.apihelper.ApiException as e:
                log_error(f"Ошибка показа подтверждения удаления: {e}")
        else:
            try:
                sent = bot.send_message(chat_id, f"Подтвердите удаление записи R{rid}:", reply_markup=build_confirm_delete_keyboard(rid))
                set_today_active_window(chat_id, sent.message_id)
            except Exception as e:
                log_error(f"Ошибка отправки подтверждения удаления: {e}")
        bot.answer_callback_query(call.id)
        return

    if call.data and call.data.startswith("confirm_delete_"):
        try:
            rid = int(call.data.split("_",2)[2])
        except:
            bot.answer_callback_query(call.id, "Неверный ID")
            return
        success, _ = delete_record_in_chat(chat_id, rid, user=call.from_user)
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Запись удалена" if success else "Запись не найдена")
        return

    if call.data == "cancel_delete":
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id, "Отмена удаления")
        return

    if call.data in ("back_to_main", "edit_back_to_list", "edit_back"):
        update_or_send_today_window(chat_id)
        bot.answer_callback_query(call.id)
        return

    if call.data == "noop":
        bot.answer_callback_query(call.id)
        return

    bot.answer_callback_query(call.id)
    return

# -----------------------------
# Regex для сумм
# -----------------------------
num_re = re.compile(r'(\^[+-]\^[0-9]+|\^[+-]?[0-9]+\^|[+-]?\s*\d+)')

def parse_amount_token(token:str):
    t = token.strip()
    t = t.replace("^", "")
    t = t.replace(" ", "")
    if t.startswith("+"):
        return int(t[1:])
    if t.startswith("-"):
        return -int(t[1:])
    return -int(t)

# -----------------------------
# Обработка установки получателя форварда (next-step)
# -----------------------------
def process_forward_target(message):
    try:
        chat_id = message.chat.id
        store = get_chat_store(chat_id)
        text = (message.text or "").strip()

        if text == "0":
            store["forward_target_id"] = None
            save_data(data)
            bot.send_message(chat_id, "✅ Получатель пересылки сброшен (будет использоваться OWNER_ID, если он задан).")
            update_or_send_today_window(chat_id)
            return

        text = text.strip()

        if not (text.startswith("-") or text.isdigit()):
            bot.send_message(chat_id, "❌ Некорректный ID. Пример: -1001234567890\nПопробуйте снова или введите 0 для сброса.")
            return

        try:
            target = int(text)
        except Exception:
            bot.send_message(chat_id, "❌ Не удалось распознать ID. Попробуйте снова.")
            return

        store["forward_target_id"] = target
        save_data(data)
        bot.send_message(chat_id, f"✅ Теперь пересылка будет идти пользователю с ID {target}.")
        update_or_send_today_window(chat_id)

    except Exception as e:
        log_error(f"Ошибка process_forward_target: {e}")
        try:
            bot.send_message(message.chat.id, "❌ Ошибка при установке получателя. Попробуйте ещё раз.")
        except:
            pass

# -----------------------------
# Входящие сообщения и команды
# -----------------------------
@bot.message_handler(commands=["start", "info"])
def cmd_start(msg):
    chat_id = msg.chat.id
    update_or_send_today_window(chat_id, create_if_missing=True)

@bot.message_handler(commands=["help"])
def cmd_help(msg):
    chat_id = msg.chat.id
    bot.send_message(chat_id, "Отправьте сумму в формате +500 Примечание или -150 Обед. Команды: /start /balance /report /csv /reset /ping")

@bot.message_handler(commands=["ping"])
def cmd_ping(msg):
    chat_id = msg.chat.id
    bot.send_message(chat_id, "PONG — бот живой ✅")

@bot.message_handler(commands=["balance"])
def cmd_balance(msg):
    chat_id = msg.chat.id
    store = get_chat_store(chat_id)
    today_key = get_today_key()
    day_records = store.get("daily_records", {}).get(today_key, [])
    daily_income = sum(r["amount"] for r in day_records if r["amount"] > 0)
    daily_expense = sum(r["amount"] for r in day_records if r["amount"] < 0)
    overall_balance = store.get("balance", 0)
    text = (
        f"📅 {today_key}\n\n"
        f"💰 Общий остаток: {fmt_num(overall_balance)} ARS\n"
        f"💵 Приход за сегодня: {fmt_num(daily_income)} ARS\n"
        f"💸 Расход за сегодня: {fmt_num(abs(daily_expense))} ARS"
    )
    bot.send_message(chat_id, text)

@bot.message_handler(commands=["report"])
def cmd_report(msg):
    chat_id = msg.chat.id
    store = get_chat_store(chat_id)
    today_key = get_today_key()
    day_records = store.get("daily_records", {}).get(today_key, [])
    expenses = [r for r in day_records if r["amount"] < 0]
    if not expenses:
        bot.send_message(chat_id, f"📅 {today_key}\nПока нет расходов за сегодня.\n💸 Расход за день: 0 ARS")
        return
    lines = [f"📅 {today_key}", "📋 Расходы за день:"]
    for r in expenses[-30:]:
        lines.append(f"{r['short_id']}: -{fmt_num(abs(r['amount']))} — {r.get('note','')}")
    lines.append(f"\n💸 Расход за день: {fmt_num(sum(abs(r['amount']) for r in expenses))} ARS")
    bot.send_message(chat_id, "\n".join(lines))

@bot.message_handler(commands=["csv"])
def cmd_csv(msg):
    chat_id = msg.chat.id
    try:
        with open(CSV_FILE, "rb") as f:
            bot.send_document(chat_id, f, caption="📂 Ваш файл data.csv")
    except Exception as e:
        bot.send_message(chat_id, f"❌ Ошибка при отправке CSV: {e}")

@bot.message_handler(commands=["reset"])
def cmd_reset(msg):
    chat_id = msg.chat.id
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.row(types.InlineKeyboardButton("✅ Да, обнулить", callback_data="confirm_reset"),
           types.InlineKeyboardButton("❌ Отмена", callback_data="cancel_reset"))
    bot.send_message(chat_id, "⚠️ Вы уверены, что хотите обнулить все данные этого чата? Это действие нельзя будет отменить.", reply_markup=kb)

# Основной обработчик текстовых сообщений
@bot.message_handler(func=lambda m: True)
def handle_message(msg):
    chat_id = msg.chat.id
    store = get_chat_store(chat_id)
    wait_action = store.get("edit_wait")

    # Если ожидаем ввод вручную для редактирования
    if wait_action == "change_value":
        rid = store.get("edit_target")
        if not rid:
            store["edit_wait"] = None
            store["edit_target"] = None
            save_data(data)
            return
        parts = msg.text.strip().split(" ", 1)
        try:
            amount_token = parts[0]
            amount = parse_amount_token(amount_token)
            note = parts[1] if len(parts) > 1 else ""
            success, _ = update_record_in_chat(chat_id, rid, amount, note, user=msg.from_user)
            store["edit_wait"] = None
            store["edit_target"] = None
            save_data(data)
            update_or_send_today_window(chat_id)
            bot.send_message(chat_id, f"✅ Запись R{rid} {'изменена' if success else 'не найдена'}")
        except Exception as e:
            log_error(f"Ошибка при изменении записи вручную: {e}")
            bot.send_message(chat_id, "Ошибка при вводе суммы. Введите в формате +500 Зарплата или ^+^500^ Зарплата или ^-^150^ Обед")
        return

    # Обычное добавление записи. Находим токен с суммой.
    if not msg.text:
        return
    m = re.search(r'(\^[+-]\^[0-9]+|\^[+-]?[0-9]+\^|[+-]?\s*\d+)', msg.text)
    if m:
        try:
            raw = m.group(0)
            raw_clean = raw.replace("^", "").replace(" ", "")
            amount = parse_amount_token(raw_clean)
            note = msg.text.replace(m.group(0), "").strip()
            add_record_to_chat(chat_id, amount, note, msg.from_user.id)
            update_or_send_today_window(chat_id)
            send_temp_message(chat_id, "✅ Запись добавлена", delay=5)
        except Exception as e:
            log_error(f"Ошибка авто-добавления записи: {e}")
            bot.send_message(chat_id, "❌ Ошибка при добавлении записи. Проверьте формат.")
        return

    # Если сообщение не распознано как добавление — краткая подсказка
    bot.send_message(chat_id, "Я получил сообщение. Чтобы добавить запись, отправьте сумму в формате +500 Заметка. Для помощи — /help")
    return

# -----------------------------
# Flask webhook
# -----------------------------
@app.route(f"/{TOKEN}", methods=["POST"])
def webhook():
    update = telebot.types.Update.de_json(request.get_data().decode("utf-8"))
    bot.process_new_updates([update])
    return "OK", 200

@app.route("/", methods=["GET"])
def index():
    return f"Финансовый бот «ФО» — версия {VERSION} работает", 200

# -----------------------------
# Keep-alive / self-ping / notify owner
# -----------------------------
def keep_alive_task():
    last_notice = 0
    while True:
        try:
            log_info("Keep-alive: выполняем пинг self и уведомление владельца (если задан).")
            # self-ping (полезно для некоторых хостов)
            try:
                if APP_URL:
                    resp = requests.get(APP_URL, timeout=10)
                    log_info(f"Keep-alive: self-ping {APP_URL} -> {resp.status_code}")
            except Exception as e:
                log_error(f"Keep-alive: ошибка self-ping: {e}")

            # уведомление владельцу (один раз за интервал)
            if KEEP_ALIVE_SEND_TO_OWNER and OWNER_ID:
                try:
                    tgt = int(OWNER_ID)
                    # отправляем простое информирование (не спамим — только если прошло время)
                    bot.send_message(tgt, f"🟢 Keep-alive: бот версия {VERSION} работает. Время: {datetime.now(TZ).isoformat(timespec='seconds')}")
                    log_info(f"Keep-alive: уведомление отправлено владельцу {tgt}")
                except Exception as e:
                    log_error(f"Keep-alive: не удалось отправить уведомление владельцу: {e}")
        except Exception as e:
            log_error(f"Keep-alive: ошибка основного цикла: {e}")
        # ждем следующий интервал
        time.sleep(max(10, KEEP_ALIVE_INTERVAL_SECONDS))

def start_keep_alive_thread():
    thread = threading.Thread(target=keep_alive_task, daemon=True)
    thread.start()

# -----------------------------
# Установка webhook и планировщик
# -----------------------------
def set_webhook():
    url = f"{APP_URL}/{TOKEN}"
    try:
        bot.remove_webhook()
        time.sleep(0.5)
        bot.set_webhook(url=url)
        log_info(f"Webhook установлен: {url}")
    except Exception as e:
        log_error(f"Не удалось установить webhook: {e}")

def schedule_daily_window_creation():
    def task():
        last_day = get_today_key()
        while True:
            try:
                time.sleep(60)
                current_day = get_today_key()
                if current_day != last_day:
                    for chat_id_str in list(data.get("chats", {}).keys()):
                        try:
                            chat_id = int(chat_id_str)
                        except:
                            continue
                        try:
                            update_or_send_today_window(chat_id)
                        except Exception as e:
                            log_error(f"Ошибка при создании окна нового дня для {chat_id}: {e}")
                    last_day = current_day
            except Exception as e:
                log_error(f"Ошибка в daily loop: {e}")
                time.sleep(5)
    thread = threading.Thread(target=task, daemon=True)
    thread.start()

# -----------------------------
# Запуск
# -----------------------------
if __name__ == "__main__":
    set_webhook()
    schedule_daily_window_creation()
    start_keep_alive_thread()
    log_info(f"Бот ФО версии {VERSION} запущен")
    try:
        if OWNER_ID:
            bot.send_message(int(OWNER_ID), f"✅ Бот запущен и работает! (версия {VERSION})")
    except Exception as e:
        log_error(f"Не удалось отправить сообщение о запуске: {e}")
    app.run(host="0.0.0.0", port=PORT)