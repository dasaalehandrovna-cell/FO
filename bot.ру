# ============================================
# Финансовый бот — версия 9.8.7
# На базе 9.8.6 — добавлено:
# - автоматический бэкап каждые 5 минут (history внутри data.json)
# - восстановление последнего состояния из data.json (если доступно)
# - никаких телеграм-уведомлений при автосохранении (по твоей просьбе)
# ============================================

import os
import json
import csv
import logging
from datetime import datetime
from zoneinfo import ZoneInfo
import telebot
from flask import Flask, request
from telebot import types

# дополнительные импорты для бэкапа/планировщика
import threading
import time

# --- Конфигурация ---
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
APP_URL = os.getenv("APP_URL", "https://yourapp.onrender.com")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
LOG_FILE = "log.txt"
PORT = int(os.environ.get("PORT", 5000))
VERSION = "9.8.7"  # bumped

if not TOKEN:
    raise ValueError("BOT_TOKEN не установлен!")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -----------------------------
# Форматирование чисел
# -----------------------------
def fmt_num(value):
    try:
        return f"{value:,.0f}".replace(",", ".")
    except Exception:
        return str(value)

# -----------------------------
# Логирование
# -----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="[{asctime}] {levelname}: {message}",
    style="{",
    handlers=[logging.FileHandler(LOG_FILE, encoding="utf-8"), logging.StreamHandler()]
)

def log_info(msg): logging.info(msg)
def log_error(msg): logging.error(msg)

log_info(f"Старт приложения. Версия {VERSION}")

# -----------------------------
# Работа с файлами и бэкапами
# -----------------------------
def default_data():
    return {
        "overall_balance": 0,
        "records": [],
        "chats": {},
        "active_messages": {},
        "processed_messages": [],
        "forward_targets": [],
        "tracked_messages": {},
        "next_id": 1
    }

# Загрузка данных: читаем data.json, если там есть "current" — используем его.
# Если "current" отсутствует, но есть "backups" — берём последний бэкап.
def load_data():
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                file_data = json.load(f)
            # prefer "current" key (actual data snapshot)
            if isinstance(file_data, dict) and "current" in file_data and isinstance(file_data["current"], dict):
                d = file_data["current"]
                log_info("Данные загружены из data.json -> current")
            else:
                # если файла структура — старый (plain data) или имеет backups
                if isinstance(file_data, dict) and "backups" in file_data and isinstance(file_data["backups"], dict) and file_data["backups"]:
                    # используем последний бэкап как текущее состояние
                    try:
                        last_key = sorted(file_data["backups"].keys())[-1]
                        d = file_data["backups"][last_key]
                        log_info(f"Данные загружены из data.json -> последний бэкап {last_key}")
                    except Exception as e:
                        log_error(f"Ошибка выбора последнего бэкапа: {e}")
                        d = default_data()
                else:
                    # возможно файл уже просто содержит текущую структуру
                    if isinstance(file_data, dict):
                        d = file_data
                        log_info("Данные загружены из data.json (без current/backups)")
                    else:
                        d = default_data()
        except Exception as e:
            log_error(f"Ошибка чтения {DATA_FILE}: {e} — используем дефолт или попробуем восстановить из backups (если возможно)")
            # Попытка восстановить — если файл повреждён, но всё равно можно попытаться прочитать via fallback
            d = default_data()
    else:
        d = default_data()
    # ensure schema compatibility
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

# save_data: записывает актуальное состояние в data.json -> поле "current".
# Бэкап-история добавляется отдельно функцией backup_data(), чтобы не раздувать файл при каждом save.
def save_data(d):
    try:
        # Загружаем существующую структуру файла (если есть) чтобы не терять "backups"
        file_data = {}
        if os.path.exists(DATA_FILE):
            try:
                with open(DATA_FILE, "r", encoding="utf-8") as f:
                    file_data = json.load(f)
            except Exception:
                file_data = {}

        # Обновляем current
        file_data["current"] = d

        # Если нет раздела backups — оставляем как есть (backup_data создаст его)
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(file_data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        log_error(f"Ошибка сохранения: {e}")

# backup_data: добавляет snapshot текущих данных в file_data["backups"] с меткой времени.
# Храним только последние N версий (по умолчанию 10).
def backup_data(max_backups=10):
    try:
        # Текущий момент
        ts = datetime.now(TZ).strftime("%Y-%m-%d %H:%M:%S")

        # Загружаем текущую структуру файла (если есть)
        file_data = {}
        if os.path.exists(DATA_FILE):
            try:
                with open(DATA_FILE, "r", encoding="utf-8") as f:
                    file_data = json.load(f)
            except Exception:
                file_data = {}

        # Убедимся, что current существует — если нет, положим текущую in-memory переменную
        current_snapshot = file_data.get("current") if isinstance(file_data, dict) and file_data.get("current") else data

        # Инициализация backups
        if "backups" not in file_data or not isinstance(file_data["backups"], dict):
            file_data["backups"] = {}

        # Записываем с полным снимком (можно сохранить всё — current_snapshot)
        # Чтобы не хранить слишком большой объем, можно сохранять current_snapshot целиком.
        file_data["backups"][ts] = current_snapshot

        # Обрезаем старые бэкапы (оставляем max_backups последних)
        if len(file_data["backups"]) > max_backups:
            keys = sorted(file_data["backups"].keys())
            while len(keys) > max_backups:
                del_key = keys.pop(0)
                try:
                    del file_data["backups"][del_key]
                except KeyError:
                    pass

        # Обновляем поле current (на всякий случай — уже должно быть)
        file_data["current"] = current_snapshot

        # Сохраняем обратно
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(file_data, f, ensure_ascii=False, indent=2)

        log_info(f"Бэкап {ts} добавлен в {DATA_FILE}")
    except Exception as e:
        log_error(f"Ошибка при создании бэкапа: {e}")

# Загружаем начальные данные
data = load_data()

# если задан OWNER_ID — добавим его в глобальные цели (совместимость)
if OWNER_ID:
    try:
        oi = int(OWNER_ID)
        if oi not in data.get("forward_targets", []):
            data["forward_targets"].append(oi)
            save_data(data)
    except Exception:
        pass

# -----------------------------
# Вспомогательные функции
# -----------------------------
def get_today_key():
    return datetime.now(TZ).strftime("%Y-%m-%d")

def get_chat_store(chat_id):
    cid = str(chat_id)
    if cid not in data["chats"]:
        data["chats"][cid] = {
            "balance": 0,
            "records": [],
            "daily_records": {},
            "forward_enabled": False,
            "forward_target_id": None
        }
        save_data(data)
    return data["chats"][cid]

def set_today_active_window(chat_id, message_id):
    today = get_today_key()
    data.setdefault("active_messages", {}).setdefault(today, {})[str(chat_id)] = message_id
    save_data(data)

# -----------------------------
# Добавление записи
# -----------------------------
def add_record_to_chat(chat_id, amount, note, owner):
    store = get_chat_store(chat_id)
    rid = data["next_id"]
    rec = {
        "id": rid,
        "short_id": f"R{rid}",
        "timestamp": datetime.now(TZ).isoformat(timespec="seconds"),
        "amount": amount,
        "note": note,
        "owner": owner
    }
    store["records"].append(rec)
    store.setdefault("daily_records", {}).setdefault(get_today_key(), []).append(rec)
    store["balance"] = store.get("balance", 0) + amount
    data.setdefault("records", []).append(rec)
    data["overall_balance"] = data.get("overall_balance", 0) + amount
    data["next_id"] = data.get("next_id", 1) + 1
    save_data(data)
    export_to_csv(data)

    # Пересылка, если включена (безопасно — в try)
    try:
        if store.get("forward_enabled"):
            target = store.get("forward_target_id") or OWNER_ID
            if target:
                bot.send_message(int(target), f"💰 {fmt_num(amount)} ARS — {note}")
    except Exception as e:
        log_error(f"Ошибка пересылки: {e}")

    return rec

# -----------------------------
# Редактирование и удаление
# -----------------------------
def update_record_in_chat(chat_id, rid, new_amount, new_note):
    store = get_chat_store(chat_id)
    for r in store["records"]:
        if r["id"] == rid:
            r["amount"] = new_amount
            r["note"] = new_note
    store["balance"] = sum(x["amount"] for x in store["records"])
    data["overall_balance"] = sum(x["amount"] for x in data.get("records", []))
    save_data(data)
    export_to_csv(data)

def delete_record_in_chat(chat_id, rid):
    store = get_chat_store(chat_id)
    store["records"] = [r for r in store["records"] if r["id"] != rid]
    store["balance"] = sum(x["amount"] for x in store["records"])
    data["records"] = [x for x in data.get("records", []) if x["id"] != rid]
    data["overall_balance"] = sum(x["amount"] for x in data.get("records", []))
    save_data(data)
    export_to_csv(data)

# -----------------------------
# CSV
# -----------------------------
def export_to_csv(d):
    try:
        with open(CSV_FILE, "w", newline='', encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["chat_id","id","short_id","timestamp","amount","note","owner"])
            for cid, store in d.get("chats", {}).items():
                for rec in store.get("records", []):
                    writer.writerow([cid, rec["id"], rec["short_id"], rec["timestamp"], rec["amount"], rec["note"], rec["owner"]])
    except Exception as e:
        log_error(f"Ошибка CSV: {e}")

# -----------------------------
# Клавиатуры
# -----------------------------
def build_edit_menu_keyboard(chat_id=None):
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.row(
        types.InlineKeyboardButton("📂 CSV", callback_data="btn_csv"),
        types.InlineKeyboardButton("✏️ Редактировать записи", callback_data="btn_edit_list")
    )
    kb.row(
        types.InlineKeyboardButton("📨 Форвард", callback_data="btn_toggle_forward"),
        types.InlineKeyboardButton("👤 Получатель", callback_data="btn_set_forward_target")
    )
    kb.row(
        types.InlineKeyboardButton("⚙️ Обнулить", callback_data="btn_reset"),
        types.InlineKeyboardButton("🔙 Назад", callback_data="back_to_main")
    )
    return kb

def build_main_keyboard(chat_id=None):
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.row(
        types.InlineKeyboardButton("💰 Баланс", callback_data="btn_balance"),
        types.InlineKeyboardButton("📊 Отчёт", callback_data="btn_report"),
        types.InlineKeyboardButton("✏️ Редактировать", callback_data="btn_edit_menu")
    )
    kb.row(
        types.InlineKeyboardButton("🚀 Обновить", callback_data="btn_start"),
        types.InlineKeyboardButton("ℹ️ Инфо", callback_data="btn_cod")
    )
    return kb

# -----------------------------
# Callback обработчик
# -----------------------------
@bot.callback_query_handler(func=lambda c: True)
def handle_callback(call):
    chat_id = call.message.chat.id
    store = get_chat_store(chat_id)

    if call.data == "btn_toggle_forward":
        store["forward_enabled"] = not store["forward_enabled"]
        save_data(data)
        status = "включена ✅" if store["forward_enabled"] else "выключена ❌"
        bot.answer_callback_query(call.id, f"Пересылка {status}")
        return

    if call.data == "btn_set_forward_target":
        msg = bot.send_message(chat_id, "Введите ID получателя (0 — сброс):")
        bot.register_next_step_handler(msg, process_forward_target)
        return

def process_forward_target(message):
    chat_id = message.chat.id
    store = get_chat_store(chat_id)
    try:
        tid = int(message.text)
        if tid == 0:
            store["forward_target_id"] = None
            bot.send_message(chat_id, "Получатель сброшен.")
        else:
            store["forward_target_id"] = tid
            bot.send_message(chat_id, f"Получатель задан: {tid}")
        save_data(data)
    except Exception:
        bot.send_message(chat_id, "Неверный формат ID.")

# -----------------------------
# Flask webhook
# -----------------------------
@app.route("/" + TOKEN, methods=["POST"])
def receive_update():
    bot.process_new_updates([telebot.types.Update.de_json(request.stream.read().decode("utf-8"))])
    return "ok", 200

@app.route("/")
def index():
    return "Bot is running.", 200

# -----------------------------
# Автоматический бэкап (запуск потокa)
# -----------------------------
def _start_auto_backup_loop():
    def loop():
        # Сначала делаем бэкап при старте (чтобы сохранить текущее состояние)
        try:
            backup_data()
        except Exception as e:
            log_error(f"Ошибка при стартап-бэкапе: {e}")
        # Затем цикл каждые 5 минут
        while True:
            time.sleep(300)  # 5 минут
            try:
                backup_data()
            except Exception as e:
                log_error(f"Ошибка в автобэкапе: {e}")
    t = threading.Thread(target=loop, daemon=True)
    t.start()

# -----------------------------
# Запуск
# -----------------------------
if __name__ == "__main__":
    # Start auto-backup thread silently (no Telegram notifications)
    _start_auto_backup_loop()

    log_info("Бот запущен на Flask")
    app.run(host="0.0.0.0", port=PORT)
# -----------------------------
# Запуск
# -----------------------------
if __name__ == "__main__":
    set_webhook()
    schedule_daily_window_creation()
    log_info(f"Бот ФО версии {VERSION} запущен")
    try:
        if OWNER_ID:
            bot.send_message(int(OWNER_ID), f"✅ Бот запущен и работает! (версия {VERSION})")
    except Exception as e:
        log_error(f"Не удалось отправить сообщение о запуске: {e}")
    app.run(host="0.0.0.0", port=PORT)