# -------------------------------
# –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç "–§–û" ‚Äî –≤–µ—Ä—Å–∏—è 9.8.0.1
# –ü–æ–ª–Ω–∞—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è (–Ω–∞ –±–∞–∑–µ 9.6.1)
# Flask webhook ‚Äî –≥–æ—Ç–æ–≤ –∫ Deploy –Ω–∞ Render
# –¢—Ä–µ–±—É–µ—Ç: BOT_TOKEN, OWNER_ID, RENDER_EXTERNAL_URL (env)
# requirements.txt: pyTelegramBotAPI==4.23.0, flask
# -------------------------------

import os
import json
import time
import threading
import re
import csv
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Optional, Tuple, Dict, Any
from flask import Flask, request
import telebot
from telebot import types

# -------------------------------
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
# -------------------------------
VERSION = "9.8.0.1"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/" + TOKEN) if TOKEN else "/webhook"

if not TOKEN:
    raise ValueError("–û—à–∏–±–∫–∞: BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------------
# –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
# -------------------------------
def default_data() -> Dict[str, Any]:
    return {
        "version_base": "9.6.1",
        "version_current": VERSION,
        "overall_balance": 0,
        "records": [],           # {id, short_id, timestamp, amount, note, owner}
        "active_messages": {},   # YYYY-MM-DD -> {chat_id, message_id}
        "next_id": 1,
        "sent_messages": [],     # –∏—Å—Ç–æ—Ä–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –±–æ—Ç–æ–º —Å–æ–æ–±—â–µ–Ω–∏–π
        "forward_targets": {},   # "<owner_chat_id>": ["<target1>", ...]
    }

def load_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception:
            d = default_data()
    else:
        d = default_data()
    for k, v in default_data().items():
        if k not in d:
            d[k] = v
    return d

def save_data(d: Dict[str, Any]) -> None:
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[save_data] –û—à–∏–±–∫–∞: {e}")

data = load_data()

# -------------------------------
# –£—Ç–∏–ª–∏—Ç—ã —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
# -------------------------------
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text: str) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    sign = '+' if s.startswith('+') else ('-' if s.startswith('-') else '')
    digits = s[1:].strip() if sign else s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    dm = re.match(r'(\d+)', digits_norm)
    if not dm:
        return None, None, None
    return int(dm.group(1)), sign, raw

def apply_sign_and_normalize(num: int, sign: Optional[str]) -> int:
    return num if sign == '+' else -num

def fmt_amount(n: int) -> str:
    return f"{abs(n):,}".replace(",", ".")

def make_short_id(n: int) -> str:
    return f"R{n}"

def date_local_str(dt: datetime) -> str:
    return dt.astimezone(TZ).strftime("%Y-%m-%d")

def time_local_str(dt: datetime) -> str:
    return dt.astimezone(TZ).strftime("%H:%M")

def now_iso_utc() -> str:
    return datetime.now(tz=ZoneInfo("UTC")).isoformat()

# -------------------------------
# –ó–∞–ø–∏—Å—å —Å–æ–æ–±—â–µ–Ω–∏–π
# -------------------------------
def record_sent_message(entry: Dict[str, Any]) -> None:
    data.setdefault("sent_messages", []).append(entry)
    save_data(data)

def send_and_record(chat_id: int, text: str, reply_markup=None, parse_mode=None, purpose: str="msg"):
    try:
        sent = bot.send_message(int(chat_id), text, reply_markup=reply_markup, parse_mode=parse_mode)
        record_sent_message({"chat_id": chat_id, "message_id": sent.message_id, "purpose": purpose, "timestamp": now_iso_utc()})
        return sent
    except Exception as e:
        record_sent_message({"chat_id": chat_id, "message_id": None, "purpose": purpose, "timestamp": now_iso_utc(), "error": str(e)})
        try: bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ {chat_id}: {e}")
        except Exception: pass
        return None

def send_file_and_record(chat_id: int, path: str, caption=None, purpose="file"):
    try:
        with open(path, "rb") as f:
            sent = bot.send_document(int(chat_id), f, caption=caption)
        record_sent_message({"chat_id": chat_id, "message_id": sent.message_id, "purpose": purpose, "timestamp": now_iso_utc()})
        return sent
    except Exception as e:
        record_sent_message({"chat_id": chat_id, "message_id": None, "purpose": purpose, "timestamp": now_iso_utc(), "error": str(e)})
        try: bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Ñ–∞–π–ª–∞ –≤ {chat_id}: {e}")
        except Exception: pass
        return None

# -------------------------------
# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
# -------------------------------
def get_day_records_for_chat(chat_id: int, day_date: str):
    recs = []
    for r in data.get("records", []):
        if str(r.get("owner")) != str(chat_id): continue
        ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        if date_local_str(ts) == day_date:
            recs.append((ts, r))
    recs.sort(key=lambda x: x[0])
    return recs

def build_day_window(chat_id: int, day_date: str) -> str:
    recs = get_day_records_for_chat(chat_id, day_date)
    if not recs:
        return "üìò –ó–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –µ—â—ë –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π."
    lines, day_income, day_expense = [f"üìÖ {day_date}\n"], 0, 0
    for ts, r in recs:
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        sid = r.get("short_id") or make_short_id(r.get("id"))
        note = r.get("note", "")
        lines.append(f"üïì {time_local_str(ts)} | {sid} | {sign}{fmt_amount(amt)} {note}".rstrip())
        if amt > 0: day_income += amt
        else: day_expense += abs(amt)
    overall = data.get("overall_balance", 0)
    lines += ["", f"üìà –ü—Ä–∏—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_income)}", f"üìâ –†–∞—Å—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_expense)}", f"üíµ –û–±—â–∏–π –æ—Å—Ç–∞—Ç–æ–∫: {fmt_amount(overall)}"]
    return "\n".join(lines)

def kb_day_main():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_menu"))
    return kb

# -------------------------------
# –û—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
# -------------------------------
@bot.message_handler(content_types=["text"])
def handle_any_message(message):
    chat_id, text = message.chat.id, message.text.strip()
@bot.message_handler(content_types=["text"])
def handle_any_message(message):
    chat_id = message.chat.id
    text = (message.text or "").strip()

    # --- –ü–ê–¢–ß: –ø—Ä–æ–ø—É—Å–∫ –∫–æ–º–∞–Ω–¥, —á—Ç–æ–±—ã –æ–Ω–∏ –Ω–µ —Å—á–∏—Ç–∞–ª–∏—Å—å —Ä–∞—Å—Ö–æ–¥–∞–º–∏/–¥–æ—Ö–æ–¥–∞–º–∏ ---
    entities = getattr(message, "entities", None) or getattr(message, "caption_entities", None)
    if entities:
        for ent in entities:
            if getattr(ent, "type", "") == "bot_command":
                # –≠—Ç–æ –∫–æ–º–∞–Ω–¥–∞ (/addforward, /–±–∞–ª–∞–Ω—Å, /–æ—Ç—á–µ—Ç –∏ —Ç.–ø.)
                return
    if text.startswith("/"):
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ ‚Äî –µ—Å–ª–∏ Telegram –Ω–µ –ø—Ä–∏—Å–ª–∞–ª entity
        return
    # ------------------------------------------------------------------------

    # --- –¥–∞–ª—å—à–µ –æ—Å—Ç–∞—ë—Ç—Å—è —Ç–≤–æ—è –ª–æ–≥–∏–∫–∞ ---
    m_amount, m_sign, m_raw = parse_first_number(text)
    if not m_amount:
        return
   

    pend = data.get("pending_edit", {}).get(str(chat_id))
    if pend:
        amount, sign, raw_num = parse_first_number(text)
        if not amount or sign is None:
            return send_and_record(chat_id, "‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: +1000 –±–µ–Ω–∑–∏–Ω")
        for r in data["records"]:
            if r["short_id"] == pend and str(r["owner"]) == str(chat_id):
                data["overall_balance"] -= r["amount"]
                r["amount"] = apply_sign_and_normalize(amount, sign)
                r["note"] = text.replace(raw_num, "").strip()
                data["overall_balance"] += r["amount"]
                save_data(data)
                send_and_record(chat_id, f"‚úÖ –ó–∞–ø–∏—Å—å {pend} –æ–±–Ω–æ–≤–ª–µ–Ω–∞.")
                data["pending_edit"].pop(str(chat_id), None)
                today = date_local_str(datetime.now(TZ))
                summary = build_day_window(chat_id, today)
                msg_info = data.get("active_messages", {}).get(today)
                if msg_info:
                    try: bot.edit_message_text(summary, chat_id=chat_id, message_id=msg_info["message_id"], reply_markup=kb_day_main())
                    except Exception: send_and_record(chat_id, summary, reply_markup=kb_day_main())
                return
        return send_and_record(chat_id, "–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")

    amount, sign, raw_num = parse_first_number(text)
    if not amount or sign is None:
        return send_and_record(chat_id, "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—É–º–º—É. –§–æ—Ä–º–∞—Ç: `+1000 —Ö–ª–µ–±` –∏–ª–∏ `-500 –±–µ–Ω–∑–∏–Ω`.", parse_mode="Markdown")

    amount_signed = apply_sign_and_normalize(amount, sign)
    rec_id = data["next_id"]; data["next_id"] += 1
    rec = {"id": rec_id, "short_id": make_short_id(rec_id), "timestamp": now_iso_utc(), "amount": amount_signed, "note": text.replace(raw_num, "").strip(), "owner": chat_id}
    data["records"].append(rec)
    data["overall_balance"] += amount_signed
    save_data(data)

    for t in data.get("forward_targets", {}).get(str(chat_id), []):
        try: bot.forward_message(int(t), chat_id, message.message_id)
        except Exception as e:
            print(f"[forward] –û—à–∏–±–∫–∞ {t}: {e}")
            try: bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –≤ {t}: {e}")
            except Exception: pass

    today = date_local_str(datetime.now(TZ))
    summary = build_day_window(chat_id, today)
    msg_info = data.get("active_messages", {}).get(today)
    if msg_info and str(msg_info.get("chat_id")) == str(chat_id):
        try: bot.edit_message_text(summary, chat_id=chat_id, message_id=msg_info["message_id"], reply_markup=kb_day_main())
        except Exception:
            sent = send_and_record(chat_id, summary, reply_markup=kb_day_main())
            if sent: data["active_messages"][today] = {"chat_id": chat_id, "message_id": sent.message_id}
    else:
        sent = send_and_record(chat_id, summary, reply_markup=kb_day_main())
        if sent: data["active_messages"][today] = {"chat_id": chat_id, "message_id": sent.message_id}
    save_data(data)

# -------------------------------
# Inline callbacks
# -------------------------------
@bot.callback_query_handler(func=lambda c: c.data == "edit_menu")
def cb_edit_menu(call):
    chat_id = call.message.chat.id
    today = date_local_str(datetime.now(TZ))
    recs = get_day_records_for_chat(chat_id, today)
    if not recs:
        return bot.answer_callback_query(call.id, "–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –∑–∞ —Å–µ–≥–æ–¥–Ω—è.")
    kb = types.InlineKeyboardMarkup()
    for _, r in recs:
        kb.add(types.InlineKeyboardButton(f"{r['short_id']} | {r.get('note','')}", callback_data=f"edit:{r['short_id']}"))
    kb.add(types.InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_edit"))
    bot.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–ø–∏—Å—å:", chat_id, call.message.id, reply_markup=kb)

@bot.callback_query_handler(func=lambda c: c.data.startswith("edit:"))
def cb_edit_record(call):
    short_id = call.data.split(":",1)[1]
    chat_id = call.message.chat.id
    for r in data["records"]:
        if r["short_id"] == short_id and str(r["owner"]) == str(chat_id):
            amt = r["amount"]; note = r.get("note","")
            sign = "+" if amt>0 else "-"
            bot.edit_message_text(f"–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º {short_id}:\n–¢–µ–∫—É—â–µ–µ: {sign}{fmt_amount(abs(amt))} {note}\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:", chat_id, call.message.id)
            data.setdefault("pending_edit", {})[str(chat_id)] = short_id; save_data(data)
            return
    bot.answer_callback_query(call.id, "–ù–µ –Ω–∞–π–¥–µ–Ω–æ.")

@bot.callback_query_handler(func=lambda c: c.data=="cancel_edit")
def cb_cancel_edit(call):
    data.get("pending_edit", {}).pop(str(call.message.chat.id), None)
    bot.edit_message_text("–û—Ç–º–µ–Ω–µ–Ω–æ.", call.message.chat.id, call.message.id)

# -------------------------------
# –ö–æ–º–∞–Ω–¥—ã –ø–µ—Ä–µ—Å—ã–ª–∫–∏
# -------------------------------
@bot.message_handler(commands=["addforward"])
def addforward_cmd(m):
    args = m.text.split()
    if len(args)<2: return send_and_record(m.chat.id,"–§–æ—Ä–º–∞—Ç: /addforward <chat_id>")
    t=args[1]; data.setdefault("forward_targets",{}).setdefault(str(m.chat.id),[])
    if t not in data["forward_targets"][str(m.chat.id)]:
        data["forward_targets"][str(m.chat.id)].append(t); save_data(data)
        send_and_record(m.chat.id,f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω {t}")
    else: send_and_record(m.chat.id,"–£–∂–µ –µ—Å—Ç—å.")

@bot.message_handler(commands=["removeforward"])
def removeforward_cmd(m):
    args=m.text.split(); 
    if len(args)<2: return send_and_record(m.chat.id,"–§–æ—Ä–º–∞—Ç: /removeforward <chat_id>")
    t=args[1]; targets=data.get("forward_targets",{}).get(str(m.chat.id),[])
    if t in targets: targets.remove(t); save_data(data); send_and_record(m.chat.id,f"üóë –£–¥–∞–ª—ë–Ω {t}")
    else: send_and_record(m.chat.id,"–ù–µ—Ç –≤ —Å–ø–∏—Å–∫–µ.")

@bot.message_handler(commands=["listforwards"])
def listforwards_cmd(m):
    targets=data.get("forward_targets",{}).get(str(m.chat.id),[])
    if not targets: send_and_record(m.chat.id,"–ù–µ—Ç —Ü–µ–ª–µ–π –ø–µ—Ä–µ—Å—ã–ª–∫–∏.")
    else: send_and_record(m.chat.id,"üì§ –¶–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏:\n"+"\n".join(targets))

@bot.message_handler(commands=["clearforwards"])
def clearforwards_cmd(m):
    data.get("forward_targets",{})[str(m.chat.id)]=[]; save_data(data)
    send_and_record(m.chat.id,"‚ôªÔ∏è –°–ø–∏—Å–æ–∫ –æ—á–∏—â–µ–Ω.")

# -------------------------------
# –ö–æ–º–∞–Ω–¥—ã: /–±–∞–ª–∞–Ω—Å /–æ—Ç—á–µ—Ç /—Å–±—Ä–æ—Å
# -------------------------------
@bot.message_handler(commands=["–±–∞–ª–∞–Ω—Å"])
def cmd_balance(m):
    send_and_record(m.chat.id,f"üí∞ –ë–∞–ª–∞–Ω—Å: {fmt_amount(data.get('overall_balance',0))}")

@bot.message_handler(commands=["–æ—Ç—á–µ—Ç"])
def cmd_report(m):
    recs=data.get("records",[])
    if not recs: return send_and_record(m.chat.id,"–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö.")
    with open(CSV_FILE,"w",newline="",encoding="utf-8") as f:
        w=csv.writer(f); w.writerow(["id","short_id","timestamp","amount","note","owner"])
        for r in recs: w.writerow([r["id"],r["short_id"],r["timestamp"],r["amount"],r.get("note",""),r["owner"]])
    send_file_and_record(m.chat.id,CSV_FILE,"üìä –û—Ç—á—ë—Ç CSV")

@bot.message_handler(commands=["—Å–±—Ä–æ—Å"])
def cmd_reset(m):
    if str(m.chat.id)!=str(OWNER_ID): return send_and_record(m.chat.id,"–¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü.")
    save_data(default_data()); send_and_record(m.chat.id,"üîÑ –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã.")

# -------------------------------
# Flask webhook endpoints
# -------------------------------
@app.route("/",methods=["GET"])
def index(): return f"–§–û v{VERSION} –∞–∫—Ç–∏–≤–µ–Ω."

@app.route(WEBHOOK_PATH,methods=["POST"])
def webhook():
    if request.headers.get("content-type")=="application/json":
        upd=telebot.types.Update.de_json(request.get_data(as_text=True))
        bot.process_new_updates([upd]); return "OK",200
    return "Unsupported Media Type",415

# -------------------------------
# –ó–∞–ø—É—Å–∫
# -------------------------------
def set_webhook():
    bot.remove_webhook(); time.sleep(1)
    url=os.getenv("RENDER_EXTERNAL_URL")
    if url:
        full=url.rstrip("/")+WEBHOOK_PATH
        bot.set_webhook(url=full)
        print(f"[Webhook] –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {full}")
    else: print("[Webhook] ‚ö†Ô∏è –ù–µ—Ç RENDER_EXTERNAL_URL")

if __name__=="__main__":
    print(f"üöÄ –§–û v{VERSION} –∑–∞–ø—É—â–µ–Ω.")
    set_webhook()
    app.run(host="0.0.0.0", port=PORT)

# -------------------------------
# –°—Ç—Ä–æ–∫ –∫–æ–¥–∞: 520
# -------------------------------