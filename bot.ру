# -------------------------------
# Финансовый бот "ФО" — версия 9.8.1
# Полная расширенная версия — per-chat accounting + pm-owner media forwarding
# Требует: BOT_TOKEN, OWNER_ID
# requirements.txt: pyTelegramBotAPI==4.23.0, flask
# -------------------------------

import os
import json
import time
import threading
import re
import csv
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Any, Dict, List, Optional, Tuple

from flask import Flask, request
import telebot
from telebot import types

# -------------------------------
VERSION = "9.8.1"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/" + TOKEN) if TOKEN else "/webhook"

if not TOKEN:
    raise ValueError("Ошибка: BOT_TOKEN не установлен в переменных окружения.")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------------
# Data model
# Now data contains per-chat accounting under data["chats"]
# and global metadata. forward_targets keyed by OWNER_ID (string) map to list of targets.
# -------------------------------
def default_data() -> Dict[str, Any]:
    return {
        "version_base": "9.6.1",
        "version_current": VERSION,
        "global_balance": 0,
        "chats": {},  # "<chat_id>": { "balance": 0, "records": [ {id, short_id, timestamp, amount, note, user} ] , "next_id":1 }
        "active_messages": {},  # per day active messages for updating windows
        "sent_messages": [],
        "forward_targets": {},  # keyed by owner chat id string -> list of targets
    }

def load_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            print(f"[load_data] Ошибка чтения {DATA_FILE}: {e}")
            d = default_data()
    else:
        d = default_data()
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d: Dict[str, Any]) -> None:
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[save_data] Ошибка сохранения {DATA_FILE}: {e}")

data = load_data()

# -------------------------------
# Utilities: parsing, formatting
# -------------------------------
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text: str) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    if s.startswith('+'):
        sign = '+'
        digits = s[1:].strip()
    elif s.startswith('-'):
        sign = '-'
        digits = s[1:].strip()
    else:
        sign = ''
        digits = s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    dm = re.match(r'(\d+)', digits_norm)
    if not dm:
        return None, None, None
    return int(dm.group(1)), sign, raw

def apply_sign_and_normalize(num: int, sign: Optional[str]) -> int:
    return num if sign == '+' else -num

def fmt_amount(n: int) -> str:
    return f"{abs(n):,}".replace(",", ".")

def now_iso_utc() -> str:
    return datetime.now(tz=ZoneInfo("UTC")).isoformat()

def now_local_iso() -> str:
    return datetime.now(tz=TZ).isoformat()

def make_record_short_id(chat_info: Dict[str, Any], local_id: int) -> str:
    return f"{chat_info.get('prefix','C')}{local_id}"

# -------------------------------
# Per-chat accounting helpers
# -------------------------------
def ensure_chat_struct(chat_id: str) -> Dict[str, Any]:
    data.setdefault("chats", {})
    if chat_id not in data["chats"]:
        data["chats"][chat_id] = {"balance": 0, "records": [], "next_id": 1, "prefix": "C"}
        save_data(data)
    return data["chats"][chat_id]

def add_record_to_chat(chat_id: str, amount: int, note: str, user: str) -> Dict[str, Any]:
    ch = ensure_chat_struct(chat_id)
    rid = ch.get("next_id",1)
    short = make_record_short_id(ch, rid)
    rec = {
        "id": rid,
        "short_id": short,
        "timestamp": now_iso_utc(),
        "amount": amount,
        "note": note,
        "user": user
    }
    ch.setdefault("records", []).append(rec)
    ch["next_id"] = rid + 1
    ch["balance"] = ch.get("balance",0) + amount
    # update global balance optionally
    data["global_balance"] = sum([c.get("balance",0) for c in data.get("chats", {}).values()])
    save_data(data)
    return rec

def delete_record_from_chat(chat_id: str, short_id: str) -> bool:
    ch = data.get("chats", {}).get(chat_id)
    if not ch:
        return False
    for r in ch.get("records", []):
        if r.get("short_id") == short_id:
            ch["records"] = [x for x in ch["records"] if x.get("short_id") != short_id]
            ch["balance"] = ch.get("balance",0) - r.get("amount",0)
            data["global_balance"] = sum([c.get("balance",0) for c in data.get("chats", {}).values()])
            save_data(data)
            return True
    return False

def modify_record_in_chat(chat_id: str, short_id: str, new_amount: int, new_note: str) -> bool:
    ch = data.get("chats", {}).get(chat_id)
    if not ch:
        return False
    for i, r in enumerate(ch.get("records", [])):
        if r.get("short_id") == short_id:
            old = r.get("amount",0)
            ch["records"][i]["amount"] = new_amount
            ch["records"][i]["note"] = new_note
            ch["balance"] = ch.get("balance",0) - old + new_amount
            data["global_balance"] = sum([c.get("balance",0) for c in data.get("chats", {}).values()])
            save_data(data)
            return True
    return False

def export_chat_to_csv(chat_id: str, path: str = CSV_FILE) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records":[]})
    rows=[]
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"])
            date_s = ts.astimezone(TZ).strftime("%Y-%m-%d")
            time_s = ts.astimezone(TZ).strftime("%H:%M:%S")
        except Exception:
            date_s = r["timestamp"]
            time_s = ""
        rows.append([r.get("short_id"), date_s, time_s, r.get("amount"), r.get("note"), r.get("user")])
    try:
        with open(path, "w", newline="", encoding="utf-8-sig") as f:
            writer = csv.writer(f)
            writer.writerow(["ID","Дата","Время","Сумма","Комментарий","Пользователь"])
            for row in rows:
                writer.writerow(row)
        return path
    except Exception as e:
        print(f"[export_chat_to_csv] Ошибка: {e}")
        raise

# -------------------------------
# Forward targets helpers (owner-targets)
# -------------------------------
def ensure_forward_list_for(owner_chat_id: str) -> List[str]:
    data.setdefault("forward_targets", {})
    lst = data["forward_targets"].get(owner_chat_id)
    if lst is None:
        data["forward_targets"][owner_chat_id] = []
        save_data(data)
        return data["forward_targets"][owner_chat_id]
    if isinstance(lst, list):
        return lst
    data["forward_targets"][owner_chat_id] = [str(lst)]
    save_data(data)
    return data["forward_targets"][owner_chat_id]

def add_forward_target(owner_chat_id: str, target: str) -> bool:
    lst = ensure_forward_list_for(owner_chat_id)
    t = str(target).strip()
    if t in lst:
        return False
    lst.append(t)
    data["forward_targets"][owner_chat_id] = lst
    save_data(data)
    return True

def remove_forward_target(owner_chat_id: str, target: str) -> bool:
    lst = ensure_forward_list_for(owner_chat_id)
    t = str(target).strip()
    if t in lst:
        lst = [x for x in lst if x != t]
        data["forward_targets"][owner_chat_id] = lst
        save_data(data)
        return True
    return False

def list_forward_targets(owner_chat_id: str) -> List[str]:
    return ensure_forward_list_for(owner_chat_id)

def validate_and_test_target(target_raw: str) -> Tuple[bool, str, str]:
    t_raw = str(target_raw).strip()
    if t_raw.startswith("@"):
        normalized = t_raw
    else:
        try:
            normalized = int(t_raw)
        except Exception:
            normalized = t_raw if t_raw.startswith("@") else "@" + t_raw
    try:
        bot.send_message(normalized, "🔁 Тест от бота: проверка доступа для пересылки.")
        return True, "Тестовое сообщение доставлено.", str(normalized)
    except Exception as e:
        return False, f"Не удалось отправить тест: {e}", str(normalized)

# -------------------------------
# Sending helpers (file_id based to avoid reupload)
# -------------------------------
def record_sent(entry: Dict[str, Any]) -> None:
    data.setdefault("sent_messages", []).append(entry)
    save_data(data)

def send_text(target, text: str, purpose: str="pm_forward_text"):
    try:
        sent = bot.send_message(int(target), text)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "message_id": getattr(sent,"message_id",None), "purpose": purpose, "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose": purpose, "ok": False, "error": str(e)})
        return None

def send_photo_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_photo(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "message_id": getattr(sent,"message_id",None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "ok": False, "error": str(e)})
        return None

def send_document_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_document(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "message_id": getattr(sent,"message_id",None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "ok": False, "error": str(e)})
        return None

def send_sticker_by_file_id(target, file_id):
    try:
        sent = bot.send_sticker(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "message_id": getattr(sent,"message_id",None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "ok": False, "error": str(e)})
        return None

def send_voice_by_file_id(target, file_id):
    try:
        sent = bot.send_voice(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "message_id": getattr(sent,"message_id",None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "ok": False, "error": str(e)})
        return None

def send_video_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_video(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "message_id": getattr(sent,"message_id",None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "ok": False, "error": str(e)})
        return None

def send_location(target, latitude, longitude):
    try:
        sent = bot.send_location(int(target), latitude, longitude)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "message_id": getattr(sent,"message_id",None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "ok": False, "error": str(e)})
        return None

def send_contact(target, phone_number, first_name, last_name=None):
    try:
        sent = bot.send_contact(int(target), phone_number, first_name, last_name)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "message_id": getattr(sent,"message_id",None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "ok": False, "error": str(e)})
        return None

# -------------------------------
# PM-owner forwarding: forward owner's private messages to configured targets
# -------------------------------
def pm_owner_forward_block(message: types.Message) -> bool:
    """
    If PRIVATE and from OWNER_ID -> send message content (text/media) to owner's targets.
    Returns True if handled (and no further processing should occur), False otherwise.
    """
    try:
        if getattr(message.chat, "type", "") != "private":
            return False
        if str(message.from_user.id) != str(OWNER_ID):
            return False

        owner_key = str(OWNER_ID)
        targets = data.get("forward_targets", {}).get(owner_key, []) or []
        if not targets:
            return False

        # TEXT
        if message.content_type == 'text':
            text = (message.text or "").strip()
            if not text:
                return True
            for tgt in targets:
                send_text(tgt, text)
            return True

        # PHOTO
        if message.content_type == 'photo' and getattr(message, "photo", None):
            file_id = message.photo[-1].file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_photo_by_file_id(tgt, file_id, caption=caption)
            return True

        # DOCUMENT
        if message.content_type == 'document' and getattr(message, "document", None):
            file_id = message.document.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_document_by_file_id(tgt, file_id, caption=caption)
            return True

        # AUDIO
        if message.content_type == 'audio' and getattr(message, "audio", None):
            file_id = message.audio.file_id
            for tgt in targets:
                try:
                    bot.send_audio(int(tgt), file_id)
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": True})
                except Exception as e:
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": False, "error": str(e)})
            return True

        # VOICE
        if message.content_type == 'voice' and getattr(message, "voice", None):
            file_id = message.voice.file_id
            for tgt in targets:
                send_voice_by_file_id(tgt, file_id)
            return True

        # STICKER
        if message.content_type == 'sticker' and getattr(message, "sticker", None):
            file_id = message.sticker.file_id
            for tgt in targets:
                send_sticker_by_file_id(tgt, file_id)
            return True

        # VIDEO
        if message.content_type == 'video' and getattr(message, "video", None):
            file_id = message.video.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_video_by_file_id(tgt, file_id, caption=caption)
            return True

        # LOCATION
        if message.content_type == 'location' and getattr(message, "location", None):
            lat = message.location.latitude
            lon = message.location.longitude
            for tgt in targets:
                send_location(tgt, lat, lon)
            return True

        # CONTACT
        if message.content_type == 'contact' and getattr(message, "contact", None):
            phone = message.contact.phone_number
            first = message.contact.first_name
            last = getattr(message.contact, "last_name", None)
            for tgt in targets:
                send_contact(tgt, phone, first, last)
            return True

        # fallback: try forward (if sending as new fails)
        for tgt in targets:
            try:
                try:
                    bot.forward_message(int(tgt), message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
                except Exception:
                    bot.forward_message(tgt, message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
            except Exception as e:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": False, "error": str(e)})
        return True

    except Exception as e:
        print(f"[pm_owner_forward_block] Ошибка: {e}")
        try:
            bot.send_message(int(OWNER_ID), f"⚠️ Ошибка блока пересылки личных сообщений: {e}")
        except Exception:
            pass
        return False

# -------------------------------
# Auto-forward for chats (forward message as forward)
# -------------------------------
def auto_forward_message_from(chat_id: str, message: types.Message) -> None:
    targets = data.get("forward_targets", {}).get(str(chat_id)) or []
    if not targets:
        return
    for t in targets:
        try:
            try:
                bot.forward_message(int(t), int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
            except Exception:
                bot.forward_message(t, int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
        except Exception as e:
            # fallback: send text copy if text
            try:
                if message.content_type == 'text' and getattr(message, "text", None):
                    bot.send_message(t, f"📨 Копия сообщения из {chat_id}:\n\n{message.text}")
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"sent_copy"})
                else:
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e)})
            except Exception as e2:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e2)})

# -------------------------------
# Active day window and keyboards (simplified but functional)
# -------------------------------
def build_day_window_for_chat(chat_id: str, day_date: str) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records":[]})
    recs = []
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        except Exception:
            ts = datetime.fromisoformat(r["timestamp"])
            ts = ts.astimezone(TZ)
        if ts.strftime("%Y-%m-%d") == day_date:
            recs.append((ts, r))
    recs.sort(key=lambda x: x[0])
    if not recs:
        return "📘 За этот день ещё нет записей."
    lines = [f"📅 {day_date}\n"]
    day_income = 0
    day_expense = 0
    last_hour = None
    for ts, r in recs:
        hour = ts.strftime("%H")
        if last_hour and hour != last_hour:
            lines.append("")
        last_hour = hour
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        sid = r.get("short_id")
        note = r.get("note","")
        t_local = ts.strftime("%H:%M")
        lines.append(f"🕓 {t_local} | {sid} | {sign}{fmt_amount(amt)} {note}".rstrip())
        if amt>0:
            day_income += amt
        else:
            day_expense += abs(amt)
    overall = data.get("chats", {}).get(chat_id, {}).get("balance",0)
    lines.append("")
    lines.append(f"📈 Приход дня: {fmt_amount(day_income)}")
    lines.append(f"📉 Расход дня: {fmt_amount(day_expense)}")
    lines.append(f"💵 Баланс чата: {fmt_amount(overall)}")
    return "\n".join(lines)

def kb_day_main():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("Редактировать", callback_data="edit_menu"))
    return kb

# -------------------------------
# Pending actions state
pending_actions: Dict[str, Dict[str, Any]] = {}

# -------------------------------
# Message handler (core)
# -------------------------------
@bot.message_handler(func=lambda m: True, content_types=['text','photo','document','audio','video','voice','sticker','animation','contact','location'])
def handle_any_message(message: types.Message):
    global data
    chat_id = message.chat.id
    data = load_data()

    # 0) PM-owner forwarding: if PRIVATE and from OWNER -> send copies to owner's targets and stop
    handled = pm_owner_forward_block(message)
    if handled:
        return

    # 1) pending actions
    pa = pending_actions.get(str(chat_id))
    if pa:
        t = pa.get("type")
        if t == "await_forward_setup":
            target = None
            if getattr(message, "forward_from_chat", None):
                try:
                    target = str(message.forward_from_chat.id)
                except Exception:
                    target = None
            elif getattr(message, "forward_from", None):
                try:
                    target = str(message.forward_from.id)
                except Exception:
                    target = None
            elif message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() == "отмена":
                    send_text(chat_id, "Отменено",)
                    pending_actions.pop(str(chat_id), None)
                    return
                target = txt
            if not target:
                send_text(chat_id, "❌ Неверный идентификатор. Отмена.")
                pending_actions.pop(str(chat_id), None)
                return
            ok, msg_text, norm = validate_and_test_target(target)
            if ok:
                added = add_forward_target(str(chat_id), norm)
                if added:
                    send_text(chat_id, f"✅ Пересылка добавлена: {norm}")
                else:
                    send_text(chat_id, f"ℹ️ Цель уже в списке: {norm}")
            else:
                send_text(chat_id, f"❌ {msg_text}")
            pending_actions.pop(str(chat_id), None)
            return

        if t == "await_remove_forward":
            if message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() in ('всё','все','all'):
                    data["forward_targets"].pop(str(chat_id), None)
                    save_data(data)
                    send_text(chat_id, "✅ Все цели пересылки удалены.")
                else:
                    removed = remove_forward_target(str(chat_id), txt)
                    if removed:
                        send_text(chat_id, f"✅ Цель {txt} удалена.")
                    else:
                        send_text(chat_id, f"❗ Цель {txt} не найдена.")
            else:
                send_text(chat_id, "❌ Неверный ввод, отменено.")
            pending_actions.pop(str(chat_id), None)
            return

    # 2) Auto-forward from group/chat if configured (for readers who set per-chat forward)
    try:
        auto_forward_message_from(str(chat_id), message)
    except Exception as e:
        print(f"[auto_forward] Ошибка: {e}")

    # 3) Accounting: react to messages of all participants in groups + private (per-chat accounting)
    # If message is text and starts with + or -, treat as transaction
    if message.content_type == 'text':
        text = (message.text or "").strip()
        lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
        any_added = False
        for line in lines:
            num, sign, raw = parse_first_number(line)
            if num is None:
                continue
            amt_signed = apply_sign_and_normalize(num, sign)
            note = line[(line.find(raw)+len(raw)):].strip() if raw in line else ""
            user_display = (message.from_user.username or message.from_user.first_name or str(message.from_user.id))
            rec = add_record_to_chat(str(chat_id), amt_signed, note, user_display)
            any_added = True
        if any_added:
            # update day window for this chat
            today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            text_window = build_day_window_for_chat(str(chat_id), today)
            try:
                # try edit existing active message
                prev = data.get("active_messages", {}).get(today, {})
                if prev and int(prev.get("chat_id")) == int(chat_id):
                    try:
                        bot.edit_message_text(chat_id=int(chat_id), message_id=int(prev.get("message_id")), text=text_window, reply_markup=kb_day_main())
                    except Exception:
                        sent = bot.send_message(int(chat_id), text_window, reply_markup=kb_day_main())
                        data.setdefault("active_messages", {})[today] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
                        record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(sent.message_id), "purpose":"day_window"})
                        save_data(data)
                else:
                    sent = bot.send_message(int(chat_id), text_window, reply_markup=kb_day_main())
                    data.setdefault("active_messages", {})[today] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
                    record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(sent.message_id), "purpose":"day_window"})
                    save_data(data)
            except Exception as e:
                print(f"[day_window send] {e}")
        return

    # for media and other types we do not add transactions by default, but can update window if needed
    # end of handler

# -------------------------------
# Callback handler (simplified)
# -------------------------------
@bot.callback_query_handler(func=lambda call: True)
def callback_worker(call: types.CallbackQuery):
    data_local = load_data()
    data_call = call.data or ""
    chat_id = call.message.chat.id
    call_msg = call.message
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    try:
        bot.answer_callback_query(call.id)
    except Exception:
        pass

    if data_call == "edit_menu":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_day_main())
        except Exception:
            send_text(chat_id, "Меню редактирования недоступно.")
        return

# -------------------------------
# Commands for forward management (owner-only)
# -------------------------------
@bot.message_handler(commands=['addforward'])
def cmd_addforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "⛔ Только владелец может управлять пересылкой.")
        return
    send_text(message.chat.id, "Перешлите мне сообщение из целевого чата/канала или отправьте chat_id/@username.")
    pending_actions[str(message.chat.id)] = {"type":"await_forward_setup","payload":{}}

@bot.message_handler(commands=['removeforward'])
def cmd_removeforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "⛔ Только владелец может управлять пересылкой.")
        return
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "Список пересылки пуст.")
        return
    send_text(message.chat.id, "Список целей:\n" + "\n".join(lst) + "\nОтправь цель для удаления или 'всё' для очистки.")
    pending_actions[str(message.chat.id)] = {"type":"await_remove_forward","payload":{}}

@bot.message_handler(commands=['listforwards'])
def cmd_listforwards(message: types.Message):
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "Пересылка не настроена.")
    else:
        send_text(message.chat.id, "Текущие цели:\n" + "\n".join(lst))

# -------------------------------
# Commands: per-chat balance/report/reset
# -------------------------------
@bot.message_handler(commands=["баланс"])
def cmd_balance(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"balance":0})
    bot.reply_to(message, f"💰 Баланс этого чата: {fmt_amount(ch.get('balance',0))}")

@bot.message_handler(commands=["отчет"])
def cmd_report(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"records":[]})
    if not ch.get("records"):
        bot.reply_to(message, "Пока нет записей в этом чате.")
        return
    try:
        path = export_chat_to_csv(chat_id, CSV_FILE)
        bot.send_document(message.chat.id, open(path, "rb"))
    except Exception as e:
        bot.reply_to(message, f"Ошибка при экспорте: {e}")

@bot.message_handler(commands=["сброс"])
def cmd_reset(message: types.Message):
    # Only owner can global reset; chat reset allowed by owner or admin? We'll restrict to owner to be safe
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "⛔ Только владелец может обнулить данные.")
        return
    data.update(default_data())
    save_data(data)
    bot.reply_to(message, "♻️ Все данные обнулены (глобально).")

# -------------------------------
# Webhook endpoints
# -------------------------------
@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    try:
        json_str = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
    except Exception as e:
        print(f"[webhook] Ошибка обработки update: {e}")
    return '', 200

@app.route("/", methods=['GET'])
def index():
    return f"🤖 Бот 'ФО' v{VERSION} работает."

# -------------------------------
# Startup: set webhook if Render host present
# -------------------------------
def set_webhook_if_possible():
    try:
        host = os.getenv("RENDER_EXTERNAL_HOSTNAME")
        if host:
            url = f"https://{host}{WEBHOOK_PATH}"
            bot.remove_webhook()
            time.sleep(0.3)
            bot.set_webhook(url=url)
            print(f"[startup] Webhook установлен: {url}")
            if OWNER_ID:
                try:
                    msg = bot.send_message(int(OWNER_ID), f"✅ Бот v{VERSION}: webhook активирован.")
                    time.sleep(0.5)
                except Exception as e:
                    print(f"[startup notify] Ошибка: {e}")
    except Exception as e:
        print(f"[set_webhook_if_possible] {e}")

# -------------------------------
# Run
# -------------------------------
if __name__ == "__main__":
    print(f"Запуск бота 'ФО' v{VERSION} ...")
    save_data(data)
    set_webhook_if_possible()
    try:
        bot.send_message(int(OWNER_ID), f"✅ Бот v{VERSION} запущен и готов.")
    except Exception:
        pass
    app.run(host="0.0.0.0", port=PORT)

# -------------------------------
# lines: 1018
# -------------------------------