# -------------------------------
# –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç "–§–û" ‚Äî –≤–µ—Ä—Å–∏—è 9.8.0.2
# –õ—ë–≥–∫–∞—è, –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω–∞—è –∏ —É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è 9.8.x
# Flask webhook ‚Äî –≥–æ—Ç–æ–≤ –∫ Deploy –Ω–∞ Render
# –¢—Ä–µ–±—É–µ—Ç: BOT_TOKEN, OWNER_ID, (–æ–ø—Ü–∏–æ–Ω–Ω–æ RENDER_EXTERNAL_URL)
# requirements.txt: pyTelegramBotAPI==4.23.0, flask
# -------------------------------

import os
import json
import time
import threading
import re
import csv
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Dict, Any, Optional, Tuple, List
from flask import Flask, request
import telebot
from telebot import types

# -------------------------------
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
# -------------------------------
VERSION = "9.8.0.2"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")  # –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω: —Ç–≤–æ–π telegram id
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/" + TOKEN) if TOKEN else "/webhook"

if not TOKEN:
    raise ValueError("BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏.")
if not OWNER_ID:
    print("[warn] OWNER_ID –Ω–µ –∑–∞–¥–∞–Ω ‚Äî —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π –±—É–¥–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------------
# –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è)
# -------------------------------
def default_data() -> Dict[str, Any]:
    return {
        "version_current": VERSION,
        "overall_balance": {},   # per chat_id -> int
        "records": [],           # list of {id, short_id, timestamp, amount, note, owner_chat}
        "next_id": 1,
        "active_messages": {},   # per-day mode: YYYY-MM-DD: {chat_id, message_id} (used when compact_mode False)
        "compact_active": {},    # per-chat single active message when compact_mode True: chat_id -> {message_id}
        "forward_targets": {},   # per chat owner (str(chat_id)) -> [target1, target2]
        "compact_mode": {},      # chat_id -> bool (True = single window always edited)
        "sent_messages": []      # history of bot sends/errors
    }

def load_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            print(f"[load_data] error: {e}")
            d = default_data()
    else:
        d = default_data()
    # ensure keys
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d: Dict[str, Any]) -> None:
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[save_data] {e}")

data = load_data()

# -------------------------------
# –£—Ç–∏–ª–∏—Ç—ã
# -------------------------------
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text: str) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    sign = '+' if s.startswith('+') else ('-' if s.startswith('-') else '')
    digits = s[1:].strip() if sign else s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    dm = re.match(r'(\d+)', digits_norm)
    if not dm:
        return None, None, None
    return int(dm.group(1)), sign, raw

def apply_sign_and_normalize(num: int, sign: Optional[str]) -> int:
    return num if sign == '+' else -num

def fmt_amount(n: int) -> str:
    return f"{abs(n):,}".replace(",", ".")

def make_short_id(n: int) -> str:
    return f"R{n}"

def now_iso_utc() -> str:
    return datetime.now(tz=ZoneInfo("UTC")).isoformat()

def date_local_str_from_iso(iso_ts: str) -> str:
    try:
        dt = datetime.fromisoformat(iso_ts)
        return dt.astimezone(TZ).strftime("%Y-%m-%d")
    except Exception:
        return datetime.now(tz=TZ).strftime("%Y-%m-%d")

def date_today_local() -> str:
    return datetime.now(tz=TZ).strftime("%Y-%m-%d")

# -------------------------------
# –ó–∞–ø–∏—Å—å –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ (–ª–æ–≥)
# -------------------------------
def record_sent_message(entry: Dict[str, Any]) -> None:
    data.setdefault("sent_messages", []).append(entry)
    save_data(data)

def send_and_record(chat_id: int, text: str, reply_markup=None, parse_mode=None, purpose: str="msg"):
    try:
        sent = bot.send_message(int(chat_id), text, reply_markup=reply_markup, parse_mode=parse_mode)
        record_sent_message({"chat_id": str(chat_id), "message_id": int(sent.message_id), "purpose": purpose, "timestamp": now_iso_utc()})
        return sent
    except Exception as e:
        record_sent_message({"chat_id": str(chat_id), "message_id": None, "purpose": purpose, "timestamp": now_iso_utc(), "error": str(e)})
        try:
            if OWNER_ID:
                bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ {chat_id}: {e}")
        except Exception:
            pass
        return None

def send_file_and_record(chat_id: int, path: str, caption: Optional[str]=None, purpose: str="file"):
    try:
        with open(path, "rb") as f:
            sent = bot.send_document(int(chat_id), f, caption=caption)
        record_sent_message({"chat_id": str(chat_id), "message_id": int(sent.message_id), "purpose": purpose, "timestamp": now_iso_utc()})
        return sent
    except Exception as e:
        record_sent_message({"chat_id": str(chat_id), "message_id": None, "purpose": purpose, "timestamp": now_iso_utc(), "error": str(e)})
        return None

# -------------------------------
# –£–¥–∞–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ –≤—Ä–µ–º—è (–Ω–µ –∑–∞—Å–æ—Ä—è—Ç—å —á–∞—Ç)
# -------------------------------
def delayed_delete(chat_id: int, message_id: int, delay: int = 5):
    def worker():
        time.sleep(delay)
        try:
            bot.delete_message(int(chat_id), int(message_id))
        except Exception as e:
            print(f"[delayed_delete] {e}")
    threading.Thread(target=worker, daemon=True).start()

# -------------------------------
# –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –æ–∫–Ω–∞ –¥–Ω—è (—Å –≤–µ—Ä—Å–∏–µ–π —Ä—è–¥–æ–º —Å –¥–∞—Ç–æ–π)
# -------------------------------
def get_day_records_for_chat(chat_id: int, day_date: str):
    recs = []
    for r in data.get("records", []):
        if str(r.get("owner_chat")) != str(chat_id):
            continue
        ts = r.get("timestamp")
        d = date_local_str_from_iso(ts)
        if d == day_date:
            try:
                dt = datetime.fromisoformat(ts).astimezone(TZ)
            except Exception:
                dt = datetime.now(tz=TZ)
            recs.append((dt, r))
    recs.sort(key=lambda x: x[0])
    return recs

def build_day_window(chat_id: int, day_date: str) -> str:
    recs = get_day_records_for_chat(chat_id, day_date)
    header = f"üìÖ {day_date} (v{data.get('version_current','?')})"
    if not recs:
        return f"{header}\n\nüìò –ó–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –µ—â—ë –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π.\n\n‚Äî –ë–æ—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ ‚Äî –≤—ã –Ω–∞—á–∞–ª–∏ –≤–µ—Å—Ç–∏ —É—á—ë—Ç."
    lines = [header, ""]
    day_income, day_expense = 0, 0
    last_hour = None
    for ts, r in recs:
        hour = ts.strftime("%H")
        if last_hour is not None and hour != last_hour:
            lines.append("")
        last_hour = hour
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        sid = r.get("short_id") or make_short_id(r.get("id"))
        note = r.get("note", "")
        lines.append(f"üïì {ts.strftime('%H:%M')} | {sid} | {sign}{fmt_amount(amt)} {note}".rstrip())
        if amt > 0: day_income += amt
        else: day_expense += abs(amt)
    overall = data.get("overall_balance", {}).get(str(chat_id), 0)
    lines += ["", f"üìà –ü—Ä–∏—Ö–æ–¥: {fmt_amount(day_income)}", f"üìâ –†–∞—Å—Ö–æ–¥: {fmt_amount(day_expense)}", f"üíµ –û—Å—Ç–∞—Ç–æ–∫: {fmt_amount(overall)}"]
    return "\n".join(lines)

# -------------------------------
# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã (–∏–Ω–ª–∞–π–Ω) ‚Äî –∫–æ–º–ø–∞–∫—Ç–Ω–æ–µ –º–µ–Ω—é
# -------------------------------
def kb_main(chat_id: int):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_menu"))
    kb.add(types.InlineKeyboardButton("üì§ –ü–µ—Ä–µ—Å—ã–ª–∫–∞", callback_data="forward_menu"))
    # compact toggle label
    cm = data.get("compact_mode", {}).get(str(chat_id), False)
    kb.add(types.InlineKeyboardButton("üîÅ Compact: –í–∫–ª" if cm else "üîÅ Compact: –í—ã–∫–ª",
                                      callback_data="toggle_compact"))
    kb.add(types.InlineKeyboardButton("üìÑ –≠–∫—Å–ø–æ—Ä—Ç CSV", callback_data="export_csv"))
    kb.add(types.InlineKeyboardButton("‚ôªÔ∏è –û–±–Ω—É–ª–∏—Ç—å (–≤–ª–∞–¥–µ–ª–µ—Ü)", callback_data="reset_confirm"))
    return kb

def kb_edit_cancel():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="edit_cancel"))
    return kb

def kb_yes_no(prefix:str):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–î–∞", callback_data=f"{prefix}_yes"),
           types.InlineKeyboardButton("–ù–µ—Ç", callback_data=f"{prefix}_no"))
    return kb

def kb_forward_menu(chat_id:int):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å", callback_data="forward_add"))
    kb.add(types.InlineKeyboardButton("‚ûñ –£–¥–∞–ª–∏—Ç—å", callback_data="forward_remove"))
    kb.add(types.InlineKeyboardButton("‚ÑπÔ∏è –°–ø–∏—Å–æ–∫", callback_data="forward_list"))
    kb.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="edit_cancel"))
    return kb

# -------------------------------
# Forward helpers (only OWNER messages forwarded)
# -------------------------------
def ensure_forward_list_for(chat_id:int):
    key = str(chat_id)
    data.setdefault("forward_targets", {})
    lst = data["forward_targets"].get(key)
    if lst is None:
        data["forward_targets"][key] = []
        save_data(data)
        return data["forward_targets"][key]
    if isinstance(lst, list):
        return lst
    data["forward_targets"][key] = [str(lst)]
    save_data(data)
    return data["forward_targets"][key]

def add_forward_target(chat_id:int, target:str) -> bool:
    lst = ensure_forward_list_for(chat_id)
    t = str(target).strip()
    if t in lst:
        return False
    lst.append(t)
    data["forward_targets"][str(chat_id)] = lst
    save_data(data)
    return True

def remove_forward_target(chat_id:int, target:str) -> bool:
    lst = ensure_forward_list_for(chat_id)
    t = str(target).strip()
    if t in lst:
        lst = [x for x in lst if x != t]
        data["forward_targets"][str(chat_id)] = lst
        save_data(data)
        return True
    return False

def list_forward_targets(chat_id:int) -> List[str]:
    return ensure_forward_list_for(chat_id)

# -------------------------------
# Auto-forwarding: —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞–≤—Ç–æ—Ä —Å–æ–æ–±—â–µ–Ω–∏—è == OWNER_ID –∏ –Ω–µ –±–æ—Ç
# -------------------------------
def auto_forward_if_owner(message: types.Message):
    # Only forward messages authored by OWNER_ID (not the bot itself)
    try:
        if not OWNER_ID:
            return []
        if getattr(message.from_user, "is_bot", False):
            return []
        if str(getattr(message.from_user, "id", "")) != str(OWNER_ID):
            return []
        src_chat = message.chat.id
        targets = data.get("forward_targets", {}).get(str(src_chat), [])  # forwarding rules per chat
        results = []
        for t in targets:
            try:
                tgt = int(t)
                bot.forward_message(tgt, src_chat, message.message_id)
                results.append((t, True))
            except Exception:
                try:
                    bot.forward_message(t, src_chat, message.message_id)
                    results.append((t, True))
                except Exception as e:
                    results.append((t, False))
        # record attempts
        for r in results:
            record_sent_message({"timestamp": now_iso_utc(), "from_chat": str(src_chat), "to": r[0], "ok": r[1]})
        return results
    except Exception as e:
        print(f"[auto_forward_if_owner] {e}")
        return []

# -------------------------------
# Update / create day window with compact mode support
# -------------------------------
def update_day_window_after_change(chat_id:int, day_date:Optional[str]=None, purpose:str="day_window"):
    if day_date is None:
        day_date = date_today_local()
    text = build_day_window(chat_id, day_date)
    kb = kb_main(chat_id)

    # check compact mode for this chat
    cmode = data.get("compact_mode", {}).get(str(chat_id), False)
    sent = None

    if cmode:
        # use single compact active message per chat (compact_active)
        pam = data.get("compact_active", {}).get(str(chat_id))
        if pam:
            try:
                bot.edit_message_text(text, chat_id, pam["message_id"], reply_markup=kb)
                record_sent_message({"chat_id": str(chat_id), "message_id": pam["message_id"], "purpose": purpose + "_edit"})
                save_data(data)
                return pam
            except Exception as e:
                print(f"[update_day_window compact edit fail] {e}")
        # send new (and replace previous compact if needed)
        try:
            sent = bot.send_message(int(chat_id), text, reply_markup=kb)
            data.setdefault("compact_active", {})[str(chat_id)] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
            record_sent_message({"chat_id": str(chat_id), "message_id": int(sent.message_id), "purpose": purpose})
            # remove previous per-day active if existed
            # (we keep chat uncluttered)
            save_data(data)
        except Exception as e:
            print(f"[update_day_window compact send fail] {e}")
            try:
                bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ–∫–Ω–∞ –¥–ª—è {chat_id}: {e}")
            except Exception:
                pass
        return sent

    else:
        # normal per-day behaviour. active_messages keyed by day_date
        prev = data.get("active_messages", {}).get(day_date)
        if prev and int(prev.get("chat_id")) == int(chat_id):
            try:
                bot.edit_message_text(text, chat_id, prev["message_id"], reply_markup=kb)
                record_sent_message({"chat_id": str(chat_id), "message_id": prev["message_id"], "purpose": purpose + "_edit"})
                save_data(data)
                return prev
            except Exception as e:
                print(f"[update_day_window edit fail] {e}")
        try:
            sent = bot.send_message(int(chat_id), text, reply_markup=kb)
            data.setdefault("active_messages", {})[day_date] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
            record_sent_message({"chat_id": str(chat_id), "message_id": int(sent.message_id), "purpose": purpose})
            save_data(data)
        except Exception as e:
            print(f"[update_day_window send fail] {e}")
            try: bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ–∫–Ω–∞ –¥–ª—è {chat_id}: {e}")
            except Exception: pass
        # cleanup: delete older same-day windows not matching current to avoid clutter
        # (we keep only the newly sent; previous handled by edit or removed)
        return sent

# -------------------------------
# Message handlers
# -------------------------------
# Filter commands out of generic handler (patch)
def message_is_command(message: types.Message) -> bool:
    entities = getattr(message, "entities", None) or getattr(message, "caption_entities", None)
    if entities:
        for e in entities:
            if getattr(e, "type", "") == "bot_command":
                return True
    txt = (getattr(message, "text", "") or "").strip()
    if txt.startswith("/"):
        return True
    return False

@bot.message_handler(func=lambda m: True, content_types=['text','photo','document','audio','video','voice','sticker','animation','contact','location'])
def handle_any_message(message: types.Message):
    global data
    data = load_data()  # refresh

    chat_id = message.chat.id

    # don't forward bot's own messages
    if getattr(message.from_user, "is_bot", False):
        return

    # if command - let command handlers process it
    if message_is_command(message):
        # do not process as transaction
        # but still allow auto-forward if it's an owner command? We skip forwarding commands.
        return

    # auto-forward only if author is OWNER_ID (and owner set)
    try:
        auto_forward_if_owner(message)
    except Exception as e:
        print(f"[auto_forward err] {e}")

    # parse transaction only for text messages
    if message.content_type != 'text':
        # update window only (media)
        update_day_window_after_change(chat_id, date_today_local(), purpose="media_received")
        return

    text = (message.text or "").strip()
    if not text:
        update_day_window_after_change(chat_id, date_today_local(), purpose="empty_text")
        return

    # Try parse number(s) from text ‚Äî supports multi-line
    lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
    added = False
    for ln in lines:
        num, sign, raw = parse_first_number(ln)
        if num is None:
            continue
        amt = apply_sign_and_normalize(num, sign)
        note = ln[(ln.find(raw) + len(raw)):].strip() if raw in ln else ""
        rec_id = data.get("next_id", 1)
        short = make_short_id(rec_id)
        rec = {
            "id": rec_id,
            "short_id": short,
            "timestamp": now_iso_utc(),
            "amount": amt,
            "note": note,
            "owner_chat": str(chat_id)
        }
        data.setdefault("records", []).append(rec)
        data["next_id"] = rec_id + 1
        # per-chat overall balance
        ob = data.setdefault("overall_balance", {})
        ob[str(chat_id)] = ob.get(str(chat_id), 0) + amt
        added = True

    if added:
        save_data(data)
        # send minimal acknowledgement to user, then forward ack only if the message author is OWNER_ID
        ack = send_and_record(chat_id, "‚úÖ –ó–∞–ø–∏—Å—å –ø—Ä–∏–Ω—è—Ç–∞. –û–∫–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ.", purpose="ack")
        # forward original message already attempted above in auto_forward_if_owner (owner-only)
        # additionally (optionally) forward the ACK message to targets if the original author is OWNER
        if getattr(message.from_user, "id", None) and str(message.from_user.id) == str(OWNER_ID):
            # forward bot ack copy to targets (so group sees both original and ack) ‚Äî but user asked earlier no bot messages forwarded; we keep this OFF by default
            pass
        update_day_window_after_change(chat_id, date_today_local(), purpose="added_records")
    else:
        # not parsed as numbers ‚Äî just refresh window (no DB change)
        update_day_window_after_change(chat_id, date_today_local(), purpose="recreated_on_message")

# -------------------------------
# Callback handler for inline buttons
# -------------------------------
@bot.callback_query_handler(func=lambda c: True)
def callback_worker(call: types.CallbackQuery):
    global data
    data = load_data()
    cdata = call.data or ""
    chat_id = call.message.chat.id
    try:
        bot.answer_callback_query(call.id)
    except Exception:
        pass

    # edit menu
    if cdata == "edit_menu":
        # list today's records for this chat
        today = date_today_local()
        recs = get_day_records_for_chat(chat_id, today)
        if not recs:
            send_and_record(chat_id, "–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –∑–∞ —Å–µ–≥–æ–¥–Ω—è.", purpose="edit_empty")
            return
        kb = types.InlineKeyboardMarkup()
        for ts, r in recs:
            label = f"{r['short_id']} {r.get('note','')[:40]}"
            kb.add(types.InlineKeyboardButton(label, callback_data=f"select:{r['short_id']}"))
        kb.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="edit_cancel"))
        try:
            bot.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–ø–∏—Å—å –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:", chat_id, call.message.message_id, reply_markup=kb)
        except Exception:
            send_and_record(chat_id, "–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–ø–∏—Å—å:", reply_markup=kb, purpose="edit_fallback")
        return

    if cdata.startswith("select:"):
        short = cdata.split(":",1)[1]
        # set pending edit for this chat
        data.setdefault("pending_edit", {})[str(chat_id)] = short
        save_data(data)
        send_and_record(chat_id, f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è {short} (–ø—Ä–∏–º–µ—Ä: +1000 –∑–∞—Ä–ø–ª–∞—Ç–∞).", purpose="await_modify")
        return

    if cdata == "edit_cancel":
        # restore day window
        update_day_window_after_change(chat_id, date_today_local(), purpose="cancel_edit")
        return

    if cdata == "forward_menu":
        try:
            bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=kb_forward_menu(chat_id))
        except Exception:
            send_and_record(chat_id, "–ú–µ–Ω—é –ø–µ—Ä–µ—Å—ã–ª–∫–∏:", reply_markup=kb_forward_menu(chat_id), purpose="forward_menu_fallback")
        return

    if cdata == "forward_add":
        send_and_record(chat_id, "–û—Ç–ø—Ä–∞–≤—å—Ç–µ chat_id –∏–ª–∏ @username —Ü–µ–ª–µ–≤–æ–π –≥—Ä—É–ø–ø—ã –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ (–∏–ª–∏ –ø–µ—Ä–µ—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ç–æ–π –≥—Ä—É–ø–ø—ã).", purpose="await_forward_input")
        data.setdefault("pending_action", {})[str(chat_id)] = {"type": "await_forward_add"}
        save_data(data)
        return

    if cdata == "forward_remove":
        lst = list_forward_targets(chat_id)
        if not lst:
            send_and_record(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.", purpose="forward_none")
            return
        send_and_record(chat_id, "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–æ—á–Ω—É—é —Ü–µ–ª—å –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è (–∏–ª–∏ '–≤—Å—ë'):", purpose="await_forward_remove")
        data.setdefault("pending_action", {})[str(chat_id)] = {"type": "await_forward_remove"}
        save_data(data)
        return

    if cdata == "forward_list":
        lst = list_forward_targets(chat_id)
        send_and_record(chat_id, "–¶–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏:\n" + ("\n".join(lst) if lst else "–ù–µ—Ç"), purpose="forward_list")
        return

    if cdata == "toggle_compact":
        key = str(chat_id)
        cur = data.setdefault("compact_mode", {}).get(key, False)
        data.setdefault("compact_mode", {})[key] = not cur
        save_data(data)
        send_and_record(chat_id, f"Compact-mode {'–≤–∫–ª—é—á–µ–Ω' if not cur else '–æ—Ç–∫–ª—é—á–µ–Ω'}.", purpose="compact_toggle")
        update_day_window_after_change(chat_id, date_today_local(), purpose="compact_toggle_update")
        return

    if cdata == "export_csv":
        try:
            path = CSV_FILE
            with open(path, "w", newline="", encoding="utf-8-sig") as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=["ID","–î–∞—Ç–∞","–í—Ä–µ–º—è","–°—É–º–º–∞","–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π","–í–ª–∞–¥–µ–ª–µ—Ü"])
                writer.writeheader()
                for r in data.get("records", []):
                    try:
                        dt = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
                        date_s = dt.strftime("%Y-%m-%d")
                        time_s = dt.strftime("%H:%M:%S")
                    except Exception:
                        date_s = date_today_local(); time_s = ""
                    writer.writerow({"ID": r.get("short_id"), "–î–∞—Ç–∞": date_s, "–í—Ä–µ–º—è": time_s, "–°—É–º–º–∞": r.get("amount"), "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π": r.get("note",""), "–í–ª–∞–¥–µ–ª–µ—Ü": r.get("owner_chat")})
            send_file_and_record(chat_id, path, caption="–≠–∫—Å–ø–æ—Ä—Ç CSV", purpose="export_csv")
        except Exception as e:
            send_and_record(chat_id, f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: {e}", purpose="export_error")
        return

    if cdata == "reset_confirm":
        # only owner can reset
        if str(call.from_user.id) != str(OWNER_ID):
            send_and_record(chat_id, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç –æ–±–Ω—É–ª–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.", purpose="reset_denied")
            return
        try:
            bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=kb_yes_no("confirm_reset"))
        except Exception:
            send_and_record(chat_id, "–í—ã —É–≤–µ—Ä–µ–Ω—ã? (–î–∞/–ù–µ—Ç)", reply_markup=kb_yes_no("confirm_reset"), purpose="reset_prompt")
        return

    if cdata.startswith("confirm_reset"):
        if cdata.endswith("_yes"):
            if str(call.from_user.id) != str(OWNER_ID):
                send_and_record(chat_id, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü.", purpose="reset_denied2")
                return
            # full reset (keeps version_current)
            base = default_data()
            base["version_current"] = data.get("version_current", VERSION)
            save_data(base)
            data.clear(); data.update(load_data())
            send_and_record(chat_id, "‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã.", purpose="reset_done")
        else:
            send_and_record(chat_id, "–û—Ç–º–µ–Ω–µ–Ω–æ.", purpose="reset_cancel")
        return

    # unhandled
    print("[callback] unhandled:", cdata)

# -------------------------------
# Command handlers
# -------------------------------
@bot.message_handler(commands=["start"])
def cmd_start(m: types.Message):
    chat_id = m.chat.id
    # minimal welcome
    text = f"ü§ñ –ë–æ—Ç '–§–û' v{VERSION}\n–ë–æ—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ ‚Äî –≤—ã –Ω–∞—á–∞–ª–∏ –≤–µ—Å—Ç–∏ —É—á—ë—Ç.\n\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n/start\n/–±–∞–ª–∞–Ω—Å\n/–æ—Ç—á–µ—Ç\n/—Å–±—Ä–æ—Å\n/addforward <chat_id>\n/removeforward <chat_id>\n/listforwards\n/compact_on\n/compact_off\n/whoami\n\n(–¢–∞–∫–∂–µ –¥–æ—Å—Ç—É–ø–Ω—ã inline-–∫–Ω–æ–ø–∫–∏ –≤ –æ–∫–Ω–µ –¥–Ω—è.)"
    send_and_record(chat_id, text, purpose="start")
    # create or update day window
    update_day_window_after_change(chat_id, date_today_local(), purpose="start_window")

@bot.message_handler(commands=["whoami"])
def cmd_whoami(m: types.Message):
    send_and_record(m.chat.id, f"–í–∞—à chat.id: {m.chat.id}\n–í–∞—à user.id: {m.from_user.id}", purpose="whoami")

@bot.message_handler(commands=["–±–∞–ª–∞–Ω—Å"])
def cmd_balance(m: types.Message):
    ob = data.get("overall_balance", {}).get(str(m.chat.id), 0)
    send_and_record(m.chat.id, f"üí∞ –ë–∞–ª–∞–Ω—Å —ç—Ç–æ–≥–æ —á–∞—Ç–∞: {fmt_amount(ob)}", purpose="balance")

@bot.message_handler(commands=["–æ—Ç—á–µ—Ç"])
def cmd_report(m: types.Message):
    recs = [r for r in data.get("records", []) if str(r.get("owner_chat")) == str(m.chat.id)]
    if not recs:
        return send_and_record(m.chat.id, "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç—á—ë—Ç–∞.", purpose="report_empty")
    path = CSV_FILE
    try:
        with open(path, "w", newline="", encoding="utf-8-sig") as f:
            writer = csv.writer(f)
            writer.writerow(["id","short_id","timestamp","amount","note","owner_chat"])
            for r in recs:
                writer.writerow([r["id"], r["short_id"], r["timestamp"], r["amount"], r.get("note",""), r.get("owner_chat")])
        send_file_and_record(m.chat.id, path, caption="–û—Ç—á—ë—Ç CSV", purpose="report")
    except Exception as e:
        send_and_record(m.chat.id, f"–û—à–∏–±–∫–∞: {e}", purpose="report_error")

@bot.message_handler(commands=["—Å–±—Ä–æ—Å"])
def cmd_reset(m: types.Message):
    if str(m.from_user.id) != str(OWNER_ID):
        return send_and_record(m.chat.id, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç –æ–±–Ω—É–ª–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.", purpose="reset_denied_cmd")
    base = default_data()
    base["version_current"] = data.get("version_current", VERSION)
    save_data(base)
    data.clear(); data.update(load_data())
    send_and_record(m.chat.id, "‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã.", purpose="reset_cmd")
    update_day_window_after_change(m.chat.id, date_today_local(), purpose="reset_update")

@bot.message_handler(commands=["addforward"])
def cmd_addforward_text(m: types.Message):
    # only owner allowed to configure forwarding
    if str(m.from_user.id) != str(OWNER_ID):
        return send_and_record(m.chat.id, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.", purpose="addforward_denied")
    parts = m.text.strip().split(maxsplit=1)
    if len(parts) < 2:
        return send_and_record(m.chat.id, "–§–æ—Ä–º–∞—Ç: /addforward <chat_id_or_username>", purpose="addforward_help")
    target = parts[1].strip().strip('"')
    added = add_forward_target(m.chat.id, target)
    if added:
        send_and_record(m.chat.id, f"‚úÖ –¶–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω–∞: {target}", purpose="addforward_ok")
    else:
        send_and_record(m.chat.id, "–≠—Ç–∞ —Ü–µ–ª—å —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ.", purpose="addforward_exists")

@bot.message_handler(commands=["removeforward"])
def cmd_removeforward_text(m: types.Message):
    if str(m.from_user.id) != str(OWNER_ID):
        return send_and_record(m.chat.id, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.", purpose="removeforward_denied")
    parts = m.text.strip().split(maxsplit=1)
    if len(parts) < 2:
        return send_and_record(m.chat.id, "–§–æ—Ä–º–∞—Ç: /removeforward <chat_id_or_username>", purpose="removeforward_help")
    target = parts[1].strip().strip('"')
    ok = remove_forward_target(m.chat.id, target)
    if ok:
        send_and_record(m.chat.id, f"‚úÖ –¶–µ–ª—å —É–¥–∞–ª–µ–Ω–∞: {target}", purpose="removeforward_ok")
    else:
        send_and_record(m.chat.id, "–¶–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", purpose="removeforward_no")

@bot.message_handler(commands=["listforwards"])
def cmd_listforwards_text(m: types.Message):
    lst = list_forward_targets(m.chat.id)
    send_and_record(m.chat.id, "–¢–µ–∫—É—â–∏–µ —Ü–µ–ª–∏:\n" + ("\n".join(lst) if lst else "–ù–µ—Ç"), purpose="listforwards")

@bot.message_handler(commands=["compact_on"])
def cmd_compact_on(m: types.Message):
    data.setdefault("compact_mode", {})[str(m.chat.id)] = True
    save_data(data)
    send_and_record(m.chat.id, "Compact-mode –≤–∫–ª—é—á—ë–Ω.", purpose="compact_on")
    update_day_window_after_change(m.chat.id, date_today_local(), purpose="compact_on_update")

@bot.message_handler(commands=["compact_off"])
def cmd_compact_off(m: types.Message):
    data.setdefault("compact_mode", {})[str(m.chat.id)] = False
    save_data(data)
    send_and_record(m.chat.id, "Compact-mode –≤—ã–∫–ª—é—á–µ–Ω.", purpose="compact_off")
    update_day_window_after_change(m.chat.id, date_today_local(), purpose="compact_off_update")

# -------------------------------
# Pending actions (simple handler for forward add/remove and edit)
# -------------------------------
@bot.message_handler(func=lambda m: True, content_types=['text'])
def pending_actions_handler(m: types.Message):
    """
    This handler runs after generic handler; it processes pending actions
    stored in data['pending_action'] or data['pending_edit'] for the chat.
    We keep it lightweight: if pending, process and return; else do nothing.
    """
    global data
    data = load_data()
    chat_id = m.chat.id
    pa = data.get("pending_action", {}).get(str(chat_id))
    if pa:
        typ = pa.get("type")
        if typ == "await_forward_add":
            txt = (m.text or "").strip().strip('"')
            if txt:
                ok = add_forward_target(chat_id, txt)
                if ok:
                    send_and_record(chat_id, f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: {txt}", purpose="pending_forward_add")
                else:
                    send_and_record(chat_id, "–£–∂–µ –≤ —Å–ø–∏—Å–∫–µ.", purpose="pending_forward_add_exists")
            else:
                send_and_record(chat_id, "–ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥.", purpose="pending_forward_add_bad")
            data.get("pending_action", {}).pop(str(chat_id), None)
            save_data(data)
            return
        if typ == "await_forward_remove":
            txt = (m.text or "").strip()
            if txt.lower() in ("–≤—Å—ë","–≤—Å–µ","all"):
                data.get("forward_targets", {}).pop(str(chat_id), None)
                save_data(data)
                send_and_record(chat_id, "‚úÖ –í—Å–µ —Ü–µ–ª–∏ —É–¥–∞–ª–µ–Ω—ã.", purpose="pending_forward_remove_all")
            else:
                ok = remove_forward_target(chat_id, txt)
                if ok:
                    send_and_record(chat_id, f"‚úÖ –£–¥–∞–ª–µ–Ω–æ: {txt}", purpose="pending_forward_remove")
                else:
                    send_and_record(chat_id, "–ù–µ –Ω–∞–π–¥–µ–Ω–æ.", purpose="pending_forward_remove_no")
            data.get("pending_action", {}).pop(str(chat_id), None)
            save_data(data)
            return

    # pending edit
    ped = data.get("pending_edit", {}).get(str(chat_id))
    if ped:
        txt = (m.text or "").strip()
        num, sign, raw = parse_first_number(txt)
        if num is None:
            send_and_record(chat_id, "‚ùó –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: +1000 –∑–∞—Ä–ø–ª–∞—Ç–∞", purpose="pending_edit_bad")
            data.get("pending_edit", {}).pop(str(chat_id), None)
            save_data(data)
            return
        new_amt = apply_sign_and_normalize(num, sign)
        note = txt[(txt.find(raw) + len(raw)):].strip() if raw in txt else ""
        for i, r in enumerate(data.get("records", [])):
            sid = r.get("short_id")
            if sid == ped and str(r.get("owner_chat")) == str(chat_id):
                # update balances
                ob = data.setdefault("overall_balance", {})
                ob[str(chat_id)] = ob.get(str(chat_id), 0) - r.get("amount", 0) + new_amt
                data["records"][i]["amount"] = new_amt
                data["records"][i]["note"] = note
                save_data(data)
                send_and_record(chat_id, f"‚úÖ {ped} –æ–±–Ω–æ–≤–ª—ë–Ω.", purpose="pending_edit_done")
                update_day_window_after_change(chat_id, date_today_local(), purpose="pending_edit_update")
                break
        data.get("pending_edit", {}).pop(str(chat_id), None)
        save_data(data)
        return

# -------------------------------
# Webhook endpoints (Flask)
# -------------------------------
@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    try:
        json_str = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
    except Exception as e:
        print(f"[webhook] {e}")
    return '', 200

@app.route("/", methods=['GET'])
def index():
    return f"ü§ñ –ë–æ—Ç '–§–û' v{VERSION} –∞–∫—Ç–∏–≤–µ–Ω."

# -------------------------------
# Startup webhook set + run
# -------------------------------
def set_webhook_if_possible():
    try:
        host = os.getenv("RENDER_EXTERNAL_URL") or os.getenv("RENDER_EXTERNAL_HOSTNAME")
        if host:
            url = f"https://{host}{WEBHOOK_PATH}"
            bot.remove_webhook()
            time.sleep(0.5)
            bot.set_webhook(url=url)
            print(f"[startup] Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {url}")
            if OWNER_ID:
                try:
                    msg = bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION}: webhook –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.")
                    delayed_delete(int(OWNER_ID), msg.message_id, delay=5)
                    record_sent_message({"chat_id": str(OWNER_ID), "message_id": int(msg.message_id), "timestamp": now_iso_utc(), "purpose": "owner_ping"})
                except Exception as e:
                    print(f"[startup notify] {e}")
    except Exception as e:
        print(f"[set_webhook_if_possible] {e}")

if __name__ == "__main__":
    print(f"–ó–∞–ø—É—Å–∫ –§–û v{VERSION} ...")
    save_data(data)
    set_webhook_if_possible()
    # notify owner on start
    if OWNER_ID:
        try:
            msg = bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION} –∑–∞–ø—É—â–µ–Ω.")
            delayed_delete(int(OWNER_ID), msg.message_id, delay=5)
            record_sent_message({"chat_id": str(OWNER_ID), "message_id": int(msg.message_id), "timestamp": now_iso_utc(), "purpose": "owner_start"})
        except Exception:
            pass
    app.run(host="0.0.0.0", port=PORT)

# -------------------------------
# lines: ~720 (–ø—Ä–∏–º–µ—Ä–Ω–æ)
# -------------------------------