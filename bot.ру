# -------------------------------
# –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç "–§–û" ‚Äî –≤–µ—Ä—Å–∏—è 9.8.2
# –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è (–Ω–∞ –±–∞–∑–µ 9.8.0)
# Flask webhook ‚Äî –≥–æ—Ç–æ–≤ –∫ Deploy –Ω–∞ Render
# –¢—Ä–µ–±—É–µ—Ç: BOT_TOKEN, OWNER_ID –≤ env
# requirements.txt: pyTelegramBotAPI==4.23.0, flask
# -------------------------------

import os
import json
import time
import threading
import re
import csv
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from typing import Optional, Tuple, List, Dict, Any

from flask import Flask, request
import telebot
from telebot import types

# -------------------------------
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
# -------------------------------
VERSION = "9.8.2"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/" + TOKEN) if TOKEN else "/webhook"

if not TOKEN:
    raise ValueError("–û—à–∏–±–∫–∞: BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------------
# default data structure (backward compatible with 9.6.1)
# –î–æ–±–∞–≤–ª–µ–Ω—ã: per_chat_balances (—Å–ª–æ–≤–∞—Ä—å), –Ω–æ —Å—Ç–∞—Ä—ã–µ –ø–æ–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã
# -------------------------------
def default_data() -> Dict[str, Any]:
    return {
        "version_base": "9.6.1",
        "version_current": VERSION,
        "overall_balance": 0,
        "records": [],           # {id, short_id, timestamp(ISO UTC), amount, note, owner}
        "active_messages": {},   # YYYY-MM-DD -> { "chat_id": id, "message_id": id } per owner/chat
        "next_id": 1,
        "sent_messages": [],     # –∏—Å—Ç–æ—Ä–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –±–æ—Ç–æ–º —Å–æ–æ–±—â–µ–Ω–∏–π / –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ—Å—ã–ª–∫–∏
        "forward_targets": {},   # "<owner_chat_id>": ["<target1>", "<target2>", ...]
        # new:
        "per_chat": {}           # "<chat_id>": { "balance": int, "records": [short_id,...] }
    }

# -------------------------------
# Load/Save data
# -------------------------------
def load_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            print(f"[load_data] –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å {DATA_FILE}: {e}")
            d = default_data()
    else:
        d = default_data()
    # ensure keys
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    # ensure per_chat structure present
    if "per_chat" not in d:
        d["per_chat"] = {}
    return d

def save_data(d: Dict[str, Any]) -> None:
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[save_data] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è {DATA_FILE}: {e}")

data = load_data()

# -------------------------------
# Utilities: parsing, formatting (–∫–∞–∫ –≤ 9.6.1)
# -------------------------------
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text: str) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    if s.startswith('+'):
        sign = '+'
        digits = s[1:].strip()
    elif s.startswith('-'):
        sign = '-'
        digits = s[1:].strip()
    else:
        sign = ''  # –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∑–Ω–∞–∫–∞ => —Ä–∞—Å—Ö–æ–¥
        digits = s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    dm = re.match(r'(\d+)', digits_norm)
    if not dm:
        return None, None, None
    return int(dm.group(1)), sign, raw

def apply_sign_and_normalize(num: int, sign: Optional[str]) -> int:
    return num if sign == '+' else -num

def fmt_amount(n: int) -> str:
    return f"{abs(n):,}".replace(",", ".")

def make_short_id(n: int) -> str:
    return f"R{n}"

def date_local_str(dt: datetime) -> str:
    return dt.astimezone(TZ).strftime("%Y-%m-%d")

def time_local_str(dt: datetime) -> str:
    return dt.astimezone(TZ).strftime("%H:%M")

def now_iso_utc() -> str:
    return datetime.now(tz=ZoneInfo("UTC")).isoformat()

def now_local_iso() -> str:
    return datetime.now(tz=TZ).isoformat()

# -------------------------------
# Per-chat helpers (new)
# - –º—ã –ù–ï —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏; —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º per_chat –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏/—É–¥–∞–ª–µ–Ω–∏–∏/–∏–∑–º–µ–Ω–µ–Ω–∏–∏
# -------------------------------
def ensure_per_chat(chat_id: str) -> None:
    data.setdefault("per_chat", {})
    if chat_id not in data["per_chat"]:
        data["per_chat"][chat_id] = {"balance": 0, "records": []}
        save_data(data)

def recalc_per_chat_for(chat_id: str) -> None:
    """
    –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ—Ç –±–∞–ª–∞–Ω—Å –∏ —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π –¥–ª—è chat_id –Ω–∞ –æ—Å–Ω–æ–≤–µ data['records'].
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏, –µ—Å–ª–∏ —Ñ–∞–π–ª –±—ã–ª –∏–∑–º–µ–Ω—ë–Ω –∏–∑–≤–Ω–µ.
    """
    ensure_per_chat(chat_id)
    recs = [r for r in data.get("records", []) if str(r.get("owner")) == str(chat_id)]
    total = sum([r.get("amount", 0) for r in recs])
    ids = [r.get("short_id") if r.get("short_id") else make_short_id(r.get("id")) for r in recs]  # fallback
    # the above line had quotes; we'll correct below in actual code (keeps logic)
    # Save:
    data["per_chat"][str(chat_id)] = {"balance": total, "records": [r.get("short_id") or make_short_id(r.get("id")) for r in recs]}
    save_data(data)

# (Note: the previous recalc_per_chat_for included a small accidental string quoting bug; it's corrected further down in real operations.)

# -------------------------------
# –ß–∞—Å—Ç—å 2/4 ‚Äî –∑–∞–ø–∏—Å—å, –æ—Ç–ø—Ä–∞–≤–∫–∞, –ø–µ—Ä–µ—Å—ã–ª–∫–∞, —ç–∫—Å–ø–æ—Ä—Ç CSV, –æ–∫–Ω–∞ –¥–Ω—è
# -------------------------------

# -------------------------------
# –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –∏ –Ω–∞–¥—ë–∂–Ω–∞—è –≤–µ—Ä—Å–∏—è recalc_per_chat_for (–±–µ–∑ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–æ–∫)
def recalc_per_chat_for(chat_id: str) -> None:
    ensure_per_chat(chat_id)
    recs = [r for r in data.get("records", []) if str(r.get("owner")) == str(chat_id)]
    total = sum([r.get("amount", 0) for r in recs])
    ids = [r.get("short_id") or make_short_id(r.get("id")) for r in recs]
    data["per_chat"][str(chat_id)] = {"balance": total, "records": ids}
    save_data(data)

# When global consistency needed (recalculate for all chats)
def recalc_all_per_chat() -> None:
    data.setdefault("per_chat", {})
    owners = set([str(r.get("owner")) for r in data.get("records", [])])
    for o in owners:
        recalc_per_chat_for(o)
    save_data(data)

# -------------------------------
# Sent messages recording (modified to store errors in Russian)
def record_sent_message(entry: Dict[str, Any]) -> None:
    data.setdefault("sent_messages", []).append(entry)
    save_data(data)

def send_and_record(chat_id: int, text: str, reply_markup=None, parse_mode=None, purpose: str="message") -> Optional[types.Message]:
    try:
        sent = bot.send_message(int(chat_id), text, reply_markup=reply_markup, parse_mode=parse_mode)
        record_sent_message({
            "chat_id": int(chat_id),
            "message_id": int(sent.message_id),
            "timestamp": now_iso_utc(),
            "purpose": purpose
        })
        return sent
    except Exception as e:
        err = f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ {chat_id}: {e}"
        record_sent_message({
            "chat_id": int(chat_id),
            "message_id": None,
            "timestamp": now_iso_utc(),
            "purpose": purpose,
            "error": str(e)
        })
        # non-blocking notify owner
        try:
            if OWNER_ID:
                bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è {err}")
        except Exception:
            pass
        return None

def send_file_and_record(chat_id: int, path: str, caption: Optional[str]=None, purpose: str="file") -> Optional[types.Message]:
    try:
        with open(path, "rb") as f:
            sent = bot.send_document(int(chat_id), f, caption=caption)
        record_sent_message({
            "chat_id": int(chat_id),
            "message_id": int(sent.message_id),
            "timestamp": now_iso_utc(),
            "purpose": purpose
        })
        return sent
    except Exception as e:
        record_sent_message({
            "chat_id": int(chat_id),
            "message_id": None,
            "timestamp": now_iso_utc(),
            "purpose": purpose,
            "error": str(e)
        })
        try:
            if OWNER_ID:
                bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞ –≤ {chat_id}: {e}")
        except Exception:
            pass
        return None

# -------------------------------
# Delayed delete helper
def delayed_delete(chat_id: int, message_id: int, delay: int = 5) -> None:
    def worker():
        time.sleep(delay)
        try:
            bot.delete_message(int(chat_id), int(message_id))
        except Exception as e:
            print(f"[delayed_delete] –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è {chat_id}/{message_id}: {e}")
    threading.Thread(target=worker, daemon=True).start()

# -------------------------------
# Day window building (as –≤ 9.6.1), –Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç per-chat —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ
def get_day_records_for_chat(chat_id: int, day_date: str):
    recs = []
    for r in data.get("records", []):
        if str(r.get("owner")) != str(chat_id):
            continue
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        except Exception:
            ts = datetime.fromisoformat(r["timestamp"])
            ts = ts.astimezone(TZ)
        if date_local_str(ts) == day_date:
            recs.append((ts, r))
    recs.sort(key=lambda x: x[0])
    return recs

def build_day_window(chat_id: int, day_date: str) -> str:
    recs = get_day_records_for_chat(chat_id, day_date)
    if not recs:
        return "üìò –ó–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –µ—â—ë –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π."
    lines = []
    lines.append(f"üìÖ {day_date}\n")
    last_hour = None
    day_income, day_expense = 0, 0
    for ts, r in recs:
        hour = ts.strftime("%H")
        if last_hour is None:
            last_hour = hour
        elif hour != last_hour:
            lines.append("")
            last_hour = hour
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        sid = r.get("short_id") or make_short_id(r.get("id"))
        note = r.get("note", "")
        t_local = time_local_str(ts)
        lines.append(f"üïì {t_local} | {sid} | {sign}{fmt_amount(amt)} {note}".rstrip())
        if amt > 0:
            day_income += amt
        else:
            day_expense += abs(amt)
    # per-chat balance (if exists), else overall
    per_chat_entry = data.get("per_chat", {}).get(str(chat_id))
    if per_chat_entry:
        overall = per_chat_entry.get("balance", 0)
    else:
        overall = data.get("overall_balance", 0)
    lines.append("")
    lines.append(f"üìà –ü—Ä–∏—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_income)}")
    lines.append(f"üìâ –†–∞—Å—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_expense)}")
    lines.append(f"üíµ –ë–∞–ª–∞–Ω—Å —á–∞—Ç–∞: {fmt_amount(overall)}")
    return "\n".join(lines)

# -------------------------------
# Keyboards (inline) ‚Äî forward button –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û –≤ –ª–∏—á–∫–µ
def kb_day_main():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_menu"))
    return kb

def kb_edit_main(chat_id=None, is_private=False):
    # is_private: –µ—Å–ª–∏ True ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–ø—Ü–∏–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–ò–∑–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å", callback_data="edit_modify"))
    kb.add(types.InlineKeyboardButton("–£–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å", callback_data="edit_delete"))
    kb.add(types.InlineKeyboardButton("üìÑ –≠–∫—Å–ø–æ—Ä—Ç CSV", callback_data="edit_export_csv"))
    kb.add(types.InlineKeyboardButton("–û–±–Ω—É–ª–∏—Ç—å –≤—Å—ë (–≤—Å–µ—Ö)", callback_data="edit_reset_all"))
    if is_private:
        target_list = data.get("forward_targets", {}).get(str(chat_id), [])
        if target_list:
            kb.add(types.InlineKeyboardButton("üö´ –û—Ç–∫–ª—é—á–∏—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫—É", callback_data="forward_cancel"))
        else:
            kb.add(types.InlineKeyboardButton("üì§ –ü–µ—Ä–µ—Å—ã–ª–∫–∞", callback_data="forward_setup"))
    kb.add(types.InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="edit_cancel"))
    return kb

def kb_forward_menu(chat_id=None):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("üîß –î–æ–±–∞–≤–∏—Ç—å —Ü–µ–ª—å –ø–µ—Ä–µ—Å—ã–ª–∫–∏", callback_data="forward_add"))
    kb.add(types.InlineKeyboardButton("‚ùå –£–¥–∞–ª–∏—Ç—å —Ü–µ–ª—å", callback_data="forward_remove"))
    kb.add(types.InlineKeyboardButton("‚ÑπÔ∏è –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–µ–∫—É—â–∏–µ", callback_data="forward_check"))
    kb.add(types.InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="edit_cancel"))
    return kb

def kb_records_list(chat_id: int, day_date: str, mode: str):
    kb = types.InlineKeyboardMarkup()
    recs = []
    for ts, r in get_day_records_for_chat(chat_id, day_date):
        sid = r.get("short_id") or make_short_id(r.get("id"))
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        label = f"[{sid}] {sign}{fmt_amount(amt)} {r.get('note','')}"
        recs.append((sid, label))
    if not recs:
        kb.add(types.InlineKeyboardButton("–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –∑–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å", callback_data="no_op"))
        kb.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="edit_menu"))
        return kb
    for sid, label in recs:
        kb.add(types.InlineKeyboardButton(label[:60], callback_data=f"select:{mode}:{sid}"))
    kb.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="edit_menu"))
    return kb

def kb_yes_no(cb_prefix: str):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–î–∞", callback_data=f"{cb_prefix}_yes"),
           types.InlineKeyboardButton("–ù–µ—Ç", callback_data=f"{cb_prefix}_no"))
    return kb

# -------------------------------
# Export to CSV (–≤—Å–µ –∑–∞–ø–∏—Å–∏ –∏–ª–∏ per-chat)
def export_all_to_csv(path: str = CSV_FILE) -> str:
    rows = []
    for r in data.get("records", []):
        try:
            ts_utc = datetime.fromisoformat(r["timestamp"])
        except Exception:
            ts_utc = datetime.fromisoformat(r["timestamp"])
        ts_local = ts_utc.astimezone(TZ)
        date_s = ts_local.strftime("%Y-%m-%d")
        time_s = ts_local.strftime("%H:%M:%S")
        amt = r["amount"]
        typ = "–ø—Ä–∏—Ö–æ–¥" if amt > 0 else "—Ä–∞—Å—Ö–æ–¥"
        rows.append({
            "ID": r.get("short_id") or make_short_id(r.get("id")),
            "–î–∞—Ç–∞": date_s,
            "–í—Ä–µ–º—è": time_s,
            "–°—É–º–º–∞": f"{amt:+d}",
            "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π": r.get("note",""),
            "–¢–∏–ø": typ,
            "–í–ª–∞–¥–µ–ª–µ—Ü": r.get("owner")
        })
    try:
        with open(path, "w", newline="", encoding="utf-8-sig") as csvfile:
            fieldnames = ["ID","–î–∞—Ç–∞","–í—Ä–µ–º—è","–°—É–º–º–∞","–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π","–¢–∏–ø","–í–ª–∞–¥–µ–ª–µ—Ü"]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            for row in rows:
                writer.writerow(row)
        return path
    except Exception as e:
        print(f"[export_all_to_csv] –û—à–∏–±–∫–∞: {e}")
        raise

# -------------------------------
# –ß–∞—Å—Ç—å 3/4 ‚Äî forward helpers, pm_owner_forward_block, auto_forward, CRUD records
# -------------------------------

# -------------------------------
# Forward helpers (multi-target)
def ensure_forward_list_for(chat_id: int) -> List[str]:
    key = str(chat_id)
    data.setdefault("forward_targets", {})
    current = data["forward_targets"].get(key)
    if current is None:
        data["forward_targets"][key] = []
        save_data(data)
        return data["forward_targets"][key]
    if isinstance(current, list):
        return current
    # convert single string to list
    data["forward_targets"][key] = [str(current)]
    save_data(data)
    return data["forward_targets"][key]

def add_forward_target(chat_id: int, target: str) -> bool:
    lst = ensure_forward_list_for(chat_id)
    t = str(target).strip()
    if t in lst:
        return False
    lst.append(t)
    data["forward_targets"][str(chat_id)] = lst
    save_data(data)
    return True

def remove_forward_target(chat_id: int, target: str) -> bool:
    lst = ensure_forward_list_for(chat_id)
    t = str(target).strip()
    if t in lst:
        lst = [x for x in lst if x != t]
        data["forward_targets"][str(chat_id)] = lst
        save_data(data)
        return True
    return False

def list_forward_targets(chat_id: int) -> List[str]:
    return ensure_forward_list_for(chat_id)

# -------------------------------
# Validate target by sending test message (same behavior, errors in Russian)
def validate_and_test_target(target_raw: str) -> Tuple[bool, str, str]:
    t_raw = str(target_raw).strip()
    if t_raw.startswith("@"):
        normalized = t_raw
    else:
        try:
            normalized = int(t_raw)
        except Exception:
            # accept plain username
            normalized = t_raw if t_raw.startswith("@") else "@" + t_raw
    try:
        bot.send_message(normalized, "üîÅ –¢–µ—Å—Ç –æ—Ç –±–æ—Ç–∞: –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏. –ï—Å–ª–∏ –≤–∏–¥–∏—Ç–µ —ç—Ç–æ ‚Äî –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ.")
        return True, "–¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ.", str(normalized)
    except Exception as e:
        return False, f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}", str(normalized)

# -------------------------------
# Auto-forward (for any incoming message) ‚Äî but we'll ensure never to forward bot's own messages
def auto_forward_message_from(chat_id: int, message: types.Message) -> List[Dict[str, Any]]:
    results = []
    # do not forward bot messages
    try:
        me = bot.get_me()
        if getattr(message.from_user, "id", None) == getattr(me, "id", None):
            return results
    except Exception:
        # if get_me fails ‚Äî proceed but still avoid forwarding messages from OWNER_ID? we rely on direct check earlier
        pass

    targets = data.get("forward_targets", {}).get(str(chat_id)) or []
    if not targets:
        return results
    for t in targets:
        try:
            try:
                tgt_int = int(t)
                bot.forward_message(tgt_int, int(chat_id), message.message_id)
                results.append({"target": t, "ok": True, "method": "forward"})
            except Exception:
                bot.forward_message(t, int(chat_id), message.message_id)
                results.append({"target": t, "ok": True, "method": "forward"})
        except Exception as e:
            try:
                if message.content_type == 'text' and getattr(message, "text", None):
                    bot.send_message(t, f"üì® –ö–æ–ø–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ {chat_id}:\n\n{message.text}")
                    results.append({"target": t, "ok": True, "method": "sent_copy"})
                else:
                    results.append({"target": t, "ok": False, "error": str(e)})
            except Exception as e2:
                results.append({"target": t, "ok": False, "error": str(e2)})
    # record attempts
    for r in results:
        record_sent_message({
            "timestamp": now_iso_utc(),
            "from_chat": str(chat_id),
            "to": r["target"],
            "ok": bool(r.get("ok")),
            "info": r.get("error") if not r.get("ok") else r.get("method")
        })
    return results

# -------------------------------
# PM-owner forwarding block (ONLY from private chat and only if message.from_user.id == OWNER_ID)
# - forwards to all targets listed in data['forward_targets'][OWNER_ID]
# - sends raw content (no pref/explanation) ‚Äî text or media sent using file_id where possible
# - never forwards bot's own messages
def pm_owner_forward_block(message: types.Message) -> bool:
    try:
        # only from private chat
        if getattr(message.chat, "type", "") != "private":
            return False
        # only from OWNER
        if str(getattr(message.from_user, "id", "")) != str(OWNER_ID):
            return False
        # don't forward bot's own messages (safety)
        try:
            me = bot.get_me()
            if getattr(message.from_user, "id", None) == getattr(me, "id", None):
                return False
        except Exception:
            pass
        owner_key = str(OWNER_ID)
        targets = data.get("forward_targets", {}).get(owner_key, []) or []
        if not targets:
            return False

        # text
        if message.content_type == 'text':
            text = (message.text or "")
            if not text:
                return True
            for tgt in targets:
                try:
                    # prefer to send as plain text to target
                    bot.send_message(tgt, text)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_text", "ok": True})
                except Exception as e:
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_text", "ok": False, "error": str(e)})
            return True

        # photo
        if message.content_type == 'photo' and getattr(message, "photo", None):
            file_id = message.photo[-1].file_id
            caption = getattr(message, "caption", None) or ""
            for tgt in targets:
                try:
                    # use send_photo with file_id
                    bot.send_photo(tgt, file_id, caption=caption)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_photo", "ok": True})
                except Exception as e:
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_photo", "ok": False, "error": str(e)})
            return True

        # document
        if message.content_type == 'document' and getattr(message, "document", None):
            file_id = message.document.file_id
            caption = getattr(message, "caption", None) or ""
            for tgt in targets:
                try:
                    bot.send_document(tgt, file_id, caption=caption)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_doc", "ok": True})
                except Exception as e:
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_doc", "ok": False, "error": str(e)})
            return True

        # voice
        if message.content_type == 'voice' and getattr(message, "voice", None):
            file_id = message.voice.file_id
            for tgt in targets:
                try:
                    bot.send_voice(tgt, file_id)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_voice", "ok": True})
                except Exception as e:
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_voice", "ok": False, "error": str(e)})
            return True

        # audio
        if message.content_type == 'audio' and getattr(message, "audio", None):
            file_id = message.audio.file_id
            for tgt in targets:
                try:
                    bot.send_audio(tgt, file_id)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_audio", "ok": True})
                except Exception as e:
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_audio", "ok": False, "error": str(e)})
            return True

        # sticker
        if message.content_type == 'sticker' and getattr(message, "sticker", None):
            file_id = message.sticker.file_id
            for tgt in targets:
                try:
                    bot.send_sticker(tgt, file_id)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_sticker", "ok": True})
                except Exception as e:
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_sticker", "ok": False, "error": str(e)})
            return True

        # video
        if message.content_type == 'video' and getattr(message, "video", None):
            file_id = message.video.file_id
            caption = getattr(message, "caption", None) or ""
            for tgt in targets:
                try:
                    bot.send_video(tgt, file_id, caption=caption)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_video", "ok": True})
                except Exception as e:
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_video", "ok": False, "error": str(e)})
            return True

        # location
        if message.content_type == 'location' and getattr(message, "location", None):
            lat = message.location.latitude
            lon = message.location.longitude
            for tgt in targets:
                try:
                    bot.send_location(tgt, lat, lon)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_location", "ok": True})
                except Exception as e:
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_location", "ok": False, "error": str(e)})
            return True

        # contact
        if message.content_type == 'contact' and getattr(message, "contact", None):
            phone = message.contact.phone_number
            first = message.contact.first_name
            last = getattr(message.contact, "last_name", None)
            for tgt in targets:
                try:
                    bot.send_contact(tgt, phone, first, last)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_contact", "ok": True})
                except Exception as e:
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_contact", "ok": False, "error": str(e)})
            return True

        # fallback: try forward_message
        for tgt in targets:
            try:
                try:
                    bot.forward_message(int(tgt), message.chat.id, message.message_id)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_forward", "ok": True})
                except Exception:
                    bot.forward_message(tgt, message.chat.id, message.message_id)
                    record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_forward", "ok": True})
            except Exception as e:
                record_sent_message({"timestamp": now_iso_utc(), "from_owner": owner_key, "to": str(tgt), "purpose": "pm_forward_forward", "ok": False, "error": str(e)})
        return True

    except Exception as e:
        print(f"[pm_owner_forward_block] –û—à–∏–±–∫–∞: {e}")
        try:
            if OWNER_ID:
                bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –±–ª–æ–∫–∞ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –ª–∏—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π: {e}")
        except Exception:
            pass
        return False

# -------------------------------
# Record CRUD: add, find, delete, modify (preserve old behaviour and update per_chat)
def find_record_by_short_id(short_id: str):
    for r in data.get("records", []):
        if r.get("short_id") == short_id or make_short_id(r.get("id")) == short_id:
            return r
    return None

def delete_record_by_short_id(chat_id: int, short_id: str) -> bool:
    r = find_record_by_short_id(short_id)
    if not r or str(r.get("owner")) != str(chat_id):
        return False
    try:
        data["records"] = [x for x in data["records"] if not (x.get("short_id") == short_id or make_short_id(x.get("id")) == short_id)]
        data["overall_balance"] = data.get("overall_balance", 0) - r["amount"]
        save_data(data)
        # update per_chat for owner
        recalc_per_chat_for(str(chat_id))
        today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
        update_day_window_after_change(chat_id, today)
        return True
    except Exception as e:
        print(f"[delete_record] –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: {e}")
        return False

def modify_record_by_short_id(chat_id: int, short_id: str, new_text: str) -> bool:
    r = find_record_by_short_id(short_id)
    if not r or str(r.get("owner")) != str(chat_id):
        return False
    num, sign, raw = parse_first_number(new_text)
    if num is None:
        return False
    new_amt = apply_sign_and_normalize(num, sign)
    note = new_text[(new_text.find(raw) + len(raw)):].strip() if raw in new_text else ""
    for i, rr in enumerate(data["records"]):
        rr_sid = rr.get("short_id") or make_short_id(rr.get("id"))
        if rr_sid == short_id:
            data["overall_balance"] = data.get("overall_balance", 0) - rr["amount"] + new_amt
            data["records"][i]["amount"] = new_amt
            data["records"][i]["note"] = note
            save_data(data)
            # update per_chat
            recalc_per_chat_for(str(chat_id))
            today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            update_day_window_after_change(chat_id, today)
            return True
    return False

# -------------------------------
# Validate and save forward target with test message (immediate feedback)
def validate_and_save_forward(owner_chat_id: int, target_raw: str) -> Tuple[bool, str, Optional[str]]:
    t = str(target_raw).strip()
    if not t:
        return False, "–ü—É—Å—Ç–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä.", None
    # normalize
    if t.startswith("@"):
        target = t
    else:
        try:
            target = int(t)
        except Exception:
            target = t if t.startswith("@") else "@" + t if re.match(r'^[A-Za-z0-9_]+$', t) else t
    test_text = "üîÅ –¢–µ—Å—Ç –æ—Ç –±–æ—Ç–∞: –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏. –ï—Å–ª–∏ –≤–∏–¥–∏—Ç–µ —ç—Ç–æ ‚Äî –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ."
    try:
        bot.send_message(target, test_text)
    except Exception as e:
        err = f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ {repr(target)}: {e}"
        print(f"[validate_forward] {err}")
        return False, f"‚ùå {err}", str(target)
    # save into list
    key = str(owner_chat_id)
    lst = data.get("forward_targets", {}).get(key, [])
    if not isinstance(lst, list):
        lst = [lst] if lst else []
    if str(target) not in lst:
        lst.append(str(target))
        data.setdefault("forward_targets", {})[key] = lst
        save_data(data)
    return True, f"‚úÖ –ü–µ—Ä–µ—Å—ã–ª–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è {target}", str(target)

# -------------------------------
# –ß–∞—Å—Ç—å 4/4 ‚Äî handlers, callbacks, commands, webhook, startup
# -------------------------------

# -------------------------------
# Update day window after change (edited to support per-chat active_messages mapping)
def update_day_window_after_change(chat_id: int, day_date: str, purpose: str="day_window") -> Optional[types.Message]:
    prev_map = data.get("active_messages", {}).get(day_date, {})
    text = build_day_window(chat_id, day_date)
    # detect if chat is private for showing forward option
    is_private = False
    try:
        # best-effort: we can't always get chat type here, but for callbacks we'll pass explicit flag
        # leave is_private False ‚Äî caller may show different markup
        pass
    except Exception:
        pass
    kb = kb_day_main()
    # try to edit existing
    sent = None
    prev_entry = prev_map if isinstance(prev_map, dict) else None
    if prev_entry and str(prev_entry.get("chat_id")) == str(chat_id):
        try:
            bot.edit_message_text(chat_id=int(chat_id), message_id=int(prev_entry.get("message_id")), text=text, reply_markup=kb)
            # record edit
            record_sent_message({
                "chat_id": int(chat_id), "message_id": int(prev_entry.get("message_id")), "timestamp": now_iso_utc(), "purpose": purpose + "_edit"
            })
            save_data(data)
            return prev_entry
        except Exception as e:
            print(f"[update_day_window] –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –¥–ª—è {chat_id}/{prev_entry.get('message_id')}: {e}")
    # send new
    try:
        sent = bot.send_message(int(chat_id), text, reply_markup=kb)
        data.setdefault("active_messages", {})[day_date] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
        record_sent_message({"chat_id": int(chat_id), "message_id": int(sent.message_id), "timestamp": now_iso_utc(), "purpose": purpose})
        save_data(data)
    except Exception as e:
        print(f"[update_day_window] –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ –æ–∫–Ω–æ –¥–Ω—è –≤ {chat_id}: {e}")
        try:
            if OWNER_ID:
                bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è [update_day_window] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ–∫–Ω–∞ –¥–Ω—è –¥–ª—è {chat_id}: {e}")
        except Exception:
            pass
        return None

    # forward the window if forward_targets set for this chat (legacy behavior preserved)
    forward_target = data.get("forward_targets", {}).get(str(chat_id))
    if forward_target:
        targets = forward_target if isinstance(forward_target, list) else [forward_target]
        for ft in targets:
            try:
                try:
                    bot.forward_message(int(ft), int(chat_id), sent.message_id)
                except Exception:
                    bot.forward_message(ft, int(chat_id), sent.message_id)
            except Exception as e:
                print(f"[update_day_window] Forward window failed to {ft}: {e}")
    # delete previous
    if prev_entry and str(prev_entry.get("chat_id")) == str(chat_id):
        delayed_delete(prev_entry["chat_id"], prev_entry["message_id"], delay=5)
        data["active_messages"].pop(day_date, None)
        save_data(data)
    return sent

# -------------------------------
# Delete active window if today and belong
def delete_active_window_if_today_and_belong(chat_id: int) -> bool:
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    am = data.get("active_messages", {}).get(today)
    if am and int(am.get("chat_id")) == int(chat_id):
        delayed_delete(am["chat_id"], am["message_id"], delay=5)
        data["active_messages"].pop(today, None)
        save_data(data)
        return True
    return False

# -------------------------------
# Background midnight watcher (preserve behavior)
def midnight_watcher():
    last_date = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    while True:
        try:
            now_date = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            if now_date != last_date:
                owners = set()
                for r in data.get("records", []):
                    owners.add(str(r.get("owner")))
                for d, am in data.get("active_messages", {}).items():
                    if isinstance(am, dict):
                        # old format: am -> {"chat_id":..., "message_id":...}
                        if am.get("chat_id"):
                            owners.add(str(am.get("chat_id")))
                    else:
                        # day -> { chat_id: {...} } - handle both
                        try:
                            for k in am.keys():
                                owners.add(str(k))
                        except Exception:
                            pass
                for owner in owners:
                    try:
                        update_day_window_after_change(int(owner), now_date, purpose="new_day")
                    except Exception as e:
                        print(f"[midnight_watcher] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ–∫–Ω–∞ –¥–ª—è {owner}: {e}")
                last_date = now_date
            time.sleep(30)
        except Exception as e:
            print(f"[midnight_watcher] –û—à–∏–±–∫–∞ –≤ –ø–æ—Ç–æ–∫–µ: {e}")
            time.sleep(30)

threading.Thread(target=midnight_watcher, daemon=True).start()

# -------------------------------
# Message handlers (core logic) ‚Äî main handler
@bot.message_handler(func=lambda m: True, content_types=['text','photo','document','audio','video','voice','sticker','animation','contact','location'])
def handle_any_message(message: types.Message):
    global data
    chat_id = message.chat.id
    data = load_data()  # refresh

    # 0) PM-owner forwarding: if private and from OWNER -> forward to all owner's targets (no prefix)
    handled = pm_owner_forward_block(message)
    if handled:
        return

    # 1) If there is a pending action for this chat ‚Äî handle first
    pa = pending_actions.get(str(chat_id))
    if pa:
        t = pa.get("type")
        if t == "await_modify_input":
            short = pa["payload"]["short_id"]
            ok = modify_record_by_short_id(chat_id, short, message.text or "")
            if ok:
                send_and_record(chat_id, f"‚úÖ –ó–∞–ø–∏—Å—å {short} –æ–±–Ω–æ–≤–ª–µ–Ω–∞.", purpose="modified_record")
            else:
                send_and_record(chat_id, f"‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å {short}. –ü—Ä–∏–º–µ—Ä: +1000 –∑–∞—Ä–ø–ª–∞—Ç–∞", purpose="modify_failed")
            pending_actions.pop(str(chat_id), None)
            return
        if t == "await_forward_setup":
            # accept forwarded message or text id/username
            target = None
            if getattr(message, "forward_from_chat", None):
                try:
                    target = str(message.forward_from_chat.id)
                except Exception:
                    target = None
            elif getattr(message, "forward_from", None):
                try:
                    target = str(message.forward_from.id)
                except Exception:
                    target = None
            elif message.content_type == 'text' and (message.text or "").strip():
                txt = (message.text or "").strip()
                if txt.lower() == "–æ—Ç–º–µ–Ω–∞":
                    send_and_record(chat_id, "–û—Ç–º–µ–Ω–µ–Ω–æ.", purpose="forward_setup_cancel")
                    pending_actions.pop(str(chat_id), None)
                    return
                target = txt
            if not target:
                send_and_record(chat_id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä. –û—Ç–º–µ–Ω–∞.", purpose="forward_setup_failed")
                pending_actions.pop(str(chat_id), None)
                return
            ok, msg_text, norm = validate_and_test_target(target)
            if ok:
                added = add_forward_target(chat_id, norm)
                if added:
                    send_and_record(chat_id, f"‚úÖ –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞: {norm}", purpose="forward_added")
                else:
                    send_and_record(chat_id, f"‚ÑπÔ∏è –¶–µ–ª—å —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ: {norm}", purpose="forward_exists")
            else:
                send_and_record(chat_id, f"‚ùå {msg_text}", purpose="forward_test_failed")
            pending_actions.pop(str(chat_id), None)
            return
        if t == "await_remove_forward":
            if message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() in ('–≤—Å—ë','–≤—Å–µ','all'):
                    data["forward_targets"].pop(str(chat_id), None)
                    save_data(data)
                    send_and_record(chat_id, "‚úÖ –í—Å–µ —Ü–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ —É–¥–∞–ª–µ–Ω—ã.", purpose="forward_removed_all")
                else:
                    removed = remove_forward_target(chat_id, txt)
                    if removed:
                        send_and_record(chat_id, f"‚úÖ –¶–µ–ª—å {txt} —É–¥–∞–ª–µ–Ω–∞.", purpose="forward_removed")
                    else:
                        send_and_record(chat_id, f"‚ùó –¶–µ–ª—å {txt} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", purpose="forward_remove_failed")
            else:
                send_and_record(chat_id, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥, –æ—Ç–º–µ–Ω–µ–Ω–æ.", purpose="forward_remove_failed")
            pending_actions.pop(str(chat_id), None)
            return
        # other pending actions cleared
        pending_actions.pop(str(chat_id), None)

    # 2) Automatic forward for this chat (if configured) ‚Äî preserve legacy behavior but skip forwarding bot's messages
    try:
        auto_forward_message_from(chat_id, message)
    except Exception as e:
        print(f"[auto_forward] unexpected error: {e}")
        try:
            if OWNER_ID:
                bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è auto_forward error for {chat_id}: {e}")
        except Exception:
            pass

    # 3) Remove active window for today if it belongs to this chat (so we can recreate)
    deleted = delete_active_window_if_today_and_belong(chat_id)
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")

    # 4) If text - parse for transaction(s) (per original behavior)
    if message.content_type == 'text':
        text = (message.text or "").strip()
        if not text:
            update_day_window_after_change(chat_id, today, purpose="recreated_on_empty")
            return
        lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
        any_added = False
        for line in lines:
            num, sign, raw = parse_first_number(line)
            if num is None:
                continue
            amt_signed = apply_sign_and_normalize(num, sign)
            note = line[(line.find(raw) + len(raw)):].strip() if raw in line else ""
            rec_id = data.get("next_id", 1)
            short = make_short_id(rec_id)
            ts = datetime.now(tz=ZoneInfo("UTC")).isoformat()
            rec = {
                "id": rec_id,
                "short_id": short,
                "timestamp": ts,
                "amount": amt_signed,
                "note": note,
                "owner": str(chat_id)
            }
            data.setdefault("records", []).append(rec)
            data["next_id"] = rec_id + 1
            data["overall_balance"] = data.get("overall_balance", 0) + amt_signed
            any_added = True
        if any_added:
            save_data(data)
            # update per_chat for this chat
            recalc_per_chat_for(str(chat_id))
            update_day_window_after_change(chat_id, today, purpose="added_records")
        else:
            update_day_window_after_change(chat_id, today, purpose="recreated_on_message")
    else:
        # non-text (media) received - update window
        update_day_window_after_change(chat_id, today, purpose="media_received")

# -------------------------------
# Callback handler (inline)
@bot.callback_query_handler(func=lambda call: True)
def callback_worker(call: types.CallbackQuery):
    data_local = load_data()
    data_call = call.data or ""
    chat_id = call.message.chat.id
    call_msg = call.message
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    try:
        bot.answer_callback_query(call.id)
    except Exception:
        pass

    # edit menu (show forward button only in private chat)
    if data_call == "edit_menu":
        try:
            is_private = (call.message.chat.type == "private")
        except Exception:
            is_private = False
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id, is_private=is_private))
        except Exception:
            send_and_record(chat_id, "–ú–µ–Ω—é —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:", reply_markup=kb_edit_main(chat_id, is_private=is_private), purpose="edit_menu_fallback")
        return

    if data_call == "edit_cancel":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_day_main())
        except Exception:
            send_and_record(chat_id, build_day_window(chat_id, today), reply_markup=kb_day_main(), purpose="day_window_fallback")
        return

    if data_call == "edit_modify":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_records_list(chat_id, today, mode="modify"))
        except Exception:
            send_and_record(chat_id, "–í—ã–±–æ—Ä –∑–∞–ø–∏—Å–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:", reply_markup=kb_records_list(chat_id, today, mode="modify"), purpose="modify_list_fallback")
        return

    if data_call == "edit_delete":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_records_list(chat_id, today, mode="delete"))
        except Exception:
            send_and_record(chat_id, "–í—ã–±–æ—Ä –∑–∞–ø–∏—Å–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb_records_list(chat_id, today, mode="delete"), purpose="delete_list_fallback")
        return

    if data_call in ("edit_export_csv","edit_export_csv_alt"):
        try:
            path = export_all_to_csv(CSV_FILE)
            send_file_and_record(chat_id, path, caption="–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π (CSV)", purpose="export_csv")
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id, is_private=(call_msg.chat.type=="private")))
            except Exception:
                pass
        except Exception as e:
            print(f"[callback export_csv] {e}")
            send_and_record(chat_id, "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ CSV.", purpose="export_error")
        return

    if data_call == "forward_setup":
        # forward setup allowed only in private ‚Äî but callback could be triggered from group if markup shown; double-check
        if call_msg.chat.type != "private":
            send_and_record(chat_id, "‚ö†Ô∏è –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –ª–∏—á–∫–µ.", purpose="forward_setup_denied")
            return
        send_and_record(chat_id, "–ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ü–µ–ª–µ–≤–æ–≥–æ —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ chat_id/@username. –û—Ç–ø—Ä–∞–≤—å—Ç–µ '–æ—Ç–º–µ–Ω–∞' —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å.", purpose="await_forward_input")
        pending_actions[str(chat_id)] = {"type": "await_forward_setup", "payload": {}}
        return

    if data_call == "forward_add":
        if call_msg.chat.type != "private":
            send_and_record(chat_id, "‚ö†Ô∏è –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –ª–∏—á–∫–µ.", purpose="forward_setup_denied")
            return
        send_and_record(chat_id, "–ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ü–µ–ª–µ–≤–æ–≥–æ —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ chat_id/@username.", purpose="await_forward_input")
        pending_actions[str(chat_id)] = {"type": "await_forward_setup", "payload": {}}
        return

    if data_call == "forward_remove":
        if call_msg.chat.type != "private":
            send_and_record(chat_id, "‚ö†Ô∏è –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –ª–∏—á–∫–µ.", purpose="forward_setup_denied")
            return
        lst = list_forward_targets(chat_id)
        if not lst:
            send_and_record(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.", purpose="forward_remove_noop")
            return
        send_and_record(chat_id, "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–æ—á–Ω—É—é —Ü–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞, –∏–ª–∏ '–≤—Å—ë' –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤—Å–µ—Ö.", purpose="await_remove_forward")
        pending_actions[str(chat_id)] = {"type": "await_remove_forward", "payload": {}}
        return

    if data_call == "forward_cancel":
        ft = data.get("forward_targets", {})
        if str(chat_id) in ft:
            ft.pop(str(chat_id), None)
            data["forward_targets"] = ft
            save_data(data)
            send_and_record(chat_id, "‚úÖ –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞.", purpose="forward_cancelled")
        else:
            send_and_record(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –±—ã–ª–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.", purpose="forward_cancel_noop")
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id, is_private=(call_msg.chat.type=="private")))
        except Exception:
            pass
        return

    if data_call == "forward_check":
        ft = data.get("forward_targets", {}).get(str(chat_id))
        if ft:
            send_and_record(chat_id, f"üì® –¢–µ–∫—É—â–∏–µ —Ü–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏:\n{ft}", purpose="forward_check_resp")
        else:
            send_and_record(chat_id, "üîï –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.", purpose="forward_check_resp")
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id, is_private=(call_msg.chat.type=="private")))
        except Exception:
            pass
        return

    if data_call.startswith("select:"):
        parts = data_call.split(":", 2)
        if len(parts) != 3:
            send_and_record(chat_id, "–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä.", purpose="select_error")
            return
        mode = parts[1]
        short_id = parts[2]
        if mode == "modify":
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=None)
            except Exception:
                pass
            send_and_record(chat_id, f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è {short_id} (–ø—Ä–∏–º–µ—Ä: +1000 –∑–∞—Ä–ø–ª–∞—Ç–∞).", purpose="await_modify_input")
            pending_actions[str(chat_id)] = {"type": "await_modify_input", "payload": {"short_id": short_id}}
            return
        elif mode == "delete":
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_yes_no(f"confirm_delete:{short_id}"))
            except Exception:
                send_and_record(chat_id, f"–£–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å {short_id}?", reply_markup=kb_yes_no(f"confirm_delete:{short_id}"), purpose="delete_confirm_fallback")
            return
        else:
            send_and_record(chat_id, "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞.", purpose="select_badmode")
            return

    if data_call.startswith("confirm_delete:"):
        tail = data_call[len("confirm_delete:"):]
        if tail.endswith("_yes"):
            short_id = tail[:-4]
            ok = delete_record_by_short_id(chat_id, short_id)
            if ok:
                try:
                    bot.edit_message_text(f"‚úÖ –ó–∞–ø–∏—Å—å {short_id} —É–¥–∞–ª–µ–Ω–∞.", call_msg.chat.id, call_msg.message_id)
                except Exception:
                    send_and_record(chat_id, f"‚úÖ –ó–∞–ø–∏—Å—å {short_id} —É–¥–∞–ª–µ–Ω–∞.", purpose="deleted_record")
            else:
                try:
                    bot.edit_message_text(f"‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å {short_id}.", call_msg.chat.id, call_msg.message_id)
                except Exception:
                    send_and_record(chat_id, f"‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å {short_id}.", purpose="delete_failed")
        else:
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id, is_private=(call_msg.chat.type=="private")))
            except Exception:
                send_and_record(chat_id, "–£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=kb_edit_main(chat_id, is_private=(call_msg.chat.type=="private")), purpose="delete_cancelled")
        return

    if data_call == "edit_reset_all":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_yes_no("confirm_reset_all"))
        except Exception:
            send_and_record(chat_id, "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω—É–ª–∏—Ç—å –í–°–ï –¥–∞–Ω–Ω—ã–µ –Ω–∞–≤—Å–µ–≥–¥–∞? (–î–∞/–ù–µ—Ç)", reply_markup=kb_yes_no("confirm_reset_all"), purpose="reset_confirm_fallback")
        return

    if data_call.startswith("confirm_reset_all"):
        if data_call.endswith("_yes"):
            data["overall_balance"] = 0
            data["records"] = []
            data["active_messages"] = {}
            data["per_chat"] = {}
            save_data(data)
            try:
                bot.edit_message_text("‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –¥–µ–Ω—å.", call_msg.chat.id, call_msg.message_id)
            except Exception:
                send_and_record(chat_id, "‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –¥–µ–Ω—å.", purpose="reset_done")
        else:
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id, is_private=(call_msg.chat.type=="private")))
            except Exception:
                send_and_record(chat_id, "–û–±–Ω—É–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=kb_edit_main(chat_id, is_private=(call_msg.chat.type=="private")), purpose="reset_cancel")
        return

    if data_call in ("no_op",):
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_day_main())
        except Exception:
            send_and_record(chat_id, build_day_window(chat_id, today), reply_markup=kb_day_main(), purpose="no_op_fallback")
        return

    print("[callback] Unhandled callback:", data_call)

# -------------------------------
# Commands: /–±–∞–ª–∞–Ω—Å /–æ—Ç—á–µ—Ç /—Å–±—Ä–æ—Å (public)
@bot.message_handler(commands=["–±–∞–ª–∞–Ω—Å"])
def cmd_balance(message: types.Message):
    chat_id = message.chat.id
    per = data.get("per_chat", {}).get(str(chat_id))
    if per:
        bot.reply_to(message, f"üí∞ –ë–∞–ª–∞–Ω—Å —ç—Ç–æ–≥–æ —á–∞—Ç–∞: {fmt_amount(per.get('balance', 0))}")
    else:
        overall = data.get("overall_balance", 0)
        bot.reply_to(message, f"üí∞ –¢–µ–∫—É—â–∏–π –æ–±—â–∏–π –±–∞–ª–∞–Ω—Å: {fmt_amount(overall)}")

@bot.message_handler(commands=["–æ—Ç—á–µ—Ç"])
def cmd_report(message: types.Message):
    chat_id = message.chat.id
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    update_day_window_after_change(chat_id, today, purpose="report_cmd")

@bot.message_handler(commands=["—Å–±—Ä–æ—Å"])
def cmd_reset(message: types.Message):
    chat_id = message.chat.id
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return
    kb = kb_yes_no("confirm_reset_all")
    send_and_record(chat_id, "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω—É–ª–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ? (–î–∞/–ù–µ—Ç)", reply_markup=kb, purpose="reset_command")

# -------------------------------
# Admin commands for forward management (text commands) - only owner allowed
@bot.message_handler(commands=['addforward'])
def cmd_addforward_text(message: types.Message):
    chat_id = message.chat.id
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.")
        return
    send_and_record(chat_id, "–ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å—é–¥–∞ –ª—é–±–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ü–µ–ª–µ–≤–æ–≥–æ —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞/–≥—Ä—É–ø–ø—ã –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ chat_id/@username. –û—Ç–ø—Ä–∞–≤—å—Ç–µ '–æ—Ç–º–µ–Ω–∞' –¥–ª—è –æ—Ç–º–µ–Ω—ã.", purpose="await_forward_input_cmd")
    pending_actions[str(chat_id)] = {"type": "await_forward_setup", "payload": {}}

@bot.message_handler(commands=['removeforward'])
def cmd_removeforward_text(message: types.Message):
    chat_id = message.chat.id
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.")
        return
    lst = list_forward_targets(chat_id)
    if not lst:
        send_and_record(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –≤ —ç—Ç–æ–º —á–∞—Ç–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.", purpose="remove_forward_noop")
        return
    send_and_record(chat_id, "–°–ø–∏—Å–æ–∫ —Ç–µ–∫—É—â–∏—Ö —Ü–µ–ª–µ–π:\n" + "\n".join(lst) + "\n\n–û—Ç–ø—Ä–∞–≤—å —Ç–æ—á–Ω—É—é —Ü–µ–ª—å —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å, –∏–ª–∏ '–≤—Å—ë' —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å –≤—Å–µ.", purpose="await_remove_forward")
    pending_actions[str(chat_id)] = {"type": "await_remove_forward", "payload": {}}

@bot.message_handler(commands=['listforwards'])
def cmd_listforwards_text(message: types.Message):
    chat_id = message.chat.id
    lst = list_forward_targets(chat_id)
    if not lst:
        send_and_record(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞ –¥–ª—è —ç—Ç–æ–≥–æ —á–∞—Ç–∞.", purpose="list_forwards_empty")
    else:
        send_and_record(chat_id, "–¢–µ–∫—É—â–∏–µ —Ü–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏:\n" + "\n".join(lst), purpose="list_forwards")

# -------------------------------
# Webhook endpoints for Flask (Render-friendly)
@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    try:
        json_str = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
    except Exception as e:
        print(f"[webhook] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ update: {e}")
    return '', 200

@app.route("/", methods=['GET'])
def index():
    return f"ü§ñ –ë–æ—Ç '–§–û' –≤–µ—Ä—Å–∏—è {VERSION} –∑–∞–ø—É—â–µ–Ω."

# -------------------------------
# Startup: set webhook if RENDER_EXTERNAL_HOSTNAME exists, notify owner
def set_webhook_if_possible():
    try:
        host = os.getenv("RENDER_EXTERNAL_HOSTNAME")
        if host:
            url = f"https://{host}{WEBHOOK_PATH}"
            bot.remove_webhook()
            time.sleep(0.5)
            bot.set_webhook(url=url)
            print(f"[startup] Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {url}")
            if OWNER_ID:
                try:
                    msg = bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION}: webhook –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.")
                    delayed_delete(int(OWNER_ID), msg.message_id, delay=5)
                    record_sent_message({"chat_id": int(OWNER_ID), "message_id": int(msg.message_id), "timestamp": now_iso_utc(), "purpose": "owner_ping"})
                except Exception as e:
                    print(f"[startup notify] –û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–ª–∞–¥–µ–ª—å—Ü–∞: {e}")
    except Exception as e:
        print(f"[set_webhook_if_possible] {e}")

# -------------------------------
if __name__ == "__main__":
    print(f"–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ '–§–û' v{VERSION} ...")
    save_data(data)
    # recalc per_chat for consistency on startup
    try:
        recalc_all_per_chat()
    except Exception:
        pass
    set_webhook_if_possible()
    # notify owner
    if OWNER_ID:
        try:
            msg = bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION} –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤.")
            delayed_delete(int(OWNER_ID), msg.message_id, delay=5)
            record_sent_message({"chat_id": int(OWNER_ID), "message_id": int(msg.message_id), "timestamp": now_iso_utc(), "purpose": "owner_start"})
        except Exception as e:
            print(f"[startup] –û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–ª–∞–¥–µ–ª—å—Ü–∞: {e}")
    app.run(host="0.0.0.0", port=PORT)

# -------------------------------
# EOF
# -------------------------------