# ============================================
# Финансовый бот — версия 9.6.1.6
# Полная версия
# Примечание: интерфейс на русском, команды латиницей.
# ОТСЕКИ пронумерованы в заголовках.
# ============================================



# -----------------------------
# ОТСЕК 1 — Импорты и настройки
# -----------------------------
import os
import json
import csv              # ✅ добавлен явный импорт CSV
import logging
import requests
import re
from datetime import datetime
from zoneinfo import ZoneInfo

import telebot
from flask import Flask, request
from telebot import types

# --------------------------------------------
# Настройки окружения и константы
# --------------------------------------------
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")  # строка или число
APP_URL = os.getenv("APP_URL", "https://fo-1.onrender.com")  # URL приложения для webhook
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
LOG_FILE = "log.txt"
PORT = int(os.environ.get("PORT", 5000))
VERSION = "9.6.1.7"

if not TOKEN:
    raise ValueError("BOT_TOKEN не установлен в переменных окружения!")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

log_info = logging.info
log_error = logging.error

# --------------------------------------------
# Настройки окружения и константы
# --------------------------------------------
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")  # строка или число
APP_URL = os.getenv("APP_URL", "https://fo-1.onrender.com")  # URL приложения, используется для webhook
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
LOG_FILE = "log.txt"
PORT = int(os.environ.get("PORT", 5000))
VERSION = "9.6.1.6"

if not TOKEN:
    raise ValueError("BOT_TOKEN не установлен в переменных окружения!")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# --------------------------------------------
# ОТСЕК 2 — Логирование
# --------------------------------------------
logging.basicConfig(
    level=logging.INFO,
    format="[{asctime}] {levelname}: {message}",
    style="{",
    handlers=[
        logging.FileHandler(LOG_FILE, encoding="utf-8"),
        logging.StreamHandler()
    ]
)

def log_info(msg):
    logging.info(msg)

def log_error(msg):
    logging.error(msg)

log_info(f"Старт приложения. Версия {VERSION}")

# --------------------------------------------
# ОТСЕК 3 — Структура данных и работа с файлом (с дневным учётом)
# --------------------------------------------
from datetime import datetime
from zoneinfo import ZoneInfo

TZ = ZoneInfo("America/Argentina/Catamarca")

def default_data():
    return {
        "chats": {},                # chat_id -> { balance, records:[], next_id, daily_records:{} }
        "forward_targets": [],      # список chat_id (int)
        "tracked_messages": {},     # chat_id -> {user_id: state}
        "processed_messages": []    # предотвращение дублей пересылки
    }

def get_today_key():
    """Возвращает ключ текущего дня в формате YYYY-MM-DD (локально для Аргентины)."""
    return datetime.now(TZ).strftime("%Y-%m-%d")

def load_data():
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            log_error(f"Ошибка загрузки data.json: {e}")
            d = default_data()
    else:
        d = default_data()
    # гарантируем наличие ключей
    for k, v in default_data().items():
        if k not in d:
            d[k] = v
    return d

def save_data(d):
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        log_error(f"Ошибка сохранения data.json: {e}")

def get_chat_store(chat_id):
    """Гарантирует наличие структуры для чата, включая дневной раздел."""
    cid = str(chat_id)
    store = data["chats"].setdefault(cid, {"balance": 0, "records": [], "next_id": 1, "daily_records": {}})
    if "daily_records" not in store:
        store["daily_records"] = {}
    return store

def add_record_to_chat(chat_id, amount, note, owner):
    """Добавление записи и в общий список, и в дневной раздел."""
    store = get_chat_store(chat_id)
    rid = store.get("next_id", 1)
    today_key = get_today_key()
    record = {
        "id": rid,
        "short_id": f"R{rid}",
        "timestamp": datetime.now(TZ).isoformat(timespec="seconds"),
        "amount": amount,
        "note": note,
        "owner": owner
    }
    # общий список
    store["records"].append(record)
    # дневной список
    day_list = store["daily_records"].setdefault(today_key, [])
    day_list.append(record)
    # баланс
    store["balance"] += amount
    store["next_id"] = rid + 1
    save_data(data)
    return record

def get_daily_records(chat_id, day_key=None):
    """Возвращает записи за конкретный день или за сегодня."""
    store = get_chat_store(chat_id)
    if day_key is None:
        day_key = get_today_key()
    return store["daily_records"].get(day_key, [])

def update_record_in_chat(chat_id, rid, amount, note):
    """Редактирует запись в общем и дневном списках."""
    store = get_chat_store(chat_id)
    found = None
    for r in store["records"]:
        if r["id"] == rid:
            diff = amount - r["amount"]
            r["amount"] = amount
            r["note"] = note
            store["balance"] += diff
            found = r
            break
    if found:
        # обновляем дневной список, если есть
        for recs in store.get("daily_records", {}).values():
            for r in recs:
                if r["id"] == rid:
                    r.update(found)
        save_data(data)
        return True, found
    return False, None

def delete_record_in_chat(chat_id, rid):
    """Удаление записи в общем и дневном списках."""
    store = get_chat_store(chat_id)
    removed = None
    for r in list(store["records"]):
        if r["id"] == rid:
            store["records"].remove(r)
            store["balance"] -= r["amount"]
            removed = r
            break
    if removed:
        for recs in store.get("daily_records", {}).values():
            recs[:] = [r for r in recs if r["id"] != rid]
        save_data(data)
        return True, removed
    return False, None

def export_to_csv(d):
    """Экспорт всех операций (включая дневные)."""
    try:
        with open(CSV_FILE, "w", newline='', encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["chat_id","ID","short_id","timestamp","amount","note","owner","day_key"])
            for cid, cdata in d.get("chats", {}).items():
                for day_key, records in cdata.get("daily_records", {}).items():
                    for r in records:
                        writer.writerow([cid, r.get("id"), r.get("short_id"), r.get("timestamp"), r.get("amount"), r.get("note"), r.get("owner"), day_key])
    except Exception as e:
        log_error(f"Ошибка экспорта CSV: {e}")

data = load_data()

# если OWNER_ID задан — убедимся, что он есть среди forward_targets
if OWNER_ID:
    try:
        owner_int = int(OWNER_ID)
    except Exception:
        owner_int = None
    if owner_int is not None and owner_int not in data["forward_targets"]:
        data["forward_targets"].append(owner_int)
        save_data(data)

# --------------------------------------------
# ОТСЕК 4 — Вспомогательные функции (парсинг, чат-менеджмент)
# --------------------------------------------
# Разбор первой найденной цифры в строке (с учётом знаков и пробелов)
num_re = re.compile(r'([+-]?\s*\d+)')

def extract_first_number(s):
    """
    Ищет первое вхождение числа в строке. Возвращает (amount:int, raw_token:str) или (None, None)
    Правила:
    - допускается пробел между знаком и цифрой: "+ 100" или "-  50"
    - возвращаемое число учитывает знак
    """
    if not s:
        return None, None
    m = num_re.search(s)
    if not m:
        return None, None
    token = m.group(1)
    # удаляем пробелы внутри токена
    token_clean = token.replace(" ", "")
    try:
        amt = int(token_clean)
    except Exception:
        return None, None
    return amt, token.strip()

def get_chat_store(chat_id):
    """Возвращает или инициализирует структуру данных для чата"""
    chat_id = str(chat_id)
    if chat_id not in data["chats"]:
        data["chats"][chat_id] = {
            "balance": 0,
            "records": [],
            "next_id": 1
        }
        save_data(data)
    return data["chats"][chat_id]

def add_record_to_chat(chat_id, amount, note, owner):
    store = get_chat_store(chat_id)
    ts = datetime.now(TZ).isoformat()
    rid = store.get("next_id", 1)
    rec = {
        "id": rid,
        "short_id": f"R{rid}",
        "timestamp": ts,
        "amount": amount,
        "note": note,
        "owner": owner
    }
    store.setdefault("records", []).append(rec)
    store["balance"] = store.get("balance", 0) + amount
    store["next_id"] = rid + 1
    save_data(data)
    export_to_csv(data)
    if amount >= 0:
        log_info(f"[CHAT {chat_id}] ПРИХОД: +{amount} {note}")
    else:
        log_info(f"[CHAT {chat_id}] РАСХОД: {amount} {note}")
    return rec

def delete_record_in_chat(chat_id, rec_id):
    store = get_chat_store(chat_id)
    recs = store.get("records", [])
    to_del = None
    for r in recs:
        if r["id"] == rec_id or str(r["id"]) == str(rec_id) or r["short_id"] == f"R{rec_id}":
            to_del = r
            break
    if not to_del:
        return False, None
    recs.remove(to_del)
    store["balance"] = sum([r["amount"] for r in recs])
    save_data(data)
    export_to_csv(data)
    return True, to_del

def update_record_in_chat(chat_id, rec_id, new_amount, new_note):
    store = get_chat_store(chat_id)
    recs = store.get("records", [])
    found = None
    for r in recs:
        if r["id"] == rec_id or str(r["id"]) == str(rec_id) or r["short_id"] == f"R{rec_id}":
            found = r
            break
    if not found:
        return False, None
    found["amount"] = new_amount
    found["note"] = new_note
    # recompute balance
    store["balance"] = sum([r["amount"] for r in recs])
    save_data(data)
    export_to_csv(data)
    return True, found

# --------------------------------------------
# ОТСЕК 5 — Клавиатуры и кнопки (обновлённый)
# --------------------------------------------
from telebot import types

def build_main_keyboard(chat_id=None):
    """
    Главное меню (компактное, в одну строку),
    с кнопками и отображением текущего баланса.
    """
    kb = types.InlineKeyboardMarkup(row_width=2)
    kb.add(
        types.InlineKeyboardButton("💰 Баланс", callback_data="btn_balance"),
        types.InlineKeyboardButton("📊 Отчёт", callback_data="btn_report"),
    )
    kb.add(
        types.InlineKeyboardButton("✏️ Редактировать", callback_data="btn_edit"),
        types.InlineKeyboardButton("⚙️ Сброс", callback_data="btn_reset"),
    )
    kb.add(
        types.InlineKeyboardButton("🚀 Старт", callback_data="btn_start"),
        types.InlineKeyboardButton("📘 О коде", callback_data="btn_cod"),
    )

    # --- нижняя строка с балансом ---
    balance_text = ""
    if chat_id is not None:
        store = get_chat_store(chat_id)
        balance_text = f"💰 {store.get('balance', 0)} ARS"
    kb.add(types.InlineKeyboardButton(balance_text or "💰 0 ARS", callback_data="noop"))
    return kb


def build_edit_list_keyboard(chat_id):
    """
    Список транзакций с маленькими кнопками ✏ и 🗑
    (в одну строку, компактно).
    """
    store = get_chat_store(chat_id)
    kb = types.InlineKeyboardMarkup()
    records = store.get("records", [])[-20:]
    if not records:
        kb.add(types.InlineKeyboardButton("Нет записей", callback_data="noop"))
        kb.add(types.InlineKeyboardButton("⬅️ Назад", callback_data="btn_start"))
        return kb

    for r in records:
        sign = "+" if r["amount"] > 0 else ""
        label = f"{r['short_id']}: {sign}{r['amount']} ARS {r.get('note','')}"
        # небольшие кнопки по ширине
        kb.row(
            types.InlineKeyboardButton(label, callback_data=f"noop_row:{r['id']}"),
            types.InlineKeyboardButton("✏", callback_data=f"edit_select:{r['id']}"),
            types.InlineKeyboardButton("🗑", callback_data=f"delete_record:{r['id']}")
        )

    # кнопка "назад" в конце
    kb.add(types.InlineKeyboardButton("⬅️ Назад", callback_data="btn_start"))
    return kb

# 6--------------------------------------------
# ОТСЕК 6 — Команды (основные)
# --------------------------------------------
@bot.message_handler(commands=["start"])
def cmd_start(msg):
    text = (
        "👋 Добро пожаловать в Финансовый бот «ФО»\n\n"
        "Команды (латиницей):\n"
        "/start – показать справку\n"
        "/myid – показать ваш user ID\n"
        "/chatid – показать ID чата\n"
        "/balance – показать текущий баланс (для текущего чата)\n"
        "/report – показать последние операции (для текущего чата)\n"
        "/reset – обнулить все данные (только владелец)\n"
        "/addforward <chat_id> – добавить цель для пересылки (только владелец)\n"
        "/removeforward <chat_id> – убрать цель пересылки (только владелец)\n"
        "/listforwards – список целей пересылки\n"
        "/cod – информация о версии и обновлениях\n"
        "/edit – редактирование транзакций (список и выбор)\n"
        "/delete <номер> – удалить запись по номеру\n\n"
        "Для записи транзакции отправьте одну или несколько строк, каждая строка отдельный учёт.\n"
        "Примеры:\n+1000 зарплата\n-123 хлеб\n200 сок\n"
    )
    bot.send_message(msg.chat.id, f"💬 Версия: {VERSION}\n\n{text}", reply_markup=build_main_keyboard())

@bot.message_handler(commands=["myid"])
def cmd_myid(msg):
    uid = msg.from_user.id
    bot.reply_to(msg, f"🆔 Ваш user ID: {uid}")

@bot.message_handler(commands=["chatid"])
def cmd_chatid(msg):
    cid = msg.chat.id
    bot.reply_to(msg, f"💬 ID текущего чата: {cid}")

@bot.message_handler(commands=["balance"])
def cmd_balance(msg):
    store = get_chat_store(msg.chat.id)
    bot.reply_to(msg, f"💰 Баланс этого чата: {store.get('balance',0)} ars", reply_markup=build_main_keyboard())

@bot.message_handler(commands=["report"])
def cmd_report(msg):
    store = get_chat_store(msg.chat.id)
    recs = store.get("records", [])
    if not recs:
        bot.send_message(msg.chat.id, "Пока нет операций в этом чате.", reply_markup=build_main_keyboard())
        return
    text_lines = ["📋 Последние операции этого чата:"]
    for r in recs[-50:]:
        sign = "+" if r["amount"] > 0 else ""
        text_lines.append(f"{r['short_id']}: {sign}{r['amount']} — {r.get('note','')}")
    bot.send_message(msg.chat.id, "\n".join(text_lines), reply_markup=build_main_keyboard())

@bot.message_handler(commands=["reset"])
def cmd_reset(msg):
    if OWNER_ID is None or str(msg.from_user.id) != str(OWNER_ID):
        bot.send_message(msg.chat.id, "Только владелец может сбрасывать данные.", reply_markup=build_main_keyboard())
        return
    global data
    data = default_data()
    try:
        if OWNER_ID:
            data["forward_targets"].append(int(OWNER_ID))
    except Exception:
        pass
    save_data(data)
    export_to_csv(data)
    bot.send_message(msg.chat.id, "✅ Все данные сброшены.", reply_markup=build_main_keyboard())
    log_info("ДАННЫЕ ОБНУЛЕНЫ владельцем")

@bot.message_handler(commands=["addforward"])
def cmd_addforward(msg):
    if OWNER_ID is None or str(msg.from_user.id) != str(OWNER_ID):
        return
    parts = msg.text.split()
    if len(parts) < 2:
        bot.reply_to(msg, "Использование: /addforward <chat_id>")
        return
    try:
        cid = int(parts[1])
    except Exception:
        bot.reply_to(msg, "Неверный chat_id (должно быть число).")
        return
    if cid in data["forward_targets"]:
        bot.reply_to(msg, "Этот чат уже в списке пересылки.")
        return
    data["forward_targets"].append(cid)
    save_data(data)
    bot.reply_to(msg, f"✅ Цель пересылки добавлена: {cid}")

@bot.message_handler(commands=["removeforward"])
def cmd_removeforward(msg):
    if OWNER_ID is None or str(msg.from_user.id) != str(OWNER_ID):
        return
    parts = msg.text.split()
    if len(parts) < 2:
        bot.reply_to(msg, "Использование: /removeforward <chat_id>")
        return
    try:
        cid = int(parts[1])
    except Exception:
        bot.reply_to(msg, "Неверный chat_id (должно быть число).")
        return
    if cid not in data["forward_targets"]:
        bot.reply_to(msg, "Этот чат не в списке пересылки.")
        return
    data["forward_targets"].remove(cid)
    save_data(data)
    bot.reply_to(msg, f"✅ Цель пересылки удалена: {cid}")

@bot.message_handler(commands=["listforwards"])
def cmd_listforwards(msg):
    if not data["forward_targets"]:
        bot.reply_to(msg, "Список пересылки пуст.", reply_markup=build_main_keyboard())
        return
    text = "📨 Цели пересылки:\n" + "\n".join(map(str, data["forward_targets"]))
    bot.reply_to(msg, text, reply_markup=build_main_keyboard())

@bot.message_handler(commands=["cod"])
def cmd_cod(msg):
    text = (
        f"📘 Информация о коде — версия {VERSION}\n\n"
        "Краткое структурное описание:\n"
        "- Интерфейс полностью на русском языке\n"
        "- Команды остаются на латинице\n"
        "- Добавлены inline-кнопки для быстрого доступа\n"
        "- Автоматическая установка webhook при запуске\n"
        "- Пересылка сообщений от владельца в указанные чаты (без эха)\n"
        "- Отдельный учёт по каждому чату\n"
        "- Редактирование записей через /edit и /delete\n"
        "- Каждая строка сообщения = отдельная запись\n\n"
        "Последнее обновление: добавлена версия 9.6.1.6 — сегментированный учёт, улучшенная пересылка, редактирование."
    )
    bot.send_message(msg.chat.id, text, reply_markup=build_main_keyboard())

@bot.message_handler(commands=["edit"])
def cmd_edit(msg):
    kb = build_edit_list_keyboard(msg.chat.id)
    if not kb.keyboard:
        bot.reply_to(msg, "Нет записей для редактирования в этом чате.", reply_markup=build_main_keyboard())
        return
    bot.send_message(msg.chat.id, "Выберите запись для редактирования:", reply_markup=kb)

@bot.message_handler(commands=["delete"])
def cmd_delete(msg):
    parts = msg.text.split()
    if len(parts) < 2:
        bot.reply_to(msg, "Использование: /delete <номер или Rномер>")
        return
    token = parts[1].strip()
    if token.upper().startswith("R"):
        token = token[1:]
    try:
        rid = int(token)
    except Exception:
        bot.reply_to(msg, "Неверный номер записи.")
        return
    ok, rec = delete_record_in_chat(msg.chat.id, rid)
    if ok:
        bot.reply_to(msg, f"✅ Запись R{rid} удалена. Баланс обновлён: {get_chat_store(msg.chat.id).get('balance',0)} ars", reply_markup=build_main_keyboard())
    else:
        bot.reply_to(msg, "Запись не найдена.", reply_markup=build_main_keyboard())


# --------------------------------------------
# ОТСЕК 7 — Обработка callback'ов (в одном окне, с кнопкой Назад)
# --------------------------------------------
@bot.callback_query_handler(func=lambda c: True)
def handle_callback(call):
    try:
        data_cd = call.data
        cid = call.message.chat.id
        mid = call.message.message_id

        # --- 💰 Баланс ---
        if data_cd == "btn_balance":
            store = get_chat_store(cid)
            text = f"💰 Текущий баланс этого чата: {store.get('balance', 0)} ARS"
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- 📊 Отчёт ---
        elif data_cd == "btn_report":
            recs = get_chat_store(cid).get("records", [])
            if not recs:
                text = "📋 Пока нет операций."
            else:
                text_lines = ["📋 Последние операции:"]
                for r in recs[-20:]:
                    sign = "+" if r["amount"] > 0 else ""
                    text_lines.append(f"{r['short_id']}: {sign}{r['amount']} ARS — {r.get('note','')}")
                text = "\n".join(text_lines)
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- ⚙️ Сброс ---
        elif data_cd == "btn_reset":
            if str(call.from_user.id) != str(OWNER_ID):
                bot.answer_callback_query(call.id, text="Только владелец может сбрасывать данные.")
                return
            chat_store = data["chats"].get(str(cid))
            if chat_store:
                chat_store["records"] = []
                chat_store["balance"] = 0
                chat_store["daily_records"] = {}
                chat_store["next_id"] = 1
            save_data(data)
            text = "✅ Все данные этого чата сброшены."
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- ✏️ Редактировать ---
        elif data_cd == "btn_edit":
            kb = build_edit_list_keyboard(cid)
            text = "Выберите запись для редактирования или удаления:"
            bot.edit_message_text(text, cid, mid, reply_markup=kb)
            bot.answer_callback_query(call.id)

        # --- 🚀 Старт ---
        elif data_cd == "btn_start":
            text = "Главное меню — выберите действие:"
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- 📘 О коде ---
        elif data_cd == "btn_cod":
            info_text = (
                "🤖 Финансовый бот — версия 9.8.X (дневной учёт)\n\n"
                "📂 Возможности:\n"
                "• Учёт по дням (новые сутки — новое окно)\n"
                "• Общий баланс сохраняется\n"
                "• Удобное редактирование и удаление записей\n"
                "• Все действия в одном окне\n\n"
                "🔄 Обновление: добавлен дневной учёт и баланс на клавиатуре."
            )
            bot.edit_message_text(info_text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- ✏ Выбор для редактирования ---
        elif data_cd.startswith("edit_select:"):
            rid = int(data_cd.split(":")[1])
            chat_state = data.setdefault("tracked_messages", {})
            chat_key = str(cid)
            user_states = chat_state.setdefault(chat_key, {})
            user_states[str(call.from_user.id)] = {
                "action": "edit_wait_value",
                "rid": rid,
                "msg_id": mid
            }
            save_data(data)
            text = f"Введите новое значение для R{rid} (например: +500 продажа)"
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- 🗑 Удаление записи ---
        elif data_cd.startswith("delete_record:"):
            rid = int(data_cd.split(":")[1])
            ok, rec = delete_record_in_chat(cid, rid)
            if ok:
                text = f"✅ Запись R{rid} удалена.\n💰 Баланс обновлён: {get_chat_store(cid).get('balance', 0)} ARS"
            else:
                text = "⚠️ Запись не найдена."
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- ⬅️ Назад (универсальная кнопка) ---
        elif data_cd in ("btn_back", "noop"):
            bot.edit_message_reply_markup(cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        else:
            bot.answer_callback_query(call.id)

    except Exception as e:
        log_error(f"Ошибка обработки callback: {e}")

# --------------------------------------------
# ОТСЕК 8 — Обработка входящих сообщений и пересылка (с дневным учётом)
# --------------------------------------------
@bot.message_handler(func=lambda m: True, content_types=[
    "text", "photo", "document", "voice", "video", "audio", "sticker"
])
def handle_message(msg):
    # --- 1. Фильтры системных сообщений ---
    if not getattr(msg, "from_user", None) or msg.from_user.is_bot:
        return

    chat_id = msg.chat.id
    user_id = msg.from_user.id
    today_key = get_today_key()

    # --- 2. Проверка состояния редактирования ---
    chat_key = str(chat_id)
    user_states = data.setdefault("tracked_messages", {}).get(chat_key, {})
    state = user_states.get(str(user_id))
    if state and state.get("action") == "edit_wait_value":
        rid = state.get("rid")
        target_msg_id = state.get("msg_id", msg.message_id)
        lines = msg.text.splitlines() if msg.content_type == "text" and msg.text else []
        if not lines:
            bot.edit_message_text(
                "Введите строку с числом, пример: +500 продажа.",
                chat_id, target_msg_id,
                reply_markup=build_main_keyboard()
            )
            return
        first_line = lines[0].strip()
        amt, token = extract_first_number(first_line)
        if amt is None:
            bot.edit_message_text(
                "Число не обнаружено. Попробуйте ещё раз.",
                chat_id, target_msg_id,
                reply_markup=build_main_keyboard()
            )
            return
        m = num_re.search(first_line)
        note = first_line[m.end():].strip() if m else ""
        raw_token = token
        if raw_token.lstrip().startswith("+"):
            final_amt = amt
        elif raw_token.lstrip().startswith("-"):
            final_amt = amt
        else:
            final_amt = -abs(amt)
        ok, updated = update_record_in_chat(chat_id, rid, final_amt, note)
        user_states.pop(str(user_id), None)
        save_data(data)
        if ok:
            bot.edit_message_text(
                f"✅ Запись R{rid} обновлена: {updated['amount']} ARS — {updated.get('note','')}\n"
                f"💰 Баланс: {get_chat_store(chat_id).get('balance',0)} ARS",
                chat_id, target_msg_id, reply_markup=build_main_keyboard()
            )
        else:
            bot.edit_message_text(
                "Запись не найдена.", chat_id, target_msg_id, reply_markup=build_main_keyboard()
            )
        return

    # --- 3. Предотвращение дублей ---
    processed = data.setdefault("processed_messages", [])
    msg_key = f"{chat_id}:{msg.message_id}"
    if msg_key in processed:
        return
    processed.append(msg_key)
    if len(processed) > 1000:
        processed = processed[-500:]
    data["processed_messages"] = processed
    save_data(data)

    # --- 4. Определяем владельца ---
    owner_int = None
    if OWNER_ID:
        try:
            owner_int = int(OWNER_ID)
        except Exception:
            owner_int = None
    is_owner_msg = owner_int and user_id == owner_int

    # --- 5. Универсальная функция обработки строк ---
    def process_lines_and_record(lines_list, target_chat):
        added_any = False
        for line in lines_list:
            line = line.strip()
            if not line:
                continue
            amt, token = extract_first_number(line)
            if amt is None:
                continue
            m = num_re.search(line)
            note = line[m.end():].strip() if m else ""
            raw_token = token
            if raw_token.lstrip().startswith("+"):
                final_amt = amt
            elif raw_token.lstrip().startswith("-"):
                final_amt = amt
            else:
                final_amt = -abs(amt)
            add_record_to_chat(target_chat, final_amt, note, user_id)
            added_any = True
        return added_any

    # --- 6. Получаем строки для разбора ---
    lines_for_processing = []
    if msg.content_type == "text" and msg.text:
        lines_for_processing = msg.text.splitlines()
    elif msg.content_type in ["photo", "document", "video", "audio"] and getattr(msg, "caption", None):
        lines_for_processing = msg.caption.splitlines()

    # --- 7. Если есть строки — учитываем операции ---
    if lines_for_processing:
        added = process_lines_and_record(lines_for_processing, chat_id)
        if added:
            # 💡 Если это личка бота — обновляем текущее окно, а не создаём новое
            if msg.chat.type == "private":
                try:
                    # ищем предыдущее сообщение от бота (если есть)
                    last_msg_id = msg.message_id - 1
                    new_text = (
                        f"✅ Записаны операции ({today_key}).\n"
                        f"💰 Баланс: {get_chat_store(chat_id).get('balance',0)} ARS"
                    )
                    bot.edit_message_text(new_text, chat_id, last_msg_id, reply_markup=build_main_keyboard())
                except Exception:
                    bot.reply_to(
                        msg,
                        f"✅ Записано ({today_key}).\n💰 Баланс: {get_chat_store(chat_id).get('balance',0)} ARS",
                        reply_markup=build_main_keyboard()
                    )
            else:
                bot.reply_to(
                    msg,
                    f"✅ Записаны операции ({today_key}).\n💰 Баланс: {get_chat_store(chat_id).get('balance',0)} ARS",
                    reply_markup=build_main_keyboard()
                )

    # --- 8. Пересылка сообщений владельца (без дублей) ---
    if is_owner_msg:
        for target in list(data.get("forward_targets", [])):
            try:
                t = int(target)
            except Exception:
                continue
            # не пересылаем в тот же чат
            if t == chat_id:
                # если владелец пишет в целевом чате, копия идёт в личку владельца
                if owner_int and t != owner_int:
                    try:
                        sent = bot.copy_message(owner_int, chat_id, msg.message_id)
                        if sent:
                            key = f"{sent.chat.id}:{sent.message_id}"
                            processed.append(key)
                            data["processed_messages"] = processed[-1000:]
                            save_data(data)
                    except Exception as e:
                        log_error(f"Ошибка пересылки владельцу: {e}")
                continue
            # обычная пересылка
            try:
                sent = bot.copy_message(t, chat_id, msg.message_id)
                if sent:
                    key = f"{sent.chat.id}:{sent.message_id}"
                    processed.append(key)
                    data["processed_messages"] = processed[-1000:]
                    save_data(data)
            except Exception as e:
                log_error(f"Ошибка пересылки в {t}: {e}")

# --------------------------------------------
# ОТСЕК 9 — Flask webhook endpoints и автоустановка
# --------------------------------------------
@app.route("/", methods=["GET"])
def index():
    return f"Бот версия {VERSION} запущен."

@app.route("/webhook", methods=["POST"])
def webhook():
    try:
        raw = request.stream.read().decode("utf-8")
        update = telebot.types.Update.de_json(raw)
        bot.process_new_updates([update])
    except Exception as e:
        log_error(f"Ошибка в webhook: {e}")
    return "ok", 200

def ensure_webhook():
    try:
        webhook_url = f"{APP_URL.rstrip('/')}/webhook"
        info = requests.get(f"https://api.telegram.org/bot{TOKEN}/getWebhookInfo", timeout=10).json()
        current = info.get("result", {}).get("url", "")
        if current != webhook_url:
            r = requests.get(f"https://api.telegram.org/bot{TOKEN}/setWebhook", params={"url": webhook_url}, timeout=10)
            try:
                jr = r.json()
            except Exception:
                jr = {"ok": False, "description": r.text}
            if jr.get("ok"):
                log_info(f"Webhook установлен: {webhook_url}")
            else:
                log_error(f"Ошибка установки webhook: {jr}")
        else:
            log_info("Webhook уже установлен корректно.")
    except Exception as e:
        log_error(f"Ошибка проверки/установки webhook: {e}")

def notify_owner_start():
    if OWNER_ID is None:
        return
    try:
        owner_int = int(OWNER_ID)
    except Exception:
        return
    try:
        text = f"💬 Финансовый бот — версия {VERSION} запущен ✅"
        bot.send_message(owner_int, text, reply_markup=build_main_keyboard())
        log_info("Уведомление владельцу отправлено.")
    except Exception as e:
        log_error(f"Не удалось отправить уведомление владельцу: {e}")

# --------------------------------------------
# ОТСЕК 10 — Запуск приложения
# --------------------------------------------
if __name__ == "__main__":
    ensure_webhook()
    notify_owner_start()
    log_info(f"Бот запущен (версия {VERSION})")
    app.run(host="0.0.0.0", port=PORT)

# ============================================
# Конец кода — версия 9.6.1.6
# Всего строк: 655
# ============================================
