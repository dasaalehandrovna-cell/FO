# -------------------------------
# –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç "–§–û" ‚Äî –≤–µ—Ä—Å–∏—è 9.8.0
# –ü–æ–ª–Ω–∞—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è (–Ω–∞ –±–∞–∑–µ 9.6.1)
# Flask webhook ‚Äî –≥–æ—Ç–æ–≤ –∫ Deploy –Ω–∞ Render
# –¢—Ä–µ–±—É–µ—Ç: BOT_TOKEN, OWNER_ID –≤ env
# requirements.txt: pyTelegramBotAPI==4.23.0, flask
# -------------------------------

import os
import json
import time
import threading
import re
import csv
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from typing import Optional, Tuple, List, Dict, Any

from flask import Flask, request
import telebot
from telebot import types

# -------------------------------
# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
# -------------------------------
VERSION = "9.8.0"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/" + TOKEN) if TOKEN else "/webhook"

if not TOKEN:
    raise ValueError("–û—à–∏–±–∫–∞: BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è.")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------------
# default data structure (backward compatible with 9.6.1)
# -------------------------------
def default_data() -> Dict[str, Any]:
    return {
        "version_base": "9.6.1",
        "version_current": VERSION,
        "overall_balance": 0,
        "records": [],           # {id, short_id, timestamp(ISO UTC), amount, note, owner}
        "active_messages": {},   # YYYY-MM-DD -> { "chat_id": id, "message_id": id } per owner/chat
        "next_id": 1,
        "sent_messages": [],     # –∏—Å—Ç–æ—Ä–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –±–æ—Ç–æ–º —Å–æ–æ–±—â–µ–Ω–∏–π / –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ—Å—ã–ª–∫–∏
        "forward_targets": {},   # "<owner_chat_id>": ["<target1>", "<target2>", ...]
    }

# -------------------------------
# Load/Save data
# -------------------------------
def load_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            print(f"[load_data] –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å {DATA_FILE}: {e}")
            d = default_data()
    else:
        d = default_data()
    # ensure keys
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d: Dict[str, Any]) -> None:
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[save_data] –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è {DATA_FILE}: {e}")

data = load_data()

# -------------------------------
# Formatting and parsing utilities (based on 9.6.1)
# -------------------------------
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text: str) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    if s.startswith('+'):
        sign = '+'
        digits = s[1:].strip()
    elif s.startswith('-'):
        sign = '-'
        digits = s[1:].strip()
    else:
        sign = ''  # –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –∑–Ω–∞–∫–∞ => —Ä–∞—Å—Ö–æ–¥
        digits = s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    dm = re.match(r'(\d+)', digits_norm)
    if not dm:
        return None, None, None
    return int(dm.group(1)), sign, raw

def apply_sign_and_normalize(num: int, sign: Optional[str]) -> int:
    return num if sign == '+' else -num

def fmt_amount(n: int) -> str:
    return f"{abs(n):,}".replace(",", ".")

def make_short_id(n: int) -> str:
    return f"R{n}"

def date_local_str(dt: datetime) -> str:
    return dt.astimezone(TZ).strftime("%Y-%m-%d")

def time_local_str(dt: datetime) -> str:
    return dt.astimezone(TZ).strftime("%H:%M")

def now_iso_utc() -> str:
    return datetime.now(tz=ZoneInfo("UTC")).isoformat()

def now_local_iso() -> str:
    return datetime.now(tz=TZ).isoformat()

# -------------------------------
# Sent messages recording
# -------------------------------
def record_sent_message(entry: Dict[str, Any]) -> None:
    data.setdefault("sent_messages", []).append(entry)
    save_data(data)

def send_and_record(chat_id: int, text: str, reply_markup=None, parse_mode=None, purpose: str="message") -> Optional[types.Message]:
    try:
        sent = bot.send_message(int(chat_id), text, reply_markup=reply_markup, parse_mode=parse_mode)
        record_sent_message({
            "chat_id": int(chat_id),
            "message_id": int(sent.message_id),
            "timestamp": now_iso_utc(),
            "purpose": purpose
        })
        return sent
    except Exception as e:
        # Russian error message saved in history
        err = f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ {chat_id}: {e}"
        record_sent_message({
            "chat_id": int(chat_id),
            "message_id": None,
            "timestamp": now_iso_utc(),
            "purpose": purpose,
            "error": str(e)
        })
        # attempt to notify owner about the error (non-blocking)
        try:
            bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è {err}")
        except Exception:
            pass
        return None

def send_file_and_record(chat_id: int, path: str, caption: Optional[str]=None, purpose: str="file") -> Optional[types.Message]:
    try:
        with open(path, "rb") as f:
            sent = bot.send_document(int(chat_id), f, caption=caption)
        record_sent_message({
            "chat_id": int(chat_id),
            "message_id": int(sent.message_id),
            "timestamp": now_iso_utc(),
            "purpose": purpose
        })
        return sent
    except Exception as e:
        record_sent_message({
            "chat_id": int(chat_id),
            "message_id": None,
            "timestamp": now_iso_utc(),
            "purpose": purpose,
            "error": str(e)
        })
        try:
            bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞ –≤ {chat_id}: {e}")
        except Exception:
            pass
        return None

# -------------------------------
# Delayed delete helper
# -------------------------------
def delayed_delete(chat_id: int, message_id: int, delay: int = 5) -> None:
    def worker():
        time.sleep(delay)
        try:
            bot.delete_message(int(chat_id), int(message_id))
        except Exception as e:
            print(f"[delayed_delete] –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è {chat_id}/{message_id}: {e}")
    threading.Thread(target=worker, daemon=True).start()

# -------------------------------
# Day window building (detailed, based on 9.6.1)
# -------------------------------
def get_day_records_for_chat(chat_id: int, day_date: str):
    recs = []
    for r in data.get("records", []):
        if str(r.get("owner")) != str(chat_id):
            continue
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        except Exception:
            # fallback if timestamp stored without tz
            ts = datetime.fromisoformat(r["timestamp"])
            ts = ts.astimezone(TZ)
        if date_local_str(ts) == day_date:
            recs.append((ts, r))
    recs.sort(key=lambda x: x[0])
    return recs

def build_day_window(chat_id: int, day_date: str) -> str:
    recs = get_day_records_for_chat(chat_id, day_date)
    if not recs:
        return "üìò –ó–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –µ—â—ë –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π."
    lines = []
    lines.append(f"üìÖ {day_date}\n")
    last_hour = None
    day_income, day_expense = 0, 0
    for ts, r in recs:
        hour = ts.strftime("%H")
        if last_hour is None:
            last_hour = hour
        elif hour != last_hour:
            lines.append("")
            last_hour = hour
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        sid = r.get("short_id") or make_short_id(r.get("id"))
        note = r.get("note", "")
        t_local = time_local_str(ts)
        lines.append(f"üïì {t_local} | {sid} | {sign}{fmt_amount(amt)} {note}".rstrip())
        if amt > 0:
            day_income += amt
        else:
            day_expense += abs(amt)
    overall = data.get("overall_balance", 0)
    lines.append("")
    lines.append(f"üìà –ü—Ä–∏—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_income)}")
    lines.append(f"üìâ –†–∞—Å—Ö–æ–¥ –¥–Ω—è: {fmt_amount(day_expense)}")
    lines.append(f"üíµ –û–±—â–∏–π –æ—Å—Ç–∞—Ç–æ–∫: {fmt_amount(overall)}")
    return "\n".join(lines)

# -------------------------------
# Keyboards (inline) ‚Äî similar to 9.6.1 but with forward management
# -------------------------------
def kb_day_main():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_menu"))
    return kb

def kb_edit_main(chat_id=None):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–ò–∑–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å", callback_data="edit_modify"))
    kb.add(types.InlineKeyboardButton("–£–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å", callback_data="edit_delete"))
    kb.add(types.InlineKeyboardButton("üìÑ –≠–∫—Å–ø–æ—Ä—Ç CSV", callback_data="edit_export_csv"))
    kb.add(types.InlineKeyboardButton("–û–±–Ω—É–ª–∏—Ç—å –≤—Å—ë (–≤—Å–µ—Ö)", callback_data="edit_reset_all"))
    target_list = data.get("forward_targets", {}).get(str(chat_id), [])
    if target_list:
        kb.add(types.InlineKeyboardButton("üö´ –û—Ç–∫–ª—é—á–∏—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫—É", callback_data="forward_cancel"))
    else:
        kb.add(types.InlineKeyboardButton("üì§ –ü–µ—Ä–µ—Å—ã–ª–∫–∞", callback_data="forward_setup"))
    kb.add(types.InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="edit_cancel"))
    return kb

def kb_forward_menu(chat_id=None):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("üîß –î–æ–±–∞–≤–∏—Ç—å —Ü–µ–ª—å –ø–µ—Ä–µ—Å—ã–ª–∫–∏", callback_data="forward_add"))
    kb.add(types.InlineKeyboardButton("‚ùå –£–¥–∞–ª–∏—Ç—å —Ü–µ–ª—å", callback_data="forward_remove"))
    kb.add(types.InlineKeyboardButton("‚ÑπÔ∏è –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–µ–∫—É—â–∏–µ", callback_data="forward_check"))
    kb.add(types.InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="edit_cancel"))
    return kb

def kb_records_list(chat_id: int, day_date: str, mode: str):
    kb = types.InlineKeyboardMarkup()
    recs = []
    for ts, r in get_day_records_for_chat(chat_id, day_date):
        sid = r.get("short_id") or make_short_id(r.get("id"))
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        label = f"[{sid}] {sign}{fmt_amount(amt)} {r.get('note','')}"
        recs.append((sid, label))
    if not recs:
        kb.add(types.InlineKeyboardButton("–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –∑–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å", callback_data="no_op"))
        kb.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="edit_menu"))
        return kb
    for sid, label in recs:
        kb.add(types.InlineKeyboardButton(label[:60], callback_data=f"select:{mode}:{sid}"))
    kb.add(types.InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data="edit_menu"))
    return kb

def kb_yes_no(cb_prefix: str):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–î–∞", callback_data=f"{cb_prefix}_yes"),
           types.InlineKeyboardButton("–ù–µ—Ç", callback_data=f"{cb_prefix}_no"))
    return kb

# -------------------------------
# Find/modify/delete helpers
# -------------------------------
def find_record_by_short_id(short_id: str):
    for r in data.get("records", []):
        if r.get("short_id") == short_id or make_short_id(r.get("id")) == short_id:
            return r
    return None

def delete_record_by_short_id(chat_id: int, short_id: str) -> bool:
    r = find_record_by_short_id(short_id)
    if not r or str(r.get("owner")) != str(chat_id):
        return False
    try:
        data["records"] = [x for x in data["records"] if not (x.get("short_id") == short_id or make_short_id(x.get("id")) == short_id)]
        data["overall_balance"] = data.get("overall_balance", 0) - r["amount"]
        save_data(data)
        today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
        update_day_window_after_change(chat_id, today)
        return True
    except Exception as e:
        print(f"[delete_record] –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: {e}")
        return False

def modify_record_by_short_id(chat_id: int, short_id: str, new_text: str) -> bool:
    r = find_record_by_short_id(short_id)
    if not r or str(r.get("owner")) != str(chat_id):
        return False
    num, sign, raw = parse_first_number(new_text)
    if num is None:
        return False
    new_amt = apply_sign_and_normalize(num, sign)
    note = new_text[(new_text.find(raw) + len(raw)):].strip() if raw in new_text else ""
    for i, rr in enumerate(data["records"]):
        rr_sid = rr.get("short_id") or make_short_id(rr.get("id"))
        if rr_sid == short_id:
            data["overall_balance"] = data.get("overall_balance", 0) - rr["amount"] + new_amt
            data["records"][i]["amount"] = new_amt
            data["records"][i]["note"] = note
            save_data(data)
            today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            update_day_window_after_change(chat_id, today)
            return True
    return False

# -------------------------------
# Validate and save forward target with test message (immediate feedback)
# -------------------------------
def validate_and_save_forward(owner_chat_id: int, target_raw: str) -> Tuple[bool, str, Optional[str]]:
    """
    –ü–æ–ø—ã—Ç–∫–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å target –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–æ—à–ª–æ.
    target_raw –º–æ–∂–µ—Ç –±—ã—Ç—å —Å—Ç—Ä–æ–∫–æ–π (username) –∏–ª–∏ —Å—Ç—Ä–æ–∫–æ–π/—á–∏—Å–ª–æ–º.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (ok: bool, message: str, normalized_target)
    """
    t = str(target_raw).strip()
    if not t:
        return False, "–ü—É—Å—Ç–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä.", None
    # normalize
    if t.startswith("@"):
        target = t
    else:
        try:
            target = int(t)
        except Exception:
            # –≤–æ–∑–º–æ–∂–Ω–æ username –±–µ–∑ @
            target = t if t.startswith("@") else "@" + t if re.match(r'^[A-Za-z0-9_]+$', t) else t
    test_text = "üîÅ –¢–µ—Å—Ç –æ—Ç –±–æ—Ç–∞: –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏. –ï—Å–ª–∏ –≤–∏–¥–∏—Ç–µ —ç—Ç–æ ‚Äî –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ."
    try:
        bot.send_message(target, test_text)
    except Exception as e:
        err = f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ {repr(target)}: {e}"
        print(f"[validate_forward] {err}")
        return False, f"‚ùå {err}", str(target)
    # save into list
    key = str(owner_chat_id)
    lst = data.get("forward_targets", {}).get(key, [])
    if not isinstance(lst, list):
        lst = [lst] if lst else []
    if str(target) not in lst:
        lst.append(str(target))
        data.setdefault("forward_targets", {})[key] = lst
        save_data(data)
    return True, f"‚úÖ –ü–µ—Ä–µ—Å—ã–ª–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è {target}", str(target)

# -------------------------------
# Update day window (try edit else send new and delete old)
# -------------------------------
def update_day_window_after_change(chat_id: int, day_date: str, purpose: str="day_window") -> Optional[types.Message]:
    prev = data.get("active_messages", {}).get(day_date)
    text = build_day_window(chat_id, day_date)
    kb = kb_day_main()
    sent = None
    # try edit
    if prev and int(prev.get("chat_id")) == int(chat_id):
        try:
            bot.edit_message_text(chat_id=int(chat_id), message_id=int(prev.get("message_id")), text=text, reply_markup=kb)
            # record fake edit
            record_sent_message({
                "chat_id": int(chat_id),
                "message_id": int(prev.get("message_id")),
                "timestamp": now_iso_utc(),
                "purpose": purpose + "_edit"
            })
            save_data(data)
            return prev
        except Exception as e:
            print(f"[update_day_window] –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –¥–ª—è {chat_id}/{prev.get('message_id')}: {e}")
    # send new
    try:
        sent = bot.send_message(int(chat_id), text, reply_markup=kb)
        data.setdefault("active_messages", {})[day_date] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
        record_sent_message({"chat_id": int(chat_id), "message_id": int(sent.message_id), "timestamp": now_iso_utc(), "purpose": purpose})
        save_data(data)
    except Exception as e:
        print(f"[update_day_window] –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ –æ–∫–Ω–æ –¥–Ω—è –≤ {chat_id}: {e}")
        try:
            bot.send_message(int(OWNER_ID), f"‚ö†Ô∏è [update_day_window] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ–∫–Ω–∞ –¥–Ω—è –¥–ª—è {chat_id}: {e}")
        except Exception:
            pass
        return None
    # forward the window if configured for this chat
    forward_target = data.get("forward_targets", {}).get(str(chat_id))
    if forward_target:
        # support list or single
        if isinstance(forward_target, list):
            targets = forward_target
        else:
            targets = [forward_target]
        for tgt in targets:
            try:
                try:
                    bot.forward_message(int(tgt), int(chat_id), sent.message_id)
                except Exception:
                    bot.forward_message(tgt, int(chat_id), sent.message_id)
            except Exception as e:
                print(f"[update_day_window] Forward window failed to {tgt}: {e}")
    # delete previous
    if prev and int(prev.get("chat_id")) == int(chat_id):
        delayed_delete(prev["chat_id"], prev["message_id"], delay=5)
        data["active_messages"].pop(day_date, None)
        save_data(data)
    return sent

# -------------------------------
# Delete active window if today and belong
# -------------------------------
def delete_active_window_if_today_and_belong(chat_id: int) -> bool:
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    am = data.get("active_messages", {}).get(today)
    if am and int(am.get("chat_id")) == int(chat_id):
        delayed_delete(am["chat_id"], am["message_id"], delay=5)
        data["active_messages"].pop(today, None)
        save_data(data)
        return True
    return False

# -------------------------------
# Background midnight watcher (create windows for new day)
# -------------------------------
def midnight_watcher():
    last_date = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    while True:
        try:
            now_date = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            if now_date != last_date:
                owners = set()
                for r in data.get("records", []):
                    owners.add(str(r.get("owner")))
                for d, am in data.get("active_messages", {}).items():
                    owners.add(str(am.get("chat_id")))
                for owner in owners:
                    try:
                        update_day_window_after_change(int(owner), now_date, purpose="new_day")
                    except Exception as e:
                        print(f"[midnight_watcher] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ–∫–Ω–∞ –¥–ª—è {owner}: {e}")
                last_date = now_date
            time.sleep(30)
        except Exception as e:
            print(f"[midnight_watcher] –û—à–∏–±–∫–∞ –≤ –ø–æ—Ç–æ–∫–µ: {e}")
            time.sleep(30)

threading.Thread(target=midnight_watcher, daemon=True).start()

# -------------------------------
# Export to CSV
# -------------------------------
def export_all_to_csv(path: str = CSV_FILE) -> str:
    rows = []
    for r in data.get("records", []):
        try:
            ts_utc = datetime.fromisoformat(r["timestamp"])
        except Exception:
            ts_utc = datetime.fromisoformat(r["timestamp"])
        ts_local = ts_utc.astimezone(TZ)
        date_s = ts_local.strftime("%Y-%m-%d")
        time_s = ts_local.strftime("%H:%M:%S")
        amt = r["amount"]
        typ = "–ø—Ä–∏—Ö–æ–¥" if amt > 0 else "—Ä–∞—Å—Ö–æ–¥"
        rows.append({
            "ID": r.get("short_id") or make_short_id(r.get("id")),
            "–î–∞—Ç–∞": date_s,
            "–í—Ä–µ–º—è": time_s,
            "–°—É–º–º–∞": f"{amt:+d}",
            "–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π": r.get("note",""),
            "–¢–∏–ø": typ,
            "–í–ª–∞–¥–µ–ª–µ—Ü": r.get("owner")
        })
    try:
        with open(path, "w", newline="", encoding="utf-8-sig") as csvfile:
            fieldnames = ["ID","–î–∞—Ç–∞","–í—Ä–µ–º—è","–°—É–º–º–∞","–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π","–¢–∏–ø","–í–ª–∞–¥–µ–ª–µ—Ü"]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            for row in rows:
                writer.writerow(row)
        return path
    except Exception as e:
        print(f"[export_all_to_csv] –û—à–∏–±–∫–∞: {e}")
        raise

# -------------------------------
# Pending actions (states for waits)
# -------------------------------
pending_actions: Dict[str, Dict[str, Any]] = {}  # key: chat_id -> {"type":..., "payload":...}

# -------------------------------
# Forward helpers (multi-target)
# -------------------------------
def ensure_forward_list_for(chat_id: int) -> List[str]:
    key = str(chat_id)
    data.setdefault("forward_targets", {})
    current = data["forward_targets"].get(key)
    if current is None:
        data["forward_targets"][key] = []
        save_data(data)
        return data["forward_targets"][key]
    if isinstance(current, list):
        return current
    # convert single string to list
    data["forward_targets"][key] = [str(current)]
    save_data(data)
    return data["forward_targets"][key]

def add_forward_target(chat_id: int, target: str) -> bool:
    lst = ensure_forward_list_for(chat_id)
    t = str(target).strip()
    if t in lst:
        return False
    lst.append(t)
    data["forward_targets"][str(chat_id)] = lst
    save_data(data)
    return True

def remove_forward_target(chat_id: int, target: str) -> bool:
    lst = ensure_forward_list_for(chat_id)
    t = str(target).strip()
    if t in lst:
        lst = [x for x in lst if x != t]
        data["forward_targets"][str(chat_id)] = lst
        save_data(data)
        return True
    return False

def list_forward_targets(chat_id: int) -> List[str]:
    return ensure_forward_list_for(chat_id)

# -------------------------------
# Validate target by sending test message
# -------------------------------
def validate_and_test_target(target_raw: str) -> Tuple[bool, str, str]:
    t_raw = str(target_raw).strip()
    if t_raw.startswith("@"):
        normalized = t_raw
    else:
        try:
            normalized = int(t_raw)
        except Exception:
            # accept plain username
            normalized = t_raw if t_raw.startswith("@") else "@" + t_raw
    try:
        bot.send_message(normalized, "üîÅ –¢–µ—Å—Ç –æ—Ç –±–æ—Ç–∞: –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ø–µ—Ä–µ—Å—ã–ª–∫–∏. –ï—Å–ª–∏ –≤–∏–¥–∏—Ç–µ —ç—Ç–æ ‚Äî –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ.")
        return True, "–¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ.", str(normalized)
    except Exception as e:
        return False, f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: {e}", str(normalized)

# -------------------------------
# Auto-forward (for any incoming message)
# -------------------------------
def auto_forward_message_from(chat_id: int, message: types.Message) -> List[Dict[str, Any]]:
    results = []
    targets = data.get("forward_targets", {}).get(str(chat_id)) or []
    if not targets:
        return results
    for t in targets:
        try:
            try:
                tgt_int = int(t)
                bot.forward_message(tgt_int, int(chat_id), message.message_id)
                results.append({"target": t, "ok": True, "method": "forward"})
            except Exception:
                bot.forward_message(t, int(chat_id), message.message_id)
                results.append({"target": t, "ok": True, "method": "forward"})
        except Exception as e:
            # fallback: try to send text copy if text; for media attempt to download+send as file may be heavy ‚Äî we try basic fallbacks
            try:
                if message.content_type == 'text' and getattr(message, "text", None):
                    bot.send_message(t, f"üì® –ö–æ–ø–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ {chat_id}:\n\n{message.text}")
                    results.append({"target": t, "ok": True, "method": "sent_copy"})
                else:
                    # For media: try forwarding as document (not always possible), skip heavy handling
                    results.append({"target": t, "ok": False, "error": str(e)})
            except Exception as e2:
                results.append({"target": t, "ok": False, "error": str(e2)})
    # record attempts
    for r in results:
        record_sent_message({
            "timestamp": now_iso_utc(),
            "from_chat": str(chat_id),
            "to": r["target"],
            "ok": bool(r.get("ok")),
            "info": r.get("error") if not r.get("ok") else r.get("method")
        })
    return results

@bot.message_handler(func=lambda m: True, content_types=["text", "photo", "video", "document", "audio", "voice", "sticker"])
def all_messages(msg):
    try:
        # --- –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü ---
        if str(msg.from_user.id) != str(OWNER_ID):
            return  # –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —á—É–∂–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è

        # --- –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –±–æ—Ç–æ–º —Å–∞–º–∏–º ---
        if msg.from_user and msg.from_user.is_bot:
            return

        text = msg.text or ""

        # --- –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –∑–∞–ø–∏—Å–∏ (+1000 / -500 ...) ---
        if re.match(r"^[+-]?\d+", text):
            amount = int(re.findall(r"^[+-]?\d+", text)[0])
            note = re.sub(r"^[+-]?\d+\s*", "", text)
            add_record(amount, note, msg.from_user.username or msg.from_user.first_name)
            bot.reply_to(msg, f"‚úÖ –ó–∞–ø–∏—Å–∞–Ω–æ: {amount} ({note})")

        else:
            # --- –ê–≤—Ç–æ–ø–µ—Ä–µ—Å—ã–ª–∫–∞ —Ç–æ–ª—å–∫–æ —Å–æ–æ–±—â–µ–Ω–∏–π –≤–ª–∞–¥–µ–ª—å—Ü–∞ ---
            for target in data.get("forward_targets", []):
                try:
                    bot.forward_message(target, msg.chat.id, msg.message_id)
                except Exception as e:
                    print(f"[–û—à–∏–±–∫–∞ –ø–µ—Ä–µ—Å—ã–ª–∫–∏ –≤ {target}] {e}")

    except Exception as e:
        bot.reply_to(msg, f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")
# -------------------------------
# Callback handler (inline buttons)
# -------------------------------
@bot.callback_query_handler(func=lambda call: True)
def callback_worker(call: types.CallbackQuery):
    data_local = load_data()
    data_call = call.data or ""
    chat_id = call.message.chat.id
    call_msg = call.message
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    try:
        bot.answer_callback_query(call.id)
    except Exception:
        pass

    # edit menu
    if data_call == "edit_menu":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
        except Exception:
            send_and_record(chat_id, "–ú–µ–Ω—é —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:", reply_markup=kb_edit_main(chat_id), purpose="edit_menu_fallback")
        return

    if data_call == "edit_cancel":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_day_main())
        except Exception:
            send_and_record(chat_id, build_day_window(chat_id, today), reply_markup=kb_day_main(), purpose="day_window_fallback")
        return

    if data_call == "edit_modify":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_records_list(chat_id, today, mode="modify"))
        except Exception:
            send_and_record(chat_id, "–í—ã–±–æ—Ä –∑–∞–ø–∏—Å–∏ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:", reply_markup=kb_records_list(chat_id, today, mode="modify"), purpose="modify_list_fallback")
        return

    if data_call == "edit_delete":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_records_list(chat_id, today, mode="delete"))
        except Exception:
            send_and_record(chat_id, "–í—ã–±–æ—Ä –∑–∞–ø–∏—Å–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=kb_records_list(chat_id, today, mode="delete"), purpose="delete_list_fallback")
        return

    if data_call in ("edit_export_csv","edit_export_csv_alt"):
        try:
            path = export_all_to_csv(CSV_FILE)
            send_file_and_record(chat_id, path, caption="–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π (CSV)", purpose="export_csv")
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
            except Exception:
                pass
        except Exception as e:
            print(f"[callback export_csv] {e}")
            send_and_record(chat_id, "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ CSV.", purpose="export_error")
        return

    if data_call == "forward_setup":
        send_and_record(chat_id, "–ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ü–µ–ª–µ–≤–æ–≥–æ —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ chat_id/@username. –û—Ç–ø—Ä–∞–≤—å—Ç–µ '–æ—Ç–º–µ–Ω–∞' —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å.", purpose="await_forward_input")
        pending_actions[str(chat_id)] = {"type": "await_forward_setup", "payload": {}}
        return

    if data_call == "forward_add":
        send_and_record(chat_id, "–ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ü–µ–ª–µ–≤–æ–≥–æ —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ chat_id/@username.", purpose="await_forward_input")
        pending_actions[str(chat_id)] = {"type": "await_forward_setup", "payload": {}}
        return

    if data_call == "forward_remove":
        lst = list_forward_targets(chat_id)
        if not lst:
            send_and_record(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.", purpose="forward_remove_noop")
            return
        send_and_record(chat_id, "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–æ—á–Ω—É—é —Ü–µ–ª—å –∏–∑ —Å–ø–∏—Å–∫–∞, –∏–ª–∏ '–≤—Å—ë' –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤—Å–µ—Ö.", purpose="await_remove_forward")
        pending_actions[str(chat_id)] = {"type": "await_remove_forward", "payload": {}}
        return

    if data_call == "forward_cancel":
        ft = data.get("forward_targets", {})
        if str(chat_id) in ft:
            ft.pop(str(chat_id), None)
            data["forward_targets"] = ft
            save_data(data)
            send_and_record(chat_id, "‚úÖ –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞.", purpose="forward_cancelled")
        else:
            send_and_record(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –±—ã–ª–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.", purpose="forward_cancel_noop")
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
        except Exception:
            pass
        return

    if data_call == "forward_check":
        ft = data.get("forward_targets", {}).get(str(chat_id))
        if ft:
            send_and_record(chat_id, f"üì® –¢–µ–∫—É—â–∏–µ —Ü–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏:\n{ft}", purpose="forward_check_resp")
        else:
            send_and_record(chat_id, "üîï –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.", purpose="forward_check_resp")
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
        except Exception:
            pass
        return

    if data_call.startswith("select:"):
        parts = data_call.split(":", 2)
        if len(parts) != 3:
            send_and_record(chat_id, "–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä.", purpose="select_error")
            return
        mode = parts[1]
        short_id = parts[2]
        if mode == "modify":
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=None)
            except Exception:
                pass
            send_and_record(chat_id, f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è {short_id} (–ø—Ä–∏–º–µ—Ä: +1000 –∑–∞—Ä–ø–ª–∞—Ç–∞).", purpose="await_modify_input")
            pending_actions[str(chat_id)] = {"type": "await_modify_input", "payload": {"short_id": short_id}}
            return
        elif mode == "delete":
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_yes_no(f"confirm_delete:{short_id}"))
            except Exception:
                send_and_record(chat_id, f"–£–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å {short_id}?", reply_markup=kb_yes_no(f"confirm_delete:{short_id}"), purpose="delete_confirm_fallback")
            return
        else:
            send_and_record(chat_id, "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞.", purpose="select_badmode")
            return

    if data_call.startswith("confirm_delete:"):
        tail = data_call[len("confirm_delete:"):]
        if tail.endswith("_yes"):
            short_id = tail[:-4]
            ok = delete_record_by_short_id(chat_id, short_id)
            if ok:
                try:
                    bot.edit_message_text(f"‚úÖ –ó–∞–ø–∏—Å—å {short_id} —É–¥–∞–ª–µ–Ω–∞.", call_msg.chat.id, call_msg.message_id)
                except Exception:
                    send_and_record(chat_id, f"‚úÖ –ó–∞–ø–∏—Å—å {short_id} —É–¥–∞–ª–µ–Ω–∞.", purpose="deleted_record")
            else:
                try:
                    bot.edit_message_text(f"‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å {short_id}.", call_msg.chat.id, call_msg.message_id)
                except Exception:
                    send_and_record(chat_id, f"‚ùó –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∑–∞–ø–∏—Å—å {short_id}.", purpose="delete_failed")
        else:
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
            except Exception:
                send_and_record(chat_id, "–£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=kb_edit_main(chat_id), purpose="delete_cancelled")
        return

    if data_call == "edit_reset_all":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_yes_no("confirm_reset_all"))
        except Exception:
            send_and_record(chat_id, "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω—É–ª–∏—Ç—å –í–°–ï –¥–∞–Ω–Ω—ã–µ –Ω–∞–≤—Å–µ–≥–¥–∞? (–î–∞/–ù–µ—Ç)", reply_markup=kb_yes_no("confirm_reset_all"), purpose="reset_confirm_fallback")
        return

    if data_call.startswith("confirm_reset_all"):
        if data_call.endswith("_yes"):
            data["overall_balance"] = 0
            data["records"] = []
            data["active_messages"] = {}
            save_data(data)
            try:
                bot.edit_message_text("‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –¥–µ–Ω—å.", call_msg.chat.id, call_msg.message_id)
            except Exception:
                send_and_record(chat_id, "‚ôªÔ∏è –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω—É–ª–µ–Ω—ã. –ù–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –¥–µ–Ω—å.", purpose="reset_done")
        else:
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
            except Exception:
                send_and_record(chat_id, "–û–±–Ω—É–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=kb_edit_main(chat_id), purpose="reset_cancel")
        return

    if data_call in ("no_op",):
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_day_main())
        except Exception:
            send_and_record(chat_id, build_day_window(chat_id, today), reply_markup=kb_day_main(), purpose="no_op_fallback")
        return

    print("[callback] Unhandled callback:", data_call)

# -------------------------------
# Commands: /–±–∞–ª–∞–Ω—Å /–æ—Ç—á–µ—Ç /—Å–±—Ä–æ—Å (public)
# -------------------------------
@bot.message_handler(commands=["–±–∞–ª–∞–Ω—Å"])
def cmd_balance(message: types.Message):
    chat_id = message.chat.id
    overall = data.get("overall_balance", 0)
    bot.reply_to(message, f"üí∞ –¢–µ–∫—É—â–∏–π –æ–±—â–∏–π –±–∞–ª–∞–Ω—Å: {fmt_amount(overall)}")

@bot.message_handler(commands=["–æ—Ç—á–µ—Ç"])
def cmd_report(message: types.Message):
    chat_id = message.chat.id
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    update_day_window_after_change(chat_id, today, purpose="report_cmd")

@bot.message_handler(commands=["—Å–±—Ä–æ—Å"])
def cmd_reset(message: types.Message):
    chat_id = message.chat.id
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return
    kb = kb_yes_no("confirm_reset_all")
    send_and_record(chat_id, "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω—É–ª–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ? (–î–∞/–ù–µ—Ç)", reply_markup=kb, purpose="reset_command")

# -------------------------------
# Admin commands for forward management (text commands)
# -------------------------------
@bot.message_handler(commands=['addforward'])
def cmd_addforward_text(message: types.Message):
    chat_id = message.chat.id
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.")
        return
    send_and_record(chat_id, "–ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å—é–¥–∞ –ª—é–±–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ —Ü–µ–ª–µ–≤–æ–≥–æ —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞/–≥—Ä—É–ø–ø—ã –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ chat_id/@username. –û—Ç–ø—Ä–∞–≤—å—Ç–µ '–æ—Ç–º–µ–Ω–∞' –¥–ª—è –æ—Ç–º–µ–Ω—ã.", purpose="await_forward_input_cmd")
    pending_actions[str(chat_id)] = {"type": "await_forward_setup", "payload": {}}

@bot.message_handler(commands=['removeforward'])
def cmd_removeforward_text(message: types.Message):
    chat_id = message.chat.id
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "‚õî –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–µ—Ä–µ—Å—ã–ª–∫–æ–π.")
        return
    lst = list_forward_targets(chat_id)
    if not lst:
        send_and_record(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –≤ —ç—Ç–æ–º —á–∞—Ç–µ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞.", purpose="remove_forward_noop")
        return
    send_and_record(chat_id, "–°–ø–∏—Å–æ–∫ —Ç–µ–∫—É—â–∏—Ö —Ü–µ–ª–µ–π:\n" + "\n".join(lst) + "\n\n–û—Ç–ø—Ä–∞–≤—å —Ç–æ—á–Ω—É—é —Ü–µ–ª—å —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å, –∏–ª–∏ '–≤—Å—ë' —á—Ç–æ–±—ã —É–¥–∞–ª–∏—Ç—å –≤—Å–µ.", purpose="await_remove_forward")
    pending_actions[str(chat_id)] = {"type": "await_remove_forward", "payload": {}}

@bot.message_handler(commands=['listforwards'])
def cmd_listforwards_text(message: types.Message):
    chat_id = message.chat.id
    lst = list_forward_targets(chat_id)
    if not lst:
        send_and_record(chat_id, "–ü–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞ –¥–ª—è —ç—Ç–æ–≥–æ —á–∞—Ç–∞.", purpose="list_forwards_empty")
    else:
        send_and_record(chat_id, "–¢–µ–∫—É—â–∏–µ —Ü–µ–ª–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–∏:\n" + "\n".join(lst), purpose="list_forwards")

# -------------------------------
# Webhook endpoints for Flask (Render-friendly)
# -------------------------------
@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    try:
        json_str = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
    except Exception as e:
        print(f"[webhook] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ update: {e}")
    return '', 200

@app.route("/", methods=['GET'])
def index():
    return f"ü§ñ –ë–æ—Ç '–§–û' –≤–µ—Ä—Å–∏—è {VERSION} –∑–∞–ø—É—â–µ–Ω."

# -------------------------------
# Startup: set webhook if RENDER_EXTERNAL_HOSTNAME exists, notify owner
# -------------------------------
def set_webhook_if_possible():
    try:
        host = os.getenv("RENDER_EXTERNAL_HOSTNAME")
        if host:
            url = f"https://{host}{WEBHOOK_PATH}"
            bot.remove_webhook()
            time.sleep(0.5)
            bot.set_webhook(url=url)
            print(f"[startup] Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {url}")
            if OWNER_ID:
                try:
                    msg = bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION}: webhook –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.")
                    delayed_delete(int(OWNER_ID), msg.message_id, delay=5)
                    record_sent_message({"chat_id": int(OWNER_ID), "message_id": int(msg.message_id), "timestamp": now_iso_utc(), "purpose": "owner_ping"})
                except Exception as e:
                    print(f"[startup notify] –û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–ª–∞–¥–µ–ª—å—Ü–∞: {e}")
    except Exception as e:
        print(f"[set_webhook_if_possible] {e}")

# -------------------------------
# Run
# -------------------------------
if __name__ == "__main__":
    print(f"–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ '–§–û' v{VERSION} ...")
    save_data(data)
    set_webhook_if_possible()
    # notify owner
    if OWNER_ID:
        try:
            msg = bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç v{VERSION} –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤.")
            delayed_delete(int(OWNER_ID), msg.message_id, delay=5)
            record_sent_message({"chat_id": int(OWNER_ID), "message_id": int(msg.message_id), "timestamp": now_iso_utc(), "purpose": "owner_start"})
        except Exception as e:
            print(f"[startup] –û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–ª–∞–¥–µ–ª—å—Ü–∞: {e}")
    app.run(host="0.0.0.0", port=PORT)

# -------------------------------
# lines: 976
# –í–µ—Ä—Å–∏—è 9.8.0 –∑–∞–ø–æ–º–Ω–µ–Ω–∞.
# -------------------------------