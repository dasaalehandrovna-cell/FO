# ============================================
# –§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç ‚Äî –≤–µ—Ä—Å–∏—è 9.8.3 + Aiogram –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
# ============================================

import os
import json
import csv
import logging
import re
import threading
import time
from datetime import datetime
from zoneinfo import ZoneInfo
import asyncio

from flask import Flask, request
import telebot
from telebot import types

from aiogram import Bot as AiogramBot, Dispatcher, types as ai_types
from aiogram.utils import executor

# -----------------------------
# –ö–æ–Ω—Ñ–∏–≥–∏
# -----------------------------
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")  # —Å—Ç—Ä–æ–∫–∞ —Å —á–∏—Å–ª–æ–º
APP_URL = os.getenv("APP_URL", "https://yourapp.onrender.com")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
LOG_FILE = "log.txt"
PORT = int(os.environ.get("PORT", 5000))
VERSION = "9.8.3"

if not TOKEN:
    raise ValueError("BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")

# -----------------------------
# Lock –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö
# -----------------------------
data_lock = threading.Lock()

# -----------------------------
# Telebot
# -----------------------------
bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -----------------------------
# Aiogram
# -----------------------------
aiobot = AiogramBot(token=TOKEN)
dp = Dispatcher(aiobot)

# -----------------------------
# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
# -----------------------------
logging.basicConfig(
    level=logging.INFO,
    format="[{asctime}] {levelname}: {message}",
    style="{",
    handlers=[logging.FileHandler(LOG_FILE, encoding="utf-8"), logging.StreamHandler()]
)

def log_info(msg):
    logging.info(msg)
def log_error(msg):
    logging.error(msg)

log_info(f"–°—Ç–∞—Ä—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. –í–µ—Ä—Å–∏—è {VERSION}")

# -----------------------------
# –†–∞–±–æ—Ç–∞ —Å –¥–∞–Ω–Ω—ã–º–∏
# -----------------------------
def default_data():
    return {
        "overall_balance": 0,
        "records": [],
        "chats": {},
        "active_messages": {},
        "processed_messages": [],
        "forward_targets": [],
        "tracked_messages": {},
        "next_id": 1
    }

def load_data():
    with data_lock:
        if os.path.exists(DATA_FILE):
            try:
                with open(DATA_FILE, "r", encoding="utf-8") as f:
                    d = json.load(f)
            except:
                d = default_data()
        else:
            d = default_data()
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–µ–π
        base = default_data()
        for k, v in base.items():
            if k not in d:
                d[k] = v
        return d

def save_data(d):
    with data_lock:
        try:
            with open(DATA_FILE, "w", encoding="utf-8") as f:
                json.dump(d, f, ensure_ascii=False, indent=2)
        except Exception as e:
            log_error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è data.json: {e}")

data = load_data()

if OWNER_ID:
    try:
        oi = int(OWNER_ID)
        if oi not in data.get("forward_targets", []):
            data["forward_targets"].append(oi)
            save_data(data)
    except Exception:
        pass

# -----------------------------
# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
# -----------------------------
def get_today_key():
    return datetime.now(TZ).strftime("%Y-%m-%d")

def get_chat_store(chat_id):
    cid = str(chat_id)
    if cid not in data["chats"]:
        data["chats"][cid] = {
            "balance": 0,
            "records": [],
            "next_id": 1,
            "daily_records": {},
            "active_windows": {},
            "edit_wait": None,
            "edit_target": None,
            "forward_enabled": False,
            "active_window_id": None
        }
        save_data(data)
    return data["chats"][cid]

def export_to_csv(d):
    try:
        with open(CSV_FILE, "w", newline='', encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["chat_id","ID","short_id","timestamp","amount","note","owner","day_key"])
            for cid, cdata in d.get("chats", {}).items():
                for day_key, records in cdata.get("daily_records", {}).items():
                    for r in records:
                        writer.writerow([cid, r.get("id"), r.get("short_id"), r.get("timestamp"), r.get("amount"), r.get("note"), r.get("owner"), day_key])
    except Exception as e:
        log_error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ CSV: {e}")

# -----------------------------
# –ù–æ–≤—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª: –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–∫–Ω–∞
# -----------------------------
def edit_then_duplicate_window(chat_id):
    today_key = get_today_key()
    store = get_chat_store(chat_id)
    today_msgs = data.setdefault("active_messages", {}).setdefault(today_key, {})
    old_id = today_msgs.get(str(chat_id))

    day_records = store.get("daily_records", {}).get(today_key, [])
    daily_income = sum(r["amount"] for r in day_records if r["amount"] > 0)
    daily_expense = sum(r["amount"] for r in day_records if r["amount"] < 0)
    overall_balance = store.get("balance", 0)

    if not day_records:
        text = (
            f"üìÖ {today_key}\n"
            f"–ü–æ–∫–∞ –Ω–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏–π.\n"
            f"üíµ –ü—Ä–∏—Ö–æ–¥: {daily_income} ARS\n"
            f"üí∏ –†–∞—Å—Ö–æ–¥: {abs(daily_expense)} ARS\n"
            f"üí∞ –û–±—â–∏–π –æ—Å—Ç–∞—Ç–æ–∫: {overall_balance} ARS"
        )
    else:
        lines = [f"üìÖ {today_key}", "üìã –û–ø–µ—Ä–∞—Ü–∏–∏:"]
        for r in day_records[-50:]:
            sign = "+" if r["amount"] > 0 else "-"
            lines.append(f"{r['short_id']}: {sign}{abs(r['amount'])} ‚Äî {r.get('note','')}")
        lines.append(
            f"\nüíµ –ü—Ä–∏—Ö–æ–¥: {daily_income} ARS\n"
            f"üí∏ –†–∞—Å—Ö–æ–¥: {abs(daily_expense)} ARS\n"
            f"üí∞ –û–±—â–∏–π –æ—Å—Ç–∞—Ç–æ–∫: {overall_balance} ARS"
        )
        text = "\n".join(lines)

    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("–û–±–Ω–æ–≤–∏—Ç—å", callback_data="btn_start"))

    if old_id:
        try:
            bot.edit_message_text(text, chat_id, old_id, reply_markup=kb)
        except:
            pass

    def duplicate_and_delete_old():
        time.sleep(2)
        try:
            sent = bot.send_message(chat_id, text, reply_markup=kb)
            today_msgs[str(chat_id)] = sent.message_id
            save_data(data)
            if old_id:
                time.sleep(0.5)
                try:
                    bot.delete_message(chat_id, old_id)
                except:
                    pass
        except Exception as e:
            log_error(f"–û—à–∏–±–∫–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –æ–∫–Ω–∞: {e}")

    threading.Thread(target=duplicate_and_delete_old, daemon=True).start()

# -----------------------------
# –ü–∞—Ä—Å–µ—Ä —Å—É–º–º
# -----------------------------
num_re = re.compile(r'(\^?[+-]?\^?\s*\d+\^?|\^[+-]\^[\d]+|\+?-?\d+)')

def parse_amount_token(token:str):
    t = token.strip()
    t = t.replace("^","").replace(" ","")
    if t.startswith("+"):
        return int(t[1:])
    if t.startswith("-"):
        return -int(t[1:])
    return -int(t)

# ===============================
# Aiogram: –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –±–ª–æ–∫
# ===============================
ALLOWED_SOURCE_CHATS = []  # —Å—é–¥–∞ ID —á–∞—Ç–æ–≤
FORWARD_TARGETS = ["me"]

def parse_amount(text: str):
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å—É–º–º—É –∏ —Ç–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–æ —Ç–µ–∫—Å—Ç—É"""
    text = text.replace(",", ".").strip()
    amount = 0
    is_income = None
    for part in text.split():
        try:
            if part.startswith("+"):
                amount = float(part[1:])
                is_income = True
                break
            elif part.startswith("-"):
                amount = float(part[1:])
                is_income = False
                break
            elif part.replace(".", "", 1).isdigit():
                amount = float(part)
                if any(w in text.lower() for w in ["–ø—Ä–∏—Ö–æ–¥", "–ø–æ–ø–æ–ª–Ω", "–¥–æ—Ö–æ–¥", "–≤–Ω–µ—Å"]):
                    is_income = True
                elif any(w in text.lower() for w in ["—Ä–∞—Å—Ö–æ–¥", "—Ç—Ä–∞—Ç–∞", "–ø–æ–∫—É–ø", "—Å–ø–∏—Å–∞–Ω"]):
                    is_income = False
                break
        except:
            continue
    return amount, is_income

@dp.message_handler(content_types=ai_types.ContentTypes.ANY)
async def forward_and_record(message: ai_types.Message):
    if message.chat.id not in ALLOWED_SOURCE_CHATS:
        return
    text = message.text or message.caption or ""
    amount, is_income = parse_amount(text)
    if amount > 0 and is_income is not None:
        chat_id = str(message.chat.id)
        with data_lock:
            store = get_chat_store(chat_id)
            if is_income:
                store["balance"] += amount
                note = f"üí∞ –ü—Ä–∏—Ö–æ–¥: +{amount} ‚ÇΩ"
            else:
                store["balance"] -= amount
                note = f"üí∏ –†–∞—Å—Ö–æ–¥: -{amount} ‚ÇΩ"
            save_data(data)
        await aiobot.send_message(chat_id, f"{note}\n–ë–∞–ª–∞–Ω—Å: {store['balance']} ‚ÇΩ")
    for target in FORWARD_TARGETS:
        try:
            if target == "me":
                await message.forward(message.from_user.id)
            else:
                await message.forward(target)
        except:
            pass

@dp.message_handler(lambda msg: msg.text)
async def auto_delete_message(message: ai_types.Message):
    await asyncio.sleep(30)
    try:
        await message.delete()
    except:
        pass

# ===============================
# Flask webhook
# ===============================
@app.route(f"/{TOKEN}", methods=["POST"])
def webhook():
    update = telebot.types.Update.de_json(request.get_data().decode("utf-8"))
    bot.process_new_updates([update])
    return "OK", 200

@app.route("/", methods=["GET"])
def index():
    return f"–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±–æ—Ç ¬´–§–û¬ª ‚Äî –≤–µ—Ä—Å–∏—è {VERSION} —Ä–∞–±–æ—Ç–∞–µ—Ç", 200

def set_webhook():
    url = f"{APP_URL}/{TOKEN}"
    try:
        bot.remove_webhook()
        time.sleep(0.5)
        bot.set_webhook(url=url)
        log_info(f"Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {url}")
    except Exception as e:
        log_error(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å webhook: {e}")

# ===============================
# –ó–∞–ø—É—Å–∫
# ===============================
if __name__ == "__main__":
    set_webhook()
    threading.Thread(target=lambda: asyncio.run(dp.start_polling()), daemon=True).start()
    log_info(f"–ë–æ—Ç –§–û –≤–µ—Ä—Å–∏–∏ {VERSION} –∑–∞–ø—É—â–µ–Ω")
    try:
        if OWNER_ID:
            bot.send_message(int(OWNER_ID), f"‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç! (–≤–µ—Ä—Å–∏—è {VERSION})")
    except Exception as e:
        log_error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–ø—É—Å–∫–µ: {e}")
    app.run(host="0.0.0.0", port=PORT)