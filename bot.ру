# -------------------------------
# Финансовый бот "ФО" — версия 9.8.1 (full)
# Per-chat accounting + PM-owner media forwarding + inline editing restored
# Requires: BOT_TOKEN, OWNER_ID environment variables
# -------------------------------

import os
import json
import time
import re
import csv
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import Any, Dict, List, Optional, Tuple

from flask import Flask, request
import telebot
from telebot import types

# Configuration
VERSION = "9.8.1"
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
PORT = int(os.environ.get("PORT", 5000))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/" + TOKEN) if TOKEN else "/webhook"

if not TOKEN:
    raise ValueError("Ошибка: BOT_TOKEN не установлен.")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# -------------------------------
# Data helpers
def default_data() -> Dict[str, Any]:
    return {
        "version_base": "9.6.1",
        "version_current": VERSION,
        "global_balance": 0,
        "chats": {},  # chat_id -> { balance, records, next_id, prefix }
        "active_messages": {},  # day-> { "<chat_id>": { "chat_id": id, "message_id": id } }
        "sent_messages": [],
        "forward_targets": {}  # owner_chat_id -> [targets]
    }

def load_data() -> Dict[str, Any]:
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            print(f"[load_data] Ошибка чтения {DATA_FILE}: {e}")
            d = default_data()
    else:
        d = default_data()
    base = default_data()
    for k, v in base.items():
        if k not in d:
            d[k] = v
    return d

def save_data(d: Dict[str, Any]) -> None:
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        print(f"[save_data] Ошибка сохранения {DATA_FILE}: {e}")

data = load_data()

# -------------------------------
# Utilities
NUMBER_RE = re.compile(r'([+-]?\s*[\d][\d\s\.,]*)')

def parse_first_number(text: str) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    if not text:
        return None, None, None
    m = NUMBER_RE.search(text)
    if not m:
        return None, None, None
    raw = m.group(1)
    s = raw.strip()
    if s.startswith('+'):
        sign = '+'
        digits = s[1:].strip()
    elif s.startswith('-'):
        sign = '-'
        digits = s[1:].strip()
    else:
        sign = ''
        digits = s
    digits_norm = re.sub(r'[\s\.,]', '', digits)
    dm = re.match(r'(\d+)', digits_norm)
    if not dm:
        return None, None, None
    return int(dm.group(1)), sign, raw

def apply_sign_and_normalize(num: int, sign: Optional[str]) -> int:
    return num if sign == '+' else -num

def fmt_amount(n: int) -> str:
    return f"{abs(n):,}".replace(",", ".")

def now_iso_utc() -> str:
    return datetime.now(tz=ZoneInfo("UTC")).isoformat()

# -------------------------------
# Per-chat accounting
def ensure_chat_struct(chat_id: str) -> Dict[str, Any]:
    data.setdefault("chats", {})
    if chat_id not in data["chats"]:
        data["chats"][chat_id] = {"balance": 0, "records": [], "next_id": 1, "prefix": "C"}
        save_data(data)
    return data["chats"][chat_id]

def make_short_id(chat_info: Dict[str, Any], n: int) -> str:
    return f"{chat_info.get('prefix','C')}{n}"

def add_record_to_chat(chat_id: str, amount: int, note: str, user: str) -> Dict[str, Any]:
    ch = ensure_chat_struct(chat_id)
    rid = ch.get("next_id", 1)
    short = make_short_id(ch, rid)
    rec = {
        "id": rid,
        "short_id": short,
        "timestamp": now_iso_utc(),
        "amount": amount,
        "note": note,
        "user": user
    }
    ch.setdefault("records", []).append(rec)
    ch["next_id"] = rid + 1
    ch["balance"] = ch.get("balance", 0) + amount
    data["global_balance"] = sum([c.get("balance", 0) for c in data.get("chats", {}).values()])
    save_data(data)
    return rec

def find_record_by_short_id(chat_id: str, short_id: str) -> Optional[Dict[str, Any]]:
    ch = data.get("chats", {}).get(chat_id)
    if not ch:
        return None
    for r in ch.get("records", []):
        if r.get("short_id") == short_id:
            return r
    return None

def delete_record_from_chat(chat_id: str, short_id: str) -> bool:
    ch = data.get("chats", {}).get(chat_id)
    if not ch:
        return False
    for r in ch.get("records", []):
        if r.get("short_id") == short_id:
            ch["records"] = [x for x in ch["records"] if x.get("short_id") != short_id]
            ch["balance"] = ch.get("balance", 0) - r.get("amount", 0)
            data["global_balance"] = sum([c.get("balance", 0) for c in data.get("chats", {}).values()])
            save_data(data)
            return True
    return False

def modify_record_in_chat(chat_id: str, short_id: str, new_amount: int, new_note: str) -> bool:
    ch = data.get("chats", {}).get(chat_id)
    if not ch:
        return False
    for i, r in enumerate(ch.get("records", [])):
        if r.get("short_id") == short_id:
            old = r.get("amount", 0)
            ch["records"][i]["amount"] = new_amount
            ch["records"][i]["note"] = new_note
            ch["balance"] = ch.get("balance", 0) - old + new_amount
            data["global_balance"] = sum([c.get("balance", 0) for c in data.get("chats", {}).values()])
            save_data(data)
            return True
    return False

def export_chat_to_csv(chat_id: str, path: str = CSV_FILE) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    rows = []
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
            date_s = ts.strftime("%Y-%m-%d")
            time_s = ts.strftime("%H:%M:%S")
        except Exception:
            date_s = r.get("timestamp", "")
            time_s = ""
        rows.append([r.get("short_id"), date_s, time_s, r.get("amount"), r.get("note"), r.get("user")])
    with open(path, "w", newline="", encoding="utf-8-sig") as f:
        writer = csv.writer(f)
        writer.writerow(["ID", "Дата", "Время", "Сумма", "Комментарий", "Пользователь"])
        for row in rows:
            writer.writerow(row)
    return path

# -------------------------------
# Forward targets helpers
def ensure_forward_list_for(owner_chat_id: str) -> List[str]:
    data.setdefault("forward_targets", {})
    lst = data["forward_targets"].get(owner_chat_id)
    if lst is None:
        data["forward_targets"][owner_chat_id] = []
        save_data(data)
        return data["forward_targets"][owner_chat_id]
    if isinstance(lst, list):
        return lst
    data["forward_targets"][owner_chat_id] = [str(lst)]
    save_data(data)
    return data["forward_targets"][owner_chat_id]

def add_forward_target(owner_chat_id: str, target: str) -> bool:
    lst = ensure_forward_list_for(owner_chat_id)
    t = str(target).strip()
    if t in lst:
        return False
    lst.append(t)
    data["forward_targets"][owner_chat_id] = lst
    save_data(data)
    return True

def remove_forward_target(owner_chat_id: str, target: str) -> bool:
    lst = ensure_forward_list_for(owner_chat_id)
    t = str(target).strip()
    if t in lst:
        lst = [x for x in lst if x != t]
        data["forward_targets"][owner_chat_id] = lst
        save_data(data)
        return True
    return False

def list_forward_targets(owner_chat_id: str) -> List[str]:
    return ensure_forward_list_for(owner_chat_id)

def validate_and_test_target(target_raw: str) -> Tuple[bool, str, str]:
    t_raw = str(target_raw).strip()
    if t_raw.startswith("@"):
        normalized = t_raw
    else:
        try:
            normalized = int(t_raw)
        except Exception:
            normalized = t_raw if t_raw.startswith("@") else "@" + t_raw
    try:
        bot.send_message(normalized, "🔁 Тест от бота: проверка доступа для пересылки.")
        return True, "Тест доставлен.", str(normalized)
    except Exception as e:
        return False, f"Не удалось отправить тест: {e}", str(normalized)

# -------------------------------
# Sending helpers for different media (use file_id to resend)
def record_sent(entry: Dict[str, Any]) -> None:
    data.setdefault("sent_messages", []).append(entry)
    save_data(data)

def send_text(target, text: str, purpose: str="pm_forward_text"):
    try:
        sent = bot.send_message(int(target), text)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "message_id": getattr(sent, "message_id", None), "purpose": purpose, "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose": purpose, "ok": False, "error": str(e)})
        return None

def send_photo_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_photo(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"photo", "ok": False, "error": str(e)})
        return None

def send_document_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_document(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"document", "ok": False, "error": str(e)})
        return None

def send_sticker_by_file_id(target, file_id):
    try:
        sent = bot.send_sticker(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"sticker", "ok": False, "error": str(e)})
        return None

def send_voice_by_file_id(target, file_id):
    try:
        sent = bot.send_voice(int(target), file_id)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"voice", "ok": False, "error": str(e)})
        return None

def send_video_by_file_id(target, file_id, caption=None):
    try:
        sent = bot.send_video(int(target), file_id, caption=caption)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"video", "ok": False, "error": str(e)})
        return None

def send_location(target, latitude, longitude):
    try:
        sent = bot.send_location(int(target), latitude, longitude)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"location", "ok": False, "error": str(e)})
        return None

def send_contact(target, phone_number, first_name, last_name=None):
    try:
        sent = bot.send_contact(int(target), phone_number, first_name, last_name)
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "message_id": getattr(sent, "message_id", None), "ok": True})
        return sent
    except Exception as e:
        record_sent({"timestamp": now_iso_utc(), "to": str(target), "purpose":"contact", "ok": False, "error": str(e)})
        return None

# -------------------------------
# PM-owner forwarding block
def pm_owner_forward_block(message: types.Message) -> bool:
    try:
        if getattr(message.chat, "type", "") != "private":
            return False
        if str(message.from_user.id) != str(OWNER_ID):
            return False
        owner_key = str(OWNER_ID)
        targets = data.get("forward_targets", {}).get(owner_key, []) or []
        if not targets:
            return False
        # text
        if message.content_type == 'text':
            text = (message.text or "").strip()
            if not text:
                return True
            for tgt in targets:
                send_text(tgt, text)
            return True
        # photo
        if message.content_type == 'photo' and getattr(message, "photo", None):
            file_id = message.photo[-1].file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_photo_by_file_id(tgt, file_id, caption=caption)
            return True
        # document
        if message.content_type == 'document' and getattr(message, "document", None):
            file_id = message.document.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_document_by_file_id(tgt, file_id, caption=caption)
            return True
        # audio
        if message.content_type == 'audio' and getattr(message, "audio", None):
            file_id = message.audio.file_id
            for tgt in targets:
                try:
                    bot.send_audio(int(tgt), file_id)
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": True})
                except Exception as e:
                    record_sent({"timestamp": now_iso_utc(), "to": str(tgt), "purpose":"audio", "ok": False, "error": str(e)})
            return True
        # voice
        if message.content_type == 'voice' and getattr(message, "voice", None):
            file_id = message.voice.file_id
            for tgt in targets:
                send_voice_by_file_id(tgt, file_id)
            return True
        # sticker
        if message.content_type == 'sticker' and getattr(message, "sticker", None):
            file_id = message.sticker.file_id
            for tgt in targets:
                send_sticker_by_file_id(tgt, file_id)
            return True
        # video
        if message.content_type == 'video' and getattr(message, "video", None):
            file_id = message.video.file_id
            caption = getattr(message, "caption", None)
            for tgt in targets:
                send_video_by_file_id(tgt, file_id, caption=caption)
            return True
        # location
        if message.content_type == 'location' and getattr(message, "location", None):
            lat = message.location.latitude
            lon = message.location.longitude
            for tgt in targets:
                send_location(tgt, lat, lon)
            return True
        # contact
        if message.content_type == 'contact' and getattr(message, "contact", None):
            phone = message.contact.phone_number
            first = message.contact.first_name
            last = getattr(message.contact, "last_name", None)
            for tgt in targets:
                send_contact(tgt, phone, first, last)
            return True
        # fallback: try forward
        for tgt in targets:
            try:
                try:
                    bot.forward_message(int(tgt), message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
                except Exception:
                    bot.forward_message(tgt, message.chat.id, message.message_id)
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": True})
            except Exception as e:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(message.chat.id), "to": str(tgt), "purpose":"pm_forward_forward", "ok": False, "error": str(e)})
        return True
    except Exception as e:
        print(f"[pm_owner_forward_block] Ошибка: {e}")
        try:
            bot.send_message(int(OWNER_ID), f"⚠️ Ошибка блока пересылки личных сообщений: {e}")
        except Exception:
            pass
        return False

# -------------------------------
# Auto-forward for chats (forward message as forward)
def auto_forward_message_from(chat_id: str, message: types.Message) -> None:
    targets = data.get("forward_targets", {}).get(str(chat_id)) or []
    if not targets:
        return
    for t in targets:
        try:
            try:
                bot.forward_message(int(t), int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
            except Exception:
                bot.forward_message(t, int(chat_id), message.message_id)
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"forward"})
        except Exception as e:
            try:
                if message.content_type == 'text' and getattr(message, "text", None):
                    bot.send_message(t, f"📨 Копия сообщения из {chat_id}:\n\n{message.text}")
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": True, "method":"sent_copy"})
                else:
                    record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e)})
            except Exception as e2:
                record_sent({"timestamp": now_iso_utc(), "from_chat": str(chat_id), "to": str(t), "ok": False, "error": str(e2)})

# -------------------------------
# Build day window per chat
def build_day_window_for_chat(chat_id: str, day_date: str) -> str:
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    recs = []
    for r in ch.get("records", []):
        try:
            ts = datetime.fromisoformat(r["timestamp"]).astimezone(TZ)
        except Exception:
            try:
                ts = datetime.fromisoformat(r["timestamp"])
                ts = ts.astimezone(TZ)
            except Exception:
                ts = None
        if ts and ts.strftime("%Y-%m-%d") == day_date:
            recs.append((ts, r))
    recs.sort(key=lambda x: x[0])
    if not recs:
        return "📘 За этот день ещё нет записей."
    lines = [f"📅 {day_date}\n"]
    day_income = 0
    day_expense = 0
    last_hour = None
    for ts, r in recs:
        hour = ts.strftime("%H")
        if last_hour and hour != last_hour:
            lines.append("")
        last_hour = hour
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        sid = r.get("short_id")
        note = r.get("note", "")
        t_local = ts.strftime("%H:%M")
        lines.append(f"🕓 {t_local} | {sid} | {sign}{fmt_amount(amt)} {note}".rstrip())
        if amt > 0:
            day_income += amt
        else:
            day_expense += abs(amt)
    overall = data.get("chats", {}).get(chat_id, {}).get("balance", 0)
    lines.append("")
    lines.append(f"📈 Приход дня: {fmt_amount(day_income)}")
    lines.append(f"📉 Расход дня: {fmt_amount(day_expense)}")
    lines.append(f"💵 Баланс чата: {fmt_amount(overall)}")
    return "\n".join(lines)

# Keyboards for inline editing
def kb_day_main():
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("Редактировать", callback_data="edit_menu"))
    return kb

def kb_edit_main(chat_id=None):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("Изменить запись", callback_data="edit_modify"))
    kb.add(types.InlineKeyboardButton("Удалить запись", callback_data="edit_delete"))
    kb.add(types.InlineKeyboardButton("📄 Экспорт CSV", callback_data="edit_export_csv"))
    kb.add(types.InlineKeyboardButton("Обнулить всё (всех)", callback_data="edit_reset_all"))
    target = data.get("forward_targets", {}).get(str(chat_id)) if chat_id is not None else None
    if target:
        kb.add(types.InlineKeyboardButton("🚫 Отключить пересылку", callback_data="forward_cancel"))
    else:
        kb.add(types.InlineKeyboardButton("📤 Пересылка", callback_data="forward_setup"))
    kb.add(types.InlineKeyboardButton("Отмена", callback_data="edit_cancel"))
    return kb

def kb_forward_menu(chat_id=None):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("🔧 Установить пересылку (перешли сообщение из нужного чата)", callback_data="forward_setup"))
    kb.add(types.InlineKeyboardButton("❌ Отключить пересылку", callback_data="forward_cancel"))
    kb.add(types.InlineKeyboardButton("ℹ️ Проверить текущую", callback_data="forward_check"))
    kb.add(types.InlineKeyboardButton("Отмена", callback_data="edit_cancel"))
    return kb

def kb_records_list(chat_id, day_date, mode):
    kb = types.InlineKeyboardMarkup()
    recs = []
    ch = data.get("chats", {}).get(str(chat_id), {"records": []})
    for ts, r in sorted([(datetime.fromisoformat(x["timestamp"]).astimezone(TZ), x) for x in ch.get("records", [])], key=lambda xx: xx[0]):
        if ts.strftime("%Y-%m-%d") != day_date:
            continue
        sid = r.get("short_id")
        amt = r["amount"]
        sign = "+" if amt > 0 else "-"
        label = f"[{sid}] {sign}{fmt_amount(amt)} {r.get('note','')}"
        recs.append((sid, label))
    if not recs:
        kb.add(types.InlineKeyboardButton("Нет записей за этот день", callback_data="no_op"))
        kb.add(types.InlineKeyboardButton("Назад", callback_data="edit_menu"))
        return kb
    for sid, label in recs:
        kb.add(types.InlineKeyboardButton(label[:60], callback_data=f"select:{mode}:{sid}"))
    kb.add(types.InlineKeyboardButton("Назад", callback_data="edit_menu"))
    return kb

def kb_yes_no(cb_prefix):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("Да", callback_data=f"{cb_prefix}_yes"),
           types.InlineKeyboardButton("Нет", callback_data=f"{cb_prefix}_no"))
    return kb

# -------------------------------
pending_actions: Dict[str, Dict[str, Any]] = {}

# -------------------------------
# Message handler
@bot.message_handler(func=lambda m: True, content_types=['text','photo','document','audio','video','voice','sticker','animation','contact','location'])
def handle_any_message(message: types.Message):
    global data
    chat_id = message.chat.id
    data = load_data()

    # 0) PM-owner forwarding: if private and from OWNER -> send copies to targets and stop
    handled = pm_owner_forward_block(message)
    if handled:
        return

    # 1) pending actions
    pa = pending_actions.get(str(chat_id))
    if pa:
        t = pa.get("type")
        if t == "await_forward_setup":
            target = None
            if getattr(message, "forward_from_chat", None):
                try:
                    target = str(message.forward_from_chat.id)
                except Exception:
                    target = None
            elif getattr(message, "forward_from", None):
                try:
                    target = str(message.forward_from.id)
                except Exception:
                    target = None
            elif message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() == "отмена":
                    send_text(chat_id, "Отменено")
                    pending_actions.pop(str(chat_id), None)
                    return
                target = txt
            if not target:
                send_text(chat_id, "❌ Неверный идентификатор. Отмена.")
                pending_actions.pop(str(chat_id), None)
                return
            ok, msg_text, norm = validate_and_test_target(target)
            if ok:
                added = add_forward_target(str(chat_id), norm)
                if added:
                    send_text(chat_id, f"✅ Пересылка добавлена: {norm}")
                else:
                    send_text(chat_id, f"ℹ️ Цель уже в списке: {norm}")
            else:
                send_text(chat_id, f"❌ {msg_text}")
            pending_actions.pop(str(chat_id), None)
            return

        if t == "await_modify_input":
            short = pa["payload"]["short_id"]
            text = (message.text or "").strip()
            ok = False
            if text:
                num, sign, raw = parse_first_number(text)
                if num is not None:
                    new_amt = apply_sign_and_normalize(num, sign)
                    note = text[(text.find(raw)+len(raw)):].strip() if raw in text else ""
                    ok = modify_record_in_chat(str(chat_id), short, new_amt, note)
            if ok:
                send_text(chat_id, f"✅ Запись {short} обновлена.")
            else:
                send_text(chat_id, f"❗ Не удалось обновить запись {short}. Пример: +1000 зарплата")
            pending_actions.pop(str(chat_id), None)
            # refresh day window
            today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            try:
                update_day_window_after_change(chat_id, today)
            except Exception:
                pass
            return

        if t == "await_remove_forward":
            if message.content_type == 'text':
                txt = (message.text or "").strip()
                if txt.lower() in ('всё','все','all'):
                    data["forward_targets"].pop(str(chat_id), None)
                    save_data(data)
                    send_text(chat_id, "✅ Все цели пересылки удалены.")
                else:
                    removed = remove_forward_target(str(chat_id), txt)
                    if removed:
                        send_text(chat_id, f"✅ Цель {txt} удалена.")
                    else:
                        send_text(chat_id, f"❗ Цель {txt} не найдена.")
            else:
                send_text(chat_id, "❌ Неверный ввод, отменено.")
            pending_actions.pop(str(chat_id), None)
            return

    # 2) Auto-forward from group/chat if configured (for readers who set per-chat forward)
    try:
        auto_forward_message_from(str(chat_id), message)
    except Exception as e:
        print(f"[auto_forward] Ошибка: {e}")

    # 3) Accounting: messages of any participants in groups + private (per-chat accounting)
    if message.content_type == 'text':
        text = (message.text or "").strip()
        lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
        any_added = False
        for line in lines:
            num, sign, raw = parse_first_number(line)
            if num is None:
                continue
            amt_signed = apply_sign_and_normalize(num, sign)
            note = line[(line.find(raw) + len(raw)):].strip() if raw in line else ""
            user_display = (message.from_user.username or message.from_user.first_name or str(message.from_user.id))
            add_record_to_chat(str(chat_id), amt_signed, note, user_display)
            any_added = True
        if any_added:
            today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
            try:
                update_day_window_after_change(chat_id, today)
            except Exception as e:
                print(f"[day window update] {e}")
        return

# -------------------------------
# Update day window with editing and forwarding
def update_day_window_after_change(chat_id, day_date, purpose="day_window"):
    # build text
    text = build_day_window_for_chat(str(chat_id), day_date)
    kb = kb_day_main()
    prev = data.get("active_messages", {}).get(day_date, {}).get(str(chat_id))
    # Try to edit existing message (search in active_messages structure)
    # Our active_messages: day -> { "<chat_id>": {"chat_id":id, "message_id": id} }
    try:
        day_map = data.get("active_messages", {}).get(day_date, {})
        prev_entry = day_map.get(str(chat_id))
        if prev_entry and int(prev_entry.get("chat_id")) == int(chat_id):
            try:
                bot.edit_message_text(chat_id=int(chat_id), message_id=int(prev_entry.get("message_id")), text=text, reply_markup=kb)
                # record as edited
                fake_msg = types.Message.de_json({"message_id": int(prev_entry.get("message_id"))}, bot)
                record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(prev_entry.get("message_id")), "purpose": purpose, "ok": True})
                save_data(data)
                return prev_entry
            except Exception as e:
                print(f"[update_day_window] edit failed: {e}")
        # send new
        sent = bot.send_message(int(chat_id), text, reply_markup=kb)
        data.setdefault("active_messages", {}).setdefault(day_date, {})[str(chat_id)] = {"chat_id": int(chat_id), "message_id": int(sent.message_id)}
        record_sent({"timestamp": now_iso_utc(), "chat_id": int(chat_id), "message_id": int(sent.message_id), "purpose": purpose, "ok": True})
        save_data(data)
    except Exception as e:
        print(f"[update_day_window] failed to send: {e}")

    # forward the day window if forward_targets set for this chat (not owner's personal forward)
    forward_targets_map = data.get("forward_targets", {})
    forward_target = forward_targets_map.get(str(chat_id))
    if forward_target:
        for ft in forward_target:
            try:
                try:
                    bot.forward_message(int(ft), int(chat_id), sent.message_id)
                except Exception:
                    bot.forward_message(ft, int(chat_id), sent.message_id)
            except Exception as e:
                print(f"[update_day_window] forward failed to {ft}: {e}")

# -------------------------------
# Callback handler (inline)
@bot.callback_query_handler(func=lambda call: True)
def callback_worker(call: types.CallbackQuery):
    data_local = load_data()
    data_call = call.data or ""
    chat_id = call.message.chat.id
    call_msg = call.message
    today = datetime.now(tz=TZ).strftime("%Y-%m-%d")
    try:
        bot.answer_callback_query(call.id)
    except Exception:
        pass

    if data_call == "edit_menu":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
        except Exception:
            send_text(chat_id, "Меню редактирования:",)
        return

    if data_call == "edit_cancel":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_day_main())
        except Exception:
            try:
                send_text(chat_id, build_day_window_for_chat(str(chat_id), today))
            except Exception:
                pass
        return

    if data_call == "edit_modify":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_records_list(chat_id, today, mode="modify"))
        except Exception:
            send_text(chat_id, "Выбор записи для изменения:",)
        return

    if data_call == "edit_delete":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_records_list(chat_id, today, mode="delete"))
        except Exception:
            send_text(chat_id, "Выбор записи для удаления:",)
        return

    if data_call in ("edit_export_csv",):
        try:
            path = export_chat_to_csv(str(chat_id), CSV_FILE)
            bot.send_document(chat_id, open(path, "rb"))
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
            except Exception:
                pass
        except Exception as e:
            print(f"[export csv] {e}")
            send_text(chat_id, "Ошибка при создании CSV.")
        return

    if data_call == "forward_setup":
        send_text(chat_id, "Перешлите сюда сообщение из нужного чата/канала или введите chat_id/@username. Отправьте 'отмена' для отказа.")
        pending_actions[str(chat_id)] = {"type":"await_forward_setup","payload":{}}
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=None)
        except Exception:
            pass
        return

    if data_call == "forward_check":
        ft = data.get("forward_targets", {}).get(str(chat_id))
        if ft:
            send_text(chat_id, f"📨 Текущие цели: {', '.join(ft)}")
        else:
            send_text(chat_id, "🔕 Пересылка не установлена.")
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
        except Exception:
            pass
        return

    if data_call == "forward_cancel":
        ft = data.get("forward_targets", {})
        if str(chat_id) in ft:
            ft.pop(str(chat_id), None)
            data["forward_targets"] = ft
            save_data(data)
            send_text(chat_id, "✅ Пересылка отключена.")
        else:
            send_text(chat_id, "Пересылка не была настроена.")
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
        except Exception:
            pass
        return

    if data_call.startswith("select:"):
        parts = data_call.split(":", 2)
        if len(parts) != 3:
            send_text(chat_id, "Неверный выбор.")
            return
        mode = parts[1]
        short_id = parts[2]
        if mode == "modify":
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=None)
            except Exception:
                pass
            send_text(chat_id, f"Введите новое значение для {short_id} (пример: +1000 зарплата).")
            pending_actions[str(chat_id)] = {"type":"await_modify_input","payload":{"short_id": short_id}}
            return
        elif mode == "delete":
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_yes_no(f"confirm_delete:{short_id}"))
            except Exception:
                send_text(chat_id, f"Удалить запись {short_id}?",)
            return
        else:
            send_text(chat_id, "Неподдерживаемый режим выбора.")
            return

    if data_call.startswith("confirm_delete:"):
        tail = data_call[len("confirm_delete:"):]
        if tail.endswith("_yes"):
            short_id = tail[:-4]
            ok = delete_record_from_chat(str(chat_id), short_id)
            if ok:
                try:
                    bot.edit_message_text(f"✅ Запись {short_id} удалена.", call_msg.chat.id, call_msg.message_id)
                except Exception:
                    send_text(chat_id, f"✅ Запись {short_id} удалена.")
                # refresh window
                try:
                    update_day_window_after_change(chat_id, today)
                except Exception:
                    pass
            else:
                try:
                    bot.edit_message_text(f"❗ Не удалось удалить запись {short_id}.", call_msg.chat.id, call_msg.message_id)
                except Exception:
                    send_text(chat_id, f"❗ Не удалось удалить запись {short_id}.")
        else:
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
            except Exception:
                send_text(chat_id, "Удаление отменено.",)
        return

    if data_call == "edit_reset_all":
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_yes_no("confirm_reset_all"))
        except Exception:
            send_text(chat_id, "Вы уверены, что хотите обнулить ВСЕ данные навсегда? (Да/Нет)")
        return

    if data_call.startswith("confirm_reset_all"):
        if data_call.endswith("_yes"):
            data.update(default_data())
            save_data(data)
            try:
                bot.edit_message_text("♻️ Все данные обнулены.", call_msg.chat.id, call_msg.message_id)
            except Exception:
                send_text(chat_id, "♻️ Все данные обнулены.")
        else:
            try:
                bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_edit_main(chat_id))
            except Exception:
                send_text(chat_id, "Обнуление отменено.")
        return

    if data_call in ("no_op",):
        try:
            bot.edit_message_reply_markup(call_msg.chat.id, call_msg.message_id, reply_markup=kb_day_main())
        except Exception:
            try:
                send_text(chat_id, build_day_window_for_chat(str(chat_id), today))
            except Exception:
                pass
        return

    print("Unhandled callback:", data_call)

# -------------------------------
# Commands (forward management and accounting)
@bot.message_handler(commands=['addforward'])
def cmd_addforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "⛔ Только владелец может управлять пересылкой.")
        return
    send_text(message.chat.id, "Перешлите мне сообщение из целевого чата/канала или отправьте chat_id/@username.")
    pending_actions[str(message.chat.id)] = {"type": "await_forward_setup", "payload": {}}

@bot.message_handler(commands=['removeforward'])
def cmd_removeforward(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "⛔ Только владелец может управлять пересылкой.")
        return
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "Список пересылки пуст.")
        return
    send_text(message.chat.id, "Список целей:\n" + "\n".join(lst) + "\nОтправь цель для удаления или 'всё' для очистки.")
    pending_actions[str(message.chat.id)] = {"type": "await_remove_forward", "payload": {}}

@bot.message_handler(commands=['listforwards'])
def cmd_listforwards(message: types.Message):
    lst = list_forward_targets(str(message.chat.id))
    if not lst:
        send_text(message.chat.id, "Пересылка не настроена.")
    else:
        send_text(message.chat.id, "Текущие цели:\n" + "\n".join(lst))

@bot.message_handler(commands=["баланс"])
def cmd_balance(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"balance": 0})
    bot.reply_to(message, f"💰 Баланс этого чата: {fmt_amount(ch.get('balance', 0))}")

@bot.message_handler(commands=["отчет"])
def cmd_report(message: types.Message):
    chat_id = str(message.chat.id)
    ch = data.get("chats", {}).get(chat_id, {"records": []})
    if not ch.get("records"):
        bot.reply_to(message, "Пока нет записей в этом чате.")
        return
    try:
        path = export_chat_to_csv(chat_id, CSV_FILE)
        bot.send_document(message.chat.id, open(path, "rb"))
    except Exception as e:
        bot.reply_to(message, f"Ошибка при экспорте: {e}")

@bot.message_handler(commands=["сброс"])
def cmd_reset(message: types.Message):
    if str(message.from_user.id) != str(OWNER_ID):
        bot.reply_to(message, "⛔ Только владелец может обнулить данные.")
        return
    data.update(default_data())
    save_data(data)
    bot.reply_to(message, "♻️ Все данные обнулены (глобально).")

# -------------------------------
# Webhook endpoint
@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    try:
        json_str = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
    except Exception as e:
        print(f"[webhook] Ошибка обработки update: {e}")
    return '', 200

@app.route("/", methods=['GET'])
def index():
    return f"🤖 Бот 'ФО' v{VERSION} работает."

# -------------------------------
def set_webhook_if_possible():
    try:
        host = os.getenv("RENDER_EXTERNAL_HOSTNAME")
        if host:
            url = f"https://{host}{WEBHOOK_PATH}"
            bot.remove_webhook()
            time.sleep(0.3)
            bot.set_webhook(url=url)
            print(f"[startup] Webhook установлен: {url}")
            if OWNER_ID:
                try:
                    bot.send_message(int(OWNER_ID), f"✅ Бот v{VERSION}: webhook активирован.")
                except Exception:
                    pass
    except Exception as e:
        print(f"[set_webhook_if_possible] {e}")

# -------------------------------
if __name__ == "__main__":
    print(f"Запуск бота 'ФО' v{VERSION} ...")
    save_data(data)
    set_webhook_if_possible()
    try:
        bot.send_message(int(OWNER_ID), f"✅ Бот v{VERSION} запущен и готов.")
    except Exception:
        pass
    app.run(host="0.0.0.0", port=PORT)

# -------------------------------
# EOF
# -------------------------------