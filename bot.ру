# ============================================
# Финансовый бот — версия 9.6.1.6
# Полная версия
# Примечание: интерфейс на русском, команды латиницей.
# ОТСЕКИ пронумерованы в заголовках.
# ============================================



# -----------------------------
# ОТСЕК 1 — Импорты и настройки
# -----------------------------
import os
import json
import csv              # ✅ добавлен явный импорт CSV
import logging
import requests
import re
from datetime import datetime
from zoneinfo import ZoneInfo

import telebot
from flask import Flask, request
from telebot import types

# --------------------------------------------
# Настройки окружения и константы
# --------------------------------------------
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")  # строка или число
APP_URL = os.getenv("APP_URL", "https://fo-1.onrender.com")  # URL приложения для webhook
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
LOG_FILE = "log.txt"
PORT = int(os.environ.get("PORT", 5000))
VERSION = "9.6.1.7"

if not TOKEN:
    raise ValueError("BOT_TOKEN не установлен в переменных окружения!")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

log_info = logging.info
log_error = logging.error

# --------------------------------------------
# Настройки окружения и константы
# --------------------------------------------
TOKEN = os.getenv("BOT_TOKEN")
OWNER_ID = os.getenv("OWNER_ID")  # строка или число
APP_URL = os.getenv("APP_URL", "https://fo-1.onrender.com")  # URL приложения, используется для webhook
TZ = ZoneInfo("America/Argentina/Catamarca")
DATA_FILE = "data.json"
CSV_FILE = "data.csv"
LOG_FILE = "log.txt"
PORT = int(os.environ.get("PORT", 5000))
VERSION = "9.6.1.6"

if not TOKEN:
    raise ValueError("BOT_TOKEN не установлен в переменных окружения!")

bot = telebot.TeleBot(TOKEN, threaded=True)
app = Flask(__name__)

# --------------------------------------------
# ОТСЕК 2 — Логирование
# --------------------------------------------
logging.basicConfig(
    level=logging.INFO,
    format="[{asctime}] {levelname}: {message}",
    style="{",
    handlers=[
        logging.FileHandler(LOG_FILE, encoding="utf-8"),
        logging.StreamHandler()
    ]
)

def log_info(msg):
    logging.info(msg)

def log_error(msg):
    logging.error(msg)

log_info(f"Старт приложения. Версия {VERSION}")

# --------------------------------------------
# ОТСЕК 3 — Структура данных и работа с файлом
# --------------------------------------------
def default_data():
    return {
        "chats": {},  # chat_id -> { balance, records:[], next_id, daily_records: {YYYY-MM-DD: [rec,...]} }
        "forward_targets": [],  # список chat_id (int)
        "tracked_messages": {},  # для временных состояний редактирования: chat_id -> {user_id: state}
        "processed_messages": [],  # список ключей "chat_id:message_id" чтобы не обрабатывать одно и то же сообщение дважды
    }

def load_data():
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r", encoding="utf-8") as f:
                d = json.load(f)
        except Exception as e:
            log_error(f"Ошибка загрузки data.json: {e}")
            d = default_data()
    else:
        d = default_data()
    # Ensure keys
    for k, v in default_data().items():
        if k not in d:
            d[k] = v
    return d

def save_data(d):
    try:
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump(d, f, ensure_ascii=False, indent=2)
    except Exception as e:
        log_error(f"Ошибка сохранения data.json: {e}")

def export_to_csv(d):
    try:
        with open(CSV_FILE, "w", newline='', encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerow(["chat_id","ID","short_id","timestamp","amount","note","owner"])
            for cid, cdata in d.get("chats", {}).items():
                for r in cdata.get("records", []):
                    writer.writerow([cid, r.get("id"), r.get("short_id"), r.get("timestamp"), r.get("amount"), r.get("note"), r.get("owner")])
    except Exception as e:
        log_error(f"Ошибка экспорта CSV: {e}")

data = load_data()

# если OWNER_ID задан в окружении — убедимся что он есть в списке forward_targets
if OWNER_ID:
    try:
        owner_int = int(OWNER_ID)
    except Exception:
        owner_int = None
    if owner_int is not None and owner_int not in data["forward_targets"]:
        data["forward_targets"].append(owner_int)
        save_data(data)

# Обновлённая функция получения/инициализации хранилища чата
def get_chat_store(chat_id):
    chat_id = str(chat_id)
    if chat_id not in data["chats"]:
        data["chats"][chat_id] = {
            "balance": 0,
            "records": [],
            "next_id": 1,
            "daily_records": {}  # YYYY-MM-DD -> [rec, ...]
        }
        save_data(data)
    # гарантируем поля в существующем хранилище
    store = data["chats"][chat_id]
    if "daily_records" not in store:
        store["daily_records"] = {}
    if "records" not in store:
        store["records"] = []
    if "next_id" not in store:
        store["next_id"] = 1
    if "balance" not in store:
        store["balance"] = 0
    return store

# утилиты для ежедневных записей
def add_record_to_chat(chat_id, amount, note, owner):
    """
    Добавляет запись и в общий список chat.records, и в daily_records[current_date].
    Пересчитывает баланс для этого чата.
    """
    store = get_chat_store(chat_id)
    ts = datetime.now(TZ)
    ts_iso = ts.isoformat()
    rid = store.get("next_id", 1)
    rec = {
        "id": rid,
        "short_id": f"R{rid}",
        "timestamp": ts_iso,
        "amount": amount,
        "note": note,
        "owner": owner
    }
    store.setdefault("records", []).append(rec)
    # daily
    today = ts.strftime("%Y-%m-%d")
    dr = store.setdefault("daily_records", {})
    day_list = dr.setdefault(today, [])
    day_list.append(rec)
    # update counters
    store["balance"] = sum([r["amount"] for r in store.get("records", [])])
    store["next_id"] = rid + 1
    save_data(data)
    export_to_csv(data)
    if amount >= 0:
        log_info(f"[CHAT {chat_id}] ПРИХОД: +{amount} {note}")
    else:
        log_info(f"[CHAT {chat_id}] РАСХОД: {amount} {note}")
    return rec

def delete_record_in_chat(chat_id, rec_id):
    store = get_chat_store(chat_id)
    recs = store.get("records", [])
    to_del = None
    for r in recs:
        if r["id"] == rec_id or str(r["id"]) == str(rec_id) or r["short_id"] == f"R{rec_id}":
            to_del = r
            break
    if not to_del:
        return False, None
    recs.remove(to_del)
    # удалить из daily_records (если возможно)
    for day, lst in store.get("daily_records", {}).items():
        lst[:] = [x for x in lst if not (x.get("id") == to_del.get("id"))]
    # recalc balance
    store["balance"] = sum([r["amount"] for r in recs])
    save_data(data)
    export_to_csv(data)
    return True, to_del

def update_record_in_chat(chat_id, rec_id, new_amount, new_note):
    store = get_chat_store(chat_id)
    recs = store.get("records", [])
    found = None
    for r in recs:
        if r["id"] == rec_id or str(r["id"]) == str(rec_id) or r["short_id"] == f"R{rec_id}":
            found = r
            break
    if not found:
        return False, None
    # update record fields
    found["amount"] = new_amount
    found["note"] = new_note
    # update in daily_records as well (find by id)
    for day, lst in store.get("daily_records", {}).items():
        for item in lst:
            if item.get("id") == found.get("id"):
                item["amount"] = new_amount
                item["note"] = new_note
    # recompute balance
    store["balance"] = sum([r["amount"] for r in recs])
    save_data(data)
    export_to_csv(data)
    return True, found

# --------------------------------------------
# ОТСЕК 4 — Вспомогательные функции (парсинг, чат-менеджмент)
# --------------------------------------------
# Разбор первой найденной цифры в строке (с учётом знаков и пробелов)
num_re = re.compile(r'([+-]?\s*\d+)')

def extract_first_number(s):
    """
    Ищет первое вхождение числа в строке. Возвращает (amount:int, raw_token:str) или (None, None)
    Правила:
    - допускается пробел между знаком и цифрой: "+ 100" или "-  50"
    - возвращаемое число учитывает знак
    """
    if not s:
        return None, None
    m = num_re.search(s)
    if not m:
        return None, None
    token = m.group(1)
    # удаляем пробелы внутри токена
    token_clean = token.replace(" ", "")
    try:
        amt = int(token_clean)
    except Exception:
        return None, None
    return amt, token.strip()

def get_chat_store(chat_id):
    """Возвращает или инициализирует структуру данных для чата"""
    chat_id = str(chat_id)
    if chat_id not in data["chats"]:
        data["chats"][chat_id] = {
            "balance": 0,
            "records": [],
            "next_id": 1
        }
        save_data(data)
    return data["chats"][chat_id]

def add_record_to_chat(chat_id, amount, note, owner):
    store = get_chat_store(chat_id)
    ts = datetime.now(TZ).isoformat()
    rid = store.get("next_id", 1)
    rec = {
        "id": rid,
        "short_id": f"R{rid}",
        "timestamp": ts,
        "amount": amount,
        "note": note,
        "owner": owner
    }
    store.setdefault("records", []).append(rec)
    store["balance"] = store.get("balance", 0) + amount
    store["next_id"] = rid + 1
    save_data(data)
    export_to_csv(data)
    if amount >= 0:
        log_info(f"[CHAT {chat_id}] ПРИХОД: +{amount} {note}")
    else:
        log_info(f"[CHAT {chat_id}] РАСХОД: {amount} {note}")
    return rec

def delete_record_in_chat(chat_id, rec_id):
    store = get_chat_store(chat_id)
    recs = store.get("records", [])
    to_del = None
    for r in recs:
        if r["id"] == rec_id or str(r["id"]) == str(rec_id) or r["short_id"] == f"R{rec_id}":
            to_del = r
            break
    if not to_del:
        return False, None
    recs.remove(to_del)
    store["balance"] = sum([r["amount"] for r in recs])
    save_data(data)
    export_to_csv(data)
    return True, to_del

def update_record_in_chat(chat_id, rec_id, new_amount, new_note):
    store = get_chat_store(chat_id)
    recs = store.get("records", [])
    found = None
    for r in recs:
        if r["id"] == rec_id or str(r["id"]) == str(rec_id) or r["short_id"] == f"R{rec_id}":
            found = r
            break
    if not found:
        return False, None
    found["amount"] = new_amount
    found["note"] = new_note
    # recompute balance
    store["balance"] = sum([r["amount"] for r in recs])
    save_data(data)
    export_to_csv(data)
    return True, found

# --------------------------------------------
# ОТСЕК 5 — Клавиатуры и кнопки (компактная + баланс + назад)
# --------------------------------------------
from telebot import types

def build_main_keyboard(chat_id=None):
    """
    Главное меню. Если передан chat_id — внизу показываем баланс и кнопку Назад.
    """
    kb = types.InlineKeyboardMarkup()
    kb.row(
        types.InlineKeyboardButton("💰 Баланс", callback_data="btn_balance"),
        types.InlineKeyboardButton("📊 Отчёт", callback_data="btn_report")
    )
    kb.row(
        types.InlineKeyboardButton("✏️ Редактировать", callback_data="btn_edit"),
        types.InlineKeyboardButton("⚙️ Сброс", callback_data="btn_reset")
    )
    kb.row(
        types.InlineKeyboardButton("🚀 Старт", callback_data="btn_start"),
        types.InlineKeyboardButton("📘 О коде", callback_data="btn_cod")
    )

    # Нижняя строка: Назад (если нужно) и показатель баланса (если есть chat_id)
    footer_left = types.InlineKeyboardButton("🔙 Назад", callback_data="btn_back")
    if chat_id is None:
        footer_right = types.InlineKeyboardButton(" ", callback_data="noop")
    else:
        store = get_chat_store(chat_id)
        footer_right = types.InlineKeyboardButton(f"💰 {store.get('balance',0)} ars", callback_data="noop")
    kb.row(footer_left, footer_right)
    return kb


def build_edit_list_keyboard(chat_id, include_back=True):
    """
    Список транзакций с кнопками ✏ и 🗑 (компактнее).
    """
    store = get_chat_store(chat_id)
    kb = types.InlineKeyboardMarkup()
    records = store.get("records", [])[-20:]
    if not records:
        kb.add(types.InlineKeyboardButton("Нет записей", callback_data="noop"))
        kb.row(types.InlineKeyboardButton("🔙 Назад", callback_data="btn_back"),
               types.InlineKeyboardButton(f"💰 {store.get('balance',0)} ARS", callback_data="noop"))
        return kb

    for r in records:
        sign = "+" if r["amount"] > 0 else ""
        label = f"{r['short_id']}: {sign}{r['amount']} {r.get('note','')}"
        # компактные кнопки ✏ и 🗑
        kb.row(
            types.InlineKeyboardButton(label, callback_data=f"noop_row:{r['id']}"),
            types.InlineKeyboardButton("✎", callback_data=f"edit_select:{r['id']}"),
            types.InlineKeyboardButton("❌", callback_data=f"delete_record:{r['id']}")
        )

    kb.row(types.InlineKeyboardButton("🔙 Назад", callback_data="btn_back"),
           types.InlineKeyboardButton(f"💰 {store.get('balance',0)} ARS", callback_data="noop"))
    return kb

# 6--------------------------------------------
# ОТСЕК 6 — Команды (основные)
# --------------------------------------------
@bot.message_handler(commands=["start"])
def cmd_start(msg):
    text = (
        "👋 Добро пожаловать в Финансовый бот «ФО»\n\n"
        "Команды (латиницей):\n"
        "/start – показать справку\n"
        "/myid – показать ваш user ID\n"
        "/chatid – показать ID чата\n"
        "/balance – показать текущий баланс (для текущего чата)\n"
        "/report – показать последние операции (для текущего чата)\n"
        "/reset – обнулить все данные (только владелец)\n"
        "/addforward <chat_id> – добавить цель для пересылки (только владелец)\n"
        "/removeforward <chat_id> – убрать цель пересылки (только владелец)\n"
        "/listforwards – список целей пересылки\n"
        "/cod – информация о версии и обновлениях\n"
        "/edit – редактирование транзакций (список и выбор)\n"
        "/delete <номер> – удалить запись по номеру\n\n"
        "Для записи транзакции отправьте одну или несколько строк, каждая строка отдельный учёт.\n"
        "Примеры:\n+1000 зарплата\n-123 хлеб\n200 сок\n"
    )
    bot.send_message(msg.chat.id, f"💬 Версия: {VERSION}\n\n{text}", reply_markup=build_main_keyboard())

@bot.message_handler(commands=["myid"])
def cmd_myid(msg):
    uid = msg.from_user.id
    bot.reply_to(msg, f"🆔 Ваш user ID: {uid}")

@bot.message_handler(commands=["chatid"])
def cmd_chatid(msg):
    cid = msg.chat.id
    bot.reply_to(msg, f"💬 ID текущего чата: {cid}")

@bot.message_handler(commands=["balance"])
def cmd_balance(msg):
    store = get_chat_store(msg.chat.id)
    bot.reply_to(msg, f"💰 Баланс этого чата: {store.get('balance',0)} ars", reply_markup=build_main_keyboard())

@bot.message_handler(commands=["report"])
def cmd_report(msg):
    store = get_chat_store(msg.chat.id)
    recs = store.get("records", [])
    if not recs:
        bot.send_message(msg.chat.id, "Пока нет операций в этом чате.", reply_markup=build_main_keyboard())
        return
    text_lines = ["📋 Последние операции этого чата:"]
    for r in recs[-50:]:
        sign = "+" if r["amount"] > 0 else ""
        text_lines.append(f"{r['short_id']}: {sign}{r['amount']} — {r.get('note','')}")
    bot.send_message(msg.chat.id, "\n".join(text_lines), reply_markup=build_main_keyboard())

@bot.message_handler(commands=["reset"])
def cmd_reset(msg):
    if OWNER_ID is None or str(msg.from_user.id) != str(OWNER_ID):
        bot.send_message(msg.chat.id, "Только владелец может сбрасывать данные.", reply_markup=build_main_keyboard())
        return
    global data
    data = default_data()
    try:
        if OWNER_ID:
            data["forward_targets"].append(int(OWNER_ID))
    except Exception:
        pass
    save_data(data)
    export_to_csv(data)
    bot.send_message(msg.chat.id, "✅ Все данные сброшены.", reply_markup=build_main_keyboard())
    log_info("ДАННЫЕ ОБНУЛЕНЫ владельцем")

@bot.message_handler(commands=["addforward"])
def cmd_addforward(msg):
    if OWNER_ID is None or str(msg.from_user.id) != str(OWNER_ID):
        return
    parts = msg.text.split()
    if len(parts) < 2:
        bot.reply_to(msg, "Использование: /addforward <chat_id>")
        return
    try:
        cid = int(parts[1])
    except Exception:
        bot.reply_to(msg, "Неверный chat_id (должно быть число).")
        return
    if cid in data["forward_targets"]:
        bot.reply_to(msg, "Этот чат уже в списке пересылки.")
        return
    data["forward_targets"].append(cid)
    save_data(data)
    bot.reply_to(msg, f"✅ Цель пересылки добавлена: {cid}")

@bot.message_handler(commands=["removeforward"])
def cmd_removeforward(msg):
    if OWNER_ID is None or str(msg.from_user.id) != str(OWNER_ID):
        return
    parts = msg.text.split()
    if len(parts) < 2:
        bot.reply_to(msg, "Использование: /removeforward <chat_id>")
        return
    try:
        cid = int(parts[1])
    except Exception:
        bot.reply_to(msg, "Неверный chat_id (должно быть число).")
        return
    if cid not in data["forward_targets"]:
        bot.reply_to(msg, "Этот чат не в списке пересылки.")
        return
    data["forward_targets"].remove(cid)
    save_data(data)
    bot.reply_to(msg, f"✅ Цель пересылки удалена: {cid}")

@bot.message_handler(commands=["listforwards"])
def cmd_listforwards(msg):
    if not data["forward_targets"]:
        bot.reply_to(msg, "Список пересылки пуст.", reply_markup=build_main_keyboard())
        return
    text = "📨 Цели пересылки:\n" + "\n".join(map(str, data["forward_targets"]))
    bot.reply_to(msg, text, reply_markup=build_main_keyboard())

@bot.message_handler(commands=["cod"])
def cmd_cod(msg):
    text = (
        f"📘 Информация о коде — версия {VERSION}\n\n"
        "Краткое структурное описание:\n"
        "- Интерфейс полностью на русском языке\n"
        "- Команды остаются на латинице\n"
        "- Добавлены inline-кнопки для быстрого доступа\n"
        "- Автоматическая установка webhook при запуске\n"
        "- Пересылка сообщений от владельца в указанные чаты (без эха)\n"
        "- Отдельный учёт по каждому чату\n"
        "- Редактирование записей через /edit и /delete\n"
        "- Каждая строка сообщения = отдельная запись\n\n"
        "Последнее обновление: добавлена версия 9.6.1.6 — сегментированный учёт, улучшенная пересылка, редактирование."
    )
    bot.send_message(msg.chat.id, text, reply_markup=build_main_keyboard())

@bot.message_handler(commands=["edit"])
def cmd_edit(msg):
    kb = build_edit_list_keyboard(msg.chat.id)
    if not kb.keyboard:
        bot.reply_to(msg, "Нет записей для редактирования в этом чате.", reply_markup=build_main_keyboard())
        return
    bot.send_message(msg.chat.id, "Выберите запись для редактирования:", reply_markup=kb)

@bot.message_handler(commands=["delete"])
def cmd_delete(msg):
    parts = msg.text.split()
    if len(parts) < 2:
        bot.reply_to(msg, "Использование: /delete <номер или Rномер>")
        return
    token = parts[1].strip()
    if token.upper().startswith("R"):
        token = token[1:]
    try:
        rid = int(token)
    except Exception:
        bot.reply_to(msg, "Неверный номер записи.")
        return
    ok, rec = delete_record_in_chat(msg.chat.id, rid)
    if ok:
        bot.reply_to(msg, f"✅ Запись R{rid} удалена. Баланс обновлён: {get_chat_store(msg.chat.id).get('balance',0)} ars", reply_markup=build_main_keyboard())
    else:
        bot.reply_to(msg, "Запись не найдена.", reply_markup=build_main_keyboard())


# --------------------------------------------
# ОТСЕК 7 — Обработка callback'ов (в одном окне)
# --------------------------------------------
@bot.callback_query_handler(func=lambda c: True)
def handle_callback(call):
    try:
        data_cd = call.data
        cid = call.message.chat.id
        mid = call.message.message_id

        # --- 💰 Баланс
        if data_cd == "btn_balance":
            store = get_chat_store(cid)
            text = f"💰 Баланс этого чата: {store.get('balance', 0)} ars"
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- 📊 Отчёт
        elif data_cd == "btn_report":
            recs = get_chat_store(cid).get("records", [])
            if not recs:
                text = "📋 Пока нет операций."
            else:
                text_lines = ["📋 Последние операции:"]
                for r in recs[-20:]:
                    sign = "+" if r["amount"] > 0 else ""
                    text_lines.append(f"{r['short_id']}: {sign}{r['amount']} — {r.get('note','')}")
                text = "\n".join(text_lines)
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- ⚙️ Сброс
        elif data_cd == "btn_reset":
            if str(call.from_user.id) != str(OWNER_ID):
                bot.answer_callback_query(call.id, text="Только владелец может сбрасывать данные.")
                return
            # сбрасываем только данные этого чата
            data["chats"].pop(str(cid), None)
            save_data(data)
            text = "✅ Все данные этого чата сброшены."
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- ✏️ Редактировать (показываем список в том же окне)
        elif data_cd == "btn_edit":
            kb = build_edit_list_keyboard(cid)
            text = "Выберите запись для редактирования или удаления:"
            bot.edit_message_text(text, cid, mid, reply_markup=kb)
            bot.answer_callback_query(call.id)

        # --- 🚀 Старт (обновляем текущее окно)
        elif data_cd == "btn_start":
            text = (
                f"🚀 Финансовый бот запущен (версия {VERSION})\n\n"
                "Доступные команды:\n"
                "/balance – показать баланс\n"
                "/report – последние операции\n"
                "/edit – редактировать запись\n"
                "/reset – сбросить все данные (только владелец)\n"
                "/cod – описание кода и обновления\n\n"
                "Чтобы добавить запись, отправьте: +1000 продажа  или  -500 еда"
            )
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- 📘 О коде (в одном окне)
        elif data_cd == "btn_cod":
            text = (
                f"📘 Финансовый бот — версия {VERSION}\n\n"
                "Краткое описание: интерфейс на русском, кнопки, автопостановка webhook, учёт по чатам.\n"
            )
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- кнопка Назад
        elif data_cd == "btn_back":
            bot.edit_message_text("Главное меню:", cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- ✏ Выбор для редактирования: сохраняем state + msg_id (чтобы потом перезаписать это окно)
        elif data_cd.startswith("edit_select:"):
            rid = int(data_cd.split(":")[1])
            chat_state = data.setdefault("tracked_messages", {})
            chat_key = str(cid)
            user_states = chat_state.setdefault(chat_key, {})
            # сохраняем, куда писать результат (msg_id) и что редактируем
            user_states[str(call.from_user.id)] = {"action": "edit_wait_value", "rid": rid, "msg_id": mid}
            save_data(data)
            text = f"Введите новое значение для R{rid} (например: +500 продажа)"
            # перезаписываем текущее окно, чтобы пользователю не приходило новое сообщение
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        # --- 🗑 Удаление записи (по кнопке) — обновляем то же окно
        elif data_cd.startswith("delete_record:"):
            rid = int(data_cd.split(":")[1])
            ok, rec = delete_record_in_chat(cid, rid)
            if ok:
                text = f"✅ Запись R{rid} удалена.\nБаланс обновлён: {get_chat_store(cid).get('balance',0)} ars"
            else:
                text = "⚠️ Запись не найдена."
            bot.edit_message_text(text, cid, mid, reply_markup=build_main_keyboard(cid))
            bot.answer_callback_query(call.id)

        else:
            bot.answer_callback_query(call.id)

    except Exception as e:
        log_error(f"Ошибка обработки callback: {e}")


# --------------------------------------------
# ОТСЕК 8 — Обработка входящих сообщений и пересылка (исправленный)
# --------------------------------------------
@bot.message_handler(func=lambda m: True, content_types=["text", "photo", "document", "voice", "video", "audio", "sticker"])
def handle_message(msg):
    # Игнорируем сообщения от ботов и без from_user
    if not getattr(msg, "from_user", None):
        return
    if msg.from_user.is_bot:
        return

    chat_id = msg.chat.id
    user_id = msg.from_user.id

    # --- 1. Проверка состояния редактирования (аналог /edit)
    chat_key = str(chat_id)
    user_states = data.setdefault("tracked_messages", {}).get(chat_key, {})
    state = user_states.get(str(user_id))
    if state and state.get("action") == "edit_wait_value":
        rid = state.get("rid")
        target_msg_id = state.get("msg_id")  # message id окна, которое нужно редактировать
        lines = msg.text.splitlines() if msg.content_type == "text" and msg.text else []
        if not lines:
            # обновляем то же окно с подсказкой
            bot.edit_message_text("Введите строку с числом, пример: +500 продажа.", chat_id, target_msg_id, reply_markup=build_main_keyboard(chat_id))
            return
        first_line = lines[0].strip()
        amt, token = extract_first_number(first_line)
        if amt is None:
            bot.edit_message_text("Число не обнаружено. Попробуйте ещё раз.", chat_id, target_msg_id, reply_markup=build_main_keyboard(chat_id))
            return
        m = num_re.search(first_line)
        note = first_line[m.end():].strip() if m else ""
        raw_token = token
        if raw_token.lstrip().startswith("+"):
            final_amt = amt
        elif raw_token.lstrip().startswith("-"):
            final_amt = amt
        else:
            final_amt = -abs(amt)
        ok, updated = update_record_in_chat(chat_id, rid, final_amt, note)
        # снять состояние ожидания
        user_states.pop(str(user_id), None)
        save_data(data)
        if ok:
            # перезаписываем исходное окно (msg_id) — там где пользователь нажимал редактировать
            bot.edit_message_text(f"✅ Запись R{rid} обновлена: {updated['amount']} — {updated.get('note','')}\nБаланс: {get_chat_store(chat_id).get('balance',0)} ars", chat_id, target_msg_id, reply_markup=build_main_keyboard(chat_id))
        else:
            bot.edit_message_text("Запись не найдена.", chat_id, target_msg_id, reply_markup=build_main_keyboard(chat_id))
        return

    # --- 2. Обработка processed_messages (чтобы не было дублей)
    processed = data.setdefault("processed_messages", [])
    msg_key = f"{chat_id}:{msg.message_id}"
    if msg_key in processed:
        # уже обработано (например, это копия, которую бот сам присылал в личку)
        return

    # --- 3. Определение владельца и флаг
    owner_int = None
    if OWNER_ID:
        try:
            owner_int = int(OWNER_ID)
        except Exception:
            owner_int = None
    is_owner_msg = (owner_int is not None and user_id == owner_int)

    # --- 4. Обработка текста/подписей (каждая строка — отдельная запись)
    # Обрабатываем текст и caption отдельно; при наличии — создаём записи в чате, где сообщение пришло.
    def process_lines_and_record(lines_list, target_chat):
        any_added_local = False
        for line in lines_list:
            line = line.strip()
            if not line:
                continue
            amt, token = extract_first_number(line)
            if amt is None:
                continue
            m = num_re.search(line)
            note = line[m.end():].strip() if m else ""
            raw_token = token
            if raw_token.lstrip().startswith("+"):
                final_amt = amt
            elif raw_token.lstrip().startswith("-"):
                final_amt = amt
            else:
                final_amt = -abs(amt)
            add_record_to_chat(target_chat, final_amt, note, user_id)
            any_added_local = True
        return any_added_local

    # Collect lines from text or caption
    lines_for_processing = []
    if msg.content_type == "text" and msg.text:
        lines_for_processing = msg.text.splitlines()
    elif msg.content_type in ["photo", "document", "video", "audio"] and getattr(msg, "caption", None):
        lines_for_processing = msg.caption.splitlines()


if lines_for_processing:
    added = process_lines_and_record(lines_for_processing, chat_id)

    # если сообщение пришло в личку бота (private) — редактируем текущее окно, а не создаём новое
    if msg.chat.type == "private" and added:
        try:
            last_msg_id = msg.message_id - 1  # последнее сообщение от бота
            new_text = f"✅ Записаны операции.\n💰 Баланс: {get_chat_store(chat_id).get('balance',0)} ARS"
            bot.edit_message_text(new_text, chat_id, last_msg_id, reply_markup=build_main_keyboard(chat_id))
        except Exception:
            # если не удалось отредактировать (нет предыдущего окна) — просто ответим
            bot.reply_to(msg, f"✅ Записано.\nБаланс: {get_chat_store(chat_id).get('balance',0)} ARS", reply_markup=build_main_keyboard(chat_id))
    elif added:
        # обычный случай — группы, чаты и т.п.
        bot.reply_to(msg, f"✅ Записаны операции.\nБаланс: {get_chat_store(chat_id).get('balance',0)} ARS", reply_markup=build_main_keyboard(chat_id))


#if lines_for_processing:
        # 1) Сначала добавляем записи в чат-источник (где сообщение пришло)
 #added = process_lines_and_record(lines_for_processing, chat_id)

        # 2) Если сообщение от владельца и бот копирует его в личку владельца,
        #    добавляем те же записи в личный чат владельца (чтобы персональная лента отражала операции),
        #    и помечаем будущую копию как обработанную (чтобы избежать повторного парсинга).
  #if is_owner_msg and owner_int is not None:
            # Добавим в личку владельца те же записи (если личка отличается от исходного чата)
   #if owner_int != chat_id:
   #process_lines_and_record(lines_for_processing, owner_int)
            # при копировании пометим будущую копию как processed — но сначала делаем копию и получаем объект отправленного сообщения
            # копируем сообщение во все targets (см. ниже); здесь пометим копию для owner, если он в targets
            # (это будет сделано при реальном копировании ниже)
  #if added:
            # ответим в том же чате (не создаём новое окно команды), используем edit если есть last bot message?
            # здесь безопасно отправить reply, но по твоему требованию стараемся минимизировать новые окна:
            # отправляем reply (короткое) — это не ломает остальной UX
  #bot.reply_to(msg, f"✅ Записаны операции. Баланс: {get_chat_store(chat_id).get('balance',0)} ars", reply_markup=build_main_keyboard(chat_id))
        # после обработки текстовых строк помечаем исходное как processed
    #processed.append(msg_key)
        # trim processed to reasonable length
     #if len(processed) > 1000:
     #processed = processed[-500:]
    #     data["processed_messages"] = processed
    #    save_data(data)
        # дальше продолжаем, но уже без повторной обработки
        # NB: не возвращим — потому что нужно ещё выполнить пересылку владельца (если он владелец)
        # но записи уже созданы

    # --- 5. Пересылка (если сообщение от владельца) — копирование в forward_targets (без эха)
    if is_owner_msg:
        for target in list(data.get("forward_targets", [])):
            try:
                t = int(target)
            except Exception:
                continue
            # не пересылаем в тот же чат
            if t == chat_id:
                # если владелец пишет в целевой чат — пересылаем в личку владельцу (если это не тот же чат)
                if owner_int and t != owner_int:
                    try:
                        sent = bot.copy_message(chat_id=owner_int, from_chat_id=chat_id, message_id=msg.message_id)
                        # помечаем скопированное сообщение как обработанное (чтобы при update/получении копии бот его не учёл снова)
                        if sent:
                            key = f"{sent.chat.id}:{sent.message_id}"
                            processed = data.setdefault("processed_messages", [])
                            processed.append(key)
                            if len(processed) > 1000:
                                processed = processed[-500:]
                            data["processed_messages"] = processed
                            save_data(data)
                        log_info(f"Владелец написал в цель {t} — переслано в личку {owner_int}")
                    except Exception as e:
                        log_error(f"Ошибка пересылки владельцу: {e}")
                continue
            # если пересылаем в другие цели
            try:
                sent = bot.copy_message(chat_id=t, from_chat_id=chat_id, message_id=msg.message_id)
                # помечаем и эти копии как processed, чтобы бот не обрабатывал их как новые входящие
                if sent:
                    key = f"{sent.chat.id}:{sent.message_id}"
                    processed = data.setdefault("processed_messages", [])
                    processed.append(key)
                    if len(processed) > 1000:
                        processed = processed[-500:]
                    data["processed_messages"] = processed
                    save_data(data)
                log_info(f"Переслано сообщение владельца в {t}")
            except Exception as e:
                log_error(f"Ошибка пересылки в {t}: {e}")


# --------------------------------------------
# ОТСЕК 9 — Flask webhook endpoints и автоустановка
# --------------------------------------------
@app.route("/", methods=["GET"])
def index():
    return f"Бот версия {VERSION} запущен."

@app.route("/webhook", methods=["POST"])
def webhook():
    try:
        raw = request.stream.read().decode("utf-8")
        update = telebot.types.Update.de_json(raw)
        bot.process_new_updates([update])
    except Exception as e:
        log_error(f"Ошибка в webhook: {e}")
    return "ok", 200

def ensure_webhook():
    try:
        webhook_url = f"{APP_URL.rstrip('/')}/webhook"
        info = requests.get(f"https://api.telegram.org/bot{TOKEN}/getWebhookInfo", timeout=10).json()
        current = info.get("result", {}).get("url", "")
        if current != webhook_url:
            r = requests.get(f"https://api.telegram.org/bot{TOKEN}/setWebhook", params={"url": webhook_url}, timeout=10)
            try:
                jr = r.json()
            except Exception:
                jr = {"ok": False, "description": r.text}
            if jr.get("ok"):
                log_info(f"Webhook установлен: {webhook_url}")
            else:
                log_error(f"Ошибка установки webhook: {jr}")
        else:
            log_info("Webhook уже установлен корректно.")
    except Exception as e:
        log_error(f"Ошибка проверки/установки webhook: {e}")

def notify_owner_start():
    if OWNER_ID is None:
        return
    try:
        owner_int = int(OWNER_ID)
    except Exception:
        return
    try:
        text = f"💬 Финансовый бот — версия {VERSION} запущен ✅"
        bot.send_message(owner_int, text, reply_markup=build_main_keyboard())
        log_info("Уведомление владельцу отправлено.")
    except Exception as e:
        log_error(f"Не удалось отправить уведомление владельцу: {e}")

# --------------------------------------------
# ОТСЕК 10 — Запуск приложения
# --------------------------------------------
if __name__ == "__main__":
    ensure_webhook()
    notify_owner_start()
    log_info(f"Бот запущен (версия {VERSION})")
    app.run(host="0.0.0.0", port=PORT)

# ============================================
# Конец кода — версия 9.6.1.6
# Всего строк: 655
# ============================================
